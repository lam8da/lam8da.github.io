<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4000/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2016-11-27T01:39:11-08:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>补胎和买车心得</title>
      <link>http://localhost:4000/2016/11/tire-repair/</link>
      <pubDate>2016-11-23T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/tire-repair</guid>
      <content:encoded><![CDATA[<p>昨天中午出门时发现车胎瘪了，应该是前天出去买菜路上扎的（后来汽车还报警说低气压，可是一直没在意，因为很久没打气了可能刚好气压低过阈值）。在网上做了一晚功课，决定先去找家修理行修车胎，如果不行再去walmart活着costco换。最后今天早上折腾两个多小时终于在wheel works免费修好，写上一些经验和总结以备以后不时之需。</p>

<ol>
  <li>去修理店，如果前台问扎了哪里，不要说扎在边缘上（即使真的离边缘很近），否则老板直接会说修不了建议换胎。总之，避免回答出任何可能导致老板建议换胎的答案。这样做的好处是：有机会把车子让修理师傅看一下，他说不能修才是不能修（这个不是前台说了算的因为他也不懂修，他的最终目的就是换胎赚你钱）</li>
  <li>车子常备一个手动打气筒（电动的应该也行，但我担心电动的由于各种原因在特发情况下不work，手动的应该总是能work的）</li>
  <li>个人觉得那些应急自救包（例如某种神喷射剂，需要自己拔出钉子往里喷，可以坚持好一会的那种；又例如手工修理包，walmart很便宜几块钱那种）貌似没什么用。如果不是专家或有经验，发现被扎后千万不要拔钉，最好打气看看漏得严不严重，如果不严重可以直接开到修理店修。如果拔钉，有可能自救包修不好，就只能千斤顶了；马路上太危险，要么就花（几百块？）叫个拖车？当然，买个应急包还是有用的，万一漏气很严重呢？要把所有可能都想到。</li>
</ol>

<p>另附上之前买车的心得：</p>

<ol>
  <li>在truecar上找个quote，找到所有match该价格的买家</li>
  <li>第一家看车一定不能选你最想买的那家：你要先了解情况，试驾，试探市场情况和卖家的情况。这样去下一家的时候心里有数。当然你还是要狠狠的砍价，往比truecar低（例如好几百）的价格砍。注意，truecar也是被他们控制了的。</li>
  <li>找好一个贷款银行，写个preapproval letter，不然车行的利率会很难看（他们可以控制利率）</li>
  <li>砍价或者下offer时不要说你手头上有preapproval
letter，否则当卖家得知自己不能控制利率可能就不会同意更低的价格</li>
  <li>dealer签字时推荐你的各种优惠package不要买（当然除非你非常有必要），他们就是想忽悠你赚钱</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>读《时间的形状：相对论史话》</title>
      <link>http://localhost:4000/2016/11/shape-of-time-notes/</link>
      <pubDate>2016-11-20T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/shape-of-time-notes</guid>
      <content:encoded><![CDATA[<p>这本书的逻辑性很好，从历史的角度介绍了经典物理学在20世纪初遇到的难题以及新理论的提出的过程，让非专业读者都能理解相对论的基本内容。</p>

<h2 id="section">第一章 不得不说的废话</h2>

<ol>
  <li>所有的物理定律都无法被证实，只能被证伪。只有满足了“预言”和“证伪”两个条件，才能冠以科学之名。如果提出一个理论并且其做出的预言永远不能被实验推翻，这个就可以称为伪科学。</li>
  <li>奥卡姆剃刀原理：如果发现一个很奇怪的现象，要对它进行解释而不得不做很多各种各样的假设，则那个需要假设最少的解释往往是最接近真相的解释。例：以太学说（假设以太存在vs光速不变）</li>
</ol>

<h2 id="section-1">第二章 伽利略和牛顿的世界</h2>

<ol>
  <li>伽利略相对性原理：在任何惯性系中，力学规律保持不变</li>
  <li>伽利略变换</li>
</ol>

<h2 id="section-2">第三章 光的速度</h2>

<p>麦克斯韦方程组预言了电磁波的存在，赫兹发现了电磁波并测量了其传播速度，发现等于光速，证实光是一种电磁波。根据麦克斯韦的理论，波的传播速度是相对于介质而言的，不受波源运动速度的影响。于是，光在不同情况下的速度的异同就成了以太是否存在的关键证据。迈克尔逊-莫雷实验却表明：光速在所有情况下都不变。这成了20世纪初物理学第一朵乌云。</p>

<h2 id="section-3">第四章 爱因斯坦和狭义相对论</h2>

<p>在第一朵乌云笼罩下，物理学家都试图用各种解释来说明以太的存在与光速不变不矛盾。只有爱因斯坦开创性地抛弃以太说，引入光速不变原理和（狭义）相对性原理，推导出运动物体的时间膨胀和空间收缩性质（洛伦兹变换）以及新的速度合成公式（合成速度不可能超过光速）。进一步，为了解决”运动速度超过光速会怎样“的问题，爱因斯坦推导出质速关系式（任何有质量物体运动速度都不可能超过光速，否则质量会变成无穷大），准确地说，没有能量和信息的传播速度能超过光速。更进一步，从动能定理和质速关系式出发，爱因斯坦推导出质能方程。</p>

<p>如何理解狭义相对论：</p>
<ul>
  <li>双生子佯谬</li>
  <li>长棍佯谬</li>
  <li>潜水艇佯谬</li>
</ul>

<h2 id="section-4">第五章 广义相对论的宇宙</h2>

<ol>
  <li>爱因斯坦通过思想实验研究<a href="https://zh.wikipedia.org/wiki/%E7%AD%89%E6%95%88%E5%8E%9F%E7%90%86">弱等效原理</a>：观测者不能在局部的区域内分辨出由加速度所产生的惯性力或由物体所产生的引力，而它是由引力质量与惯性质量成正比例这一事实推演出来。通过弱等效原理和思想实验推导出引力会弯曲光线。更进一步，通过”爱因斯坦圆盘实验“，结合狭义相对论，我们可以推导出引力是把时间和空间都弯曲了。</li>
  <li>相对于地面上来说，在地球的高山上的物体运动得快（由于地球自转），根据狭义相对论时间会变慢，而根据广义相对论高山上引力变小因此时间会变快。根据精确计算，广义相对论造成的影响更大。</li>
  <li>引力波的传播速度也是光速。</li>
  <li>爱因斯坦引力场方程成功解释了水星进动现象，爱丁顿进行星光实验进一步验证其正确性</li>
  <li>广义相对论的推论
    <ul>
      <li>黑洞的存在</li>
      <li>白洞</li>
      <li>场方程的一个解允许虫洞（即爱因斯坦-罗森塔尔桥）的存在，虫洞的一端是黑洞另一端是白洞</li>
      <li>宇宙正在加速膨胀</li>
      <li>宇宙有界无限（希尔伯特空间）</li>
    </ul>
  </li>
</ol>

<h2 id="section-5">第六章 红色革命</h2>

<p>主要描述魏嗣銮，相对论在中国的早期传播者之一，被文化大革命打压的历史。我们不希望这样的历史在当今世界重演。</p>

<h2 id="section-6">第七章 时空那点事</h2>

<ul>
  <li>闵可夫斯基四维空间：所有物体的运动速度在该空间中都是光速c。一个物体在三维空间中的速度越快，在时间维度上的速度越慢（根据勾股定理）。光在三维空间中速度达到极限，因此在时间维度上停滞（我们现在看到的遥远星系发出来的光是几十亿年前的光，没有任何变化）</li>
  <li>莫比乌斯带和克莱恩瓶</li>
  <li>如何避免时间旅行带来的逻辑悖论（如回到过去杀死自己的祖母）
    <ul>
      <li>自由意志丧失说</li>
      <li>时空交错说：历史不能被改变，只能被观察</li>
      <li>多历史说（Feynman）：平行世界？</li>
    </ul>
  </li>
  <li>可以制作出一种手表，当速度变化时，其频率随着变化。这样在星际旅行时就能准确知道地球上的时间（即假如这一刻我在地球上，地球上的时间）。</li>
  <li>星际贸易的经济学</li>
</ul>

<h2 id="section-7">第八章 再谈四维空间</h2>

<ul>
  <li>闵可夫斯基四维空间与光锥</li>
  <li>四维空间在三维上的投影和展开</li>
  <li>爱因斯坦认为这个宇宙是：
    <ul>
      <li>定域的：一个事件的将来光锥决定了这个事件对时空的影响范围，而它的过去光锥决定了怎样的时空范围可以影响到这个事件本身，过去光锥和将来光锥都是有大小和形状的，任何事件之间都不可能超越这个范围而产生互相影响</li>
      <li>客观存在的：宇宙万物的运动规律独立于观察者而存在，与观察者（人类）的存在与否无关</li>
      <li>因果律：如果知道宇宙某一时刻的状态且有足够的计算能力，我们就能知道下一刻的状态</li>
    </ul>
  </li>
</ul>

<h2 id="section-8">第九章 上帝的判决</h2>

<ol>
  <li>双缝干涉实验：如果一次只释放一个粒子（光子，电子，etc），在重复这个实验多次以后，仍能得到干涉条纹。问：为什么得到的图像不是两个单缝图像的简单叠加？即单个粒子在穿越一个缝的时候是如何知道另一个缝的存在？</li>
  <li>波尔的解释（哥本哈根解释）：光子同时通过了两个缝</li>
  <li>进一步实验揭示：一旦电子被观测到了（哪怕是电子通过了双缝之后再去观测），干涉条纹便消失了；如果不去观测，又重新出现干涉条纹
    <ul>
      <li><a href="https://zh.wikipedia.org/wiki/%E6%83%A0%E5%8B%92%E5%BB%B6%E8%BF%9F%E9%80%89%E6%8B%A9%E5%AE%9E%E9%AA%8C">惠勒延迟选择实验</a>：通过了双缝之后再去观测</li>
    </ul>
  </li>
  <li>波尔：没有因果律，只有互补原理</li>
  <li>爱因斯坦提出了爱因斯坦-波多尔斯基-罗森（EPR）佯谬，揭示了量子力学的非定域性与我们常识之间的矛盾。
    <ul>
      <li>然后，他进一步把这个想法推广，设想了一桶不稳定的炸药，经过一段时间后，炸药处于爆炸与不爆炸之间的量子叠加态。薛定谔受此启发，把宏观量子叠加态推广到了生命体，提出了处于死与活量子叠加态的薛定谔的猫。这个思维实验提出了一个很尖锐的问题，宏观的量子叠加态何时退化为确定的经典状态？难道是在打开容器的那一瞬间么？摘自<a href="http://www.guokr.com/article/440829/">果壳网</a></li>
    </ul>
  </li>
  <li><a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9A%E7%90%86">贝尔不等式</a>使得EPR实验的检验成为可能。如果实验结果违反了贝尔不等式，说明：
    <ul>
      <li>真有超光速的信号存在，两个量子间可以瞬间相互知道对方的状态（违反定域性）；或者</li>
      <li>量子的自旋状态不是一个客观实在，在我们观测之前不存在确定状态，只有我们观测之后状态才确定（违反客观实在性）</li>
    </ul>
  </li>
</ol>

<h2 id="section-9">第十章 宇宙是一首交响乐</h2>

<ol>
  <li>万物理论，弦论</li>
  <li>两个基本问题：
    <ul>
      <li>物质的最小构成单位：如何击碎粒子（粒子加速器）</li>
      <li>用一个统一的理论解释四种基本作用力（引力，电磁力，强核力，弱核力）</li>
    </ul>
  </li>
  <li>超弦理论与欧拉贝塔函数</li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Blogging Resources</title>
      <link>http://localhost:4000/2016/11/welcome-to-jekyll/</link>
      <pubDate>2016-11-07T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/welcome-to-jekyll</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#resources" id="markdown-toc-resources">Resources</a></li>
  <li><a href="#code-block-highlighting" id="markdown-toc-code-block-highlighting">Code block highlighting</a>    <ul>
      <li><a href="#how-to-use-highlighter" id="markdown-toc-how-to-use-highlighter">How to use highlighter</a></li>
      <li><a href="#how-to-highlight-inlined-code-blocks" id="markdown-toc-how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</a></li>
    </ul>
  </li>
  <li><a href="#block-inline-attribute-lists-ial" id="markdown-toc-block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</a></li>
  <li><a href="#math-equations" id="markdown-toc-math-equations">Math equations</a></li>
  <li><a href="#tables" id="markdown-toc-tables">Tables</a></li>
</ul>

<h2 id="resources">Resources</h2>
<ol>
  <li>git commands manual: <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></li>
  <li>markdown manual: <a href="http://www.appinn.com/markdown/">http://www.appinn.com/markdown/</a></li>
  <li>kramdown
    <ul>
      <li>quickref/examples: <a href="http://kramdown.gettalong.org/quickref.html">http://kramdown.gettalong.org/quickref.html</a></li>
      <li>syntax/manual: <a href="http://kramdown.gettalong.org/syntax.html">http://kramdown.gettalong.org/syntax.html</a></li>
    </ul>
  </li>
  <li>rouge options: <a href="https://github.com/jneen/rouge#full-options">https://github.com/jneen/rouge#full-options</a></li>
  <li>latex cheat sheet: <a href="https://wch.github.io/latexsheet/">https://wch.github.io/latexsheet/</a></li>
  <li><a href="http://jekyllrb.com/docs/home">Jekyll docs</a></li>
</ol>

<h2 id="code-block-highlighting">Code block highlighting</h2>

<h3 id="how-to-use-highlighter">How to use highlighter</h3>
<!-- Overwrite the setting to not show line_numbers in fenced code blocks -->

<p>Code block using kramdown (<strong>may not be compactible if not using kramdown</strong>):</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span>
</code></pre>
</div>

<p>Code block using Pygments or Rouge by using the <code class="language-ruby highlighter-rouge"><span class="n">highlight</span></code> Liquid tag
(<strong>putting it inside a list will work incorrectly</strong>):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</h3>

<p>I discovered in 11/12/2016 that all (inlined) code blocks generated by rouge are
wrapped by a
<code class="language-ruby highlighter-rouge"><span class="nt">&lt;code&gt;</span></code>
tag with css class set to</p>
<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="nt">language-some_language</span> <span class="nt">highlighter-rouge</span>
</code></pre>
</div>
<p>. So we can copy the highlight.css to highlighter-rouge.css and make same css
rules applicable to</p>
<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="nt">highlighter-rouge</span> <span class="nt">span_css_class</span>
</code></pre>
</div>
<p>(e.g. <code class="language-ruby highlighter-rouge"><span class="nt">highlighter-rouge</span> <span class="nt">cp</span></code>).</p>

<p>If the code block is just a block of text, not code, we can append
<code class="language-ruby highlighter-rouge"><span class="p">{</span><span class="ss">:language</span><span class="o">-</span><span class="n">nothing</span><span class="p">}</span></code> to the end of the block to make rouge not generate
colorful html representations. E.g.</p>
<div class="language-markdown highlighter-rouge"><pre class="highlight"><code><span class="sb">`int i = 0;`</span>{:.language-nothing}
</code></pre>
</div>
<p>looks like: <code class="language-nothing">int i = 0;</code></p>

<h2 id="block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</h2>

<p id="para-one">A simple paragraph with an ID attribute.</p>

<blockquote title="The blockquote title" id="myid">
  <p>A blockquote with a title</p>
</blockquote>

<div class="language-ruby ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Some</span> <span class="n">code</span> <span class="n">here</span>
</code></pre>
</div>

<h2 id="math-equations">Math equations</h2>

<script type="math/tex; mode=display">a = b</script>

<script type="math/tex; mode=display">\Large a = b</script>

<h2 id="tables">Tables</h2>

<p>Table with header row:</p>

<table>
  <thead>
    <tr>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
  </tbody>
</table>

<p>Table without header row:</p>

<table>
  <tbody>
    <tr>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
  </tbody>
</table>

]]></content:encoded>
    </item>
    
    <item>
      <title>拜占庭将军问题</title>
      <link>http://localhost:4000/2014/03/byzantine-general-problem/</link>
      <pubDate>2014-03-08T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2014/03/byzantine-general-problem</guid>
      <content:encoded><![CDATA[<p>工作之余，花了一周的几乎每个晚上把Lamport神的那篇有关拜占庭将军问题的文章看完了。在这里做下笔记。</p>

<p>个人觉得最难懂的就是OM算法，我将它理解成一个动态规划：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">// @c is the commander id;
// @l is one of the lieutenant id, which belongs to the current lieutenant set;
// @m is the parameter m mentioned in the paper;
// OM(c, l, m) means the final value lieutenant @l obeys from commander @c.
</span>
<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span> <span class="n">where</span> <span class="n">l</span> <span class="n">in</span> <span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">};</span>

<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">majority</span><span class="p">(</span>
  <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span>
  <span class="n">the</span> <span class="n">list</span> <span class="n">of</span> <span class="n">OM</span><span class="p">(</span><span class="n">l</span><span class="err">'</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">where</span> <span class="n">l</span><span class="err">'</span> <span class="n">in</span> <span class="p">(</span><span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">l</span><span class="p">})</span>
<span class="p">).</span>  <span class="c1">// majority
</span></pre></td></tr></tbody></table>
</div>
</div>

<p>实际上，准确来说上面的状态表示是不完全的，OM的第一个参数应该是一个commander的id列表，表示从算法开始的第一个commander通过发消息沿途产生的所有commander。这样说起来还是很抽象，具体还是看下文代码吧。</p>

<p>为了让自己有更深的理解，我用C++实现了一个模拟器，输入general的个数，指定commander是否loyal，模拟算法运行，打印出每条消息以及消息路径，最后得出每个忠诚的lieutenant遵守的命令。目测+用小数据测试没有发现错误，也贴在这里供以后回顾使用。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208</pre></td><td class="code"><pre><span class="cp">#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
</span> 
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">num_generals</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">commander_is_loyal</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_loyal</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
 
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ValueType</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ValueType</span> <span class="n">kDefaultValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999999999</span><span class="p">;</span>
 
<span class="c1">// Classic algorithm to find the majority: maintain a value and
// a counter, when see a same value, ++counter; otherwise, if
// counter is 0, set the value to the one we see and let counter=1,
// or if counter&gt;0, --counter.
</span><span class="k">struct</span> <span class="n">MajorityCount</span> <span class="p">{</span>
  <span class="n">ValueType</span> <span class="n">majority</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">seen</span><span class="p">;</span>
 
  <span class="n">MajorityCount</span><span class="p">()</span> <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">kDefaultValue</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">MajorityCount</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
 
  <span class="n">MajorityCount</span><span class="o">&amp;</span> <span class="n">Merge</span><span class="p">(</span><span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">seen</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">majority</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">majority</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">": val="</span> <span class="o">&lt;&lt;</span> <span class="n">majority</span>
         <span class="o">&lt;&lt;</span> <span class="s">", cnt="</span> <span class="o">&lt;&lt;</span> <span class="n">count</span>
         <span class="o">&lt;&lt;</span> <span class="s">", seen="</span> <span class="o">&lt;&lt;</span> <span class="n">seen</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">MajorityCount</span><span class="o">&gt;</span> <span class="n">MapType</span><span class="p">;</span>
<span class="n">MapType</span> <span class="n">val_storage</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="nf">RandomShuffle</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">begin</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Itoa</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">res</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sprintf</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Join</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">delim</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Itoa</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ValueType</span> <span class="nf">RandomValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// return std::rand() % 97;
</span>  <span class="k">return</span> <span class="mi">250</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">// Updates the value of OM(c, l, m) using OM(l', l, m-1).
</span><span class="kt">void</span> <span class="nf">MergeUp</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key_vec</span> <span class="o">=</span> <span class="n">passed_ids</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">back</span> <span class="o">=</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">string</span> <span class="n">src_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">required_num_seen</span> <span class="o">=</span> <span class="n">remaining_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
 
  <span class="k">while</span> <span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dst_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
 
    <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">[</span><span class="n">dst_key</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span><span class="n">val_storage</span><span class="p">[</span><span class="n">src_key</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">back</span><span class="p">])</span> <span class="n">mc</span><span class="p">.</span><span class="n">majority</span> <span class="o">=</span> <span class="n">RandomValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">seen</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"    "</span> <span class="o">&lt;&lt;</span> <span class="n">src_key</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">dst_key</span><span class="p">;</span>
    <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">src_key</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">==</span> <span class="n">required_num_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src_key</span> <span class="o">=</span> <span class="n">dst_key</span><span class="p">;</span>
      <span class="o">++</span><span class="n">required_num_seen</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// Sequential algorithm: for simplicity, assume that each lieutenant
// will send messages to others when needed.
</span><span class="kt">void</span> <span class="nf">OM</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">commander_id</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ValueType</span> <span class="o">&amp;</span><span class="n">received_val</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span>  <span class="c1">// the last one is commander_id.
</span>        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// {1, 2, ..., n-1} - passed_ids
</span>  <span class="k">const</span> <span class="n">string</span> <span class="n">prefix_path</span> <span class="o">=</span>
      <span class="n">Join</span><span class="p">(</span><span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids_copy</span><span class="p">(</span><span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
      <span class="n">ValueType</span> <span class="n">val_to_send</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">commander_id</span><span class="p">]</span> <span class="o">?</span> <span class="n">received_val</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">());</span>
 
      <span class="c1">// OM(m), step (1)
</span>      <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="n">prefix_path</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">Itoa</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span>
        <span class="n">val_storage</span><span class="p">[</span><span class="n">path</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span>
            <span class="n">MajorityCount</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">val_to_send</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">;</span>
      <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
      <span class="c1">// OM(m), step (2)
</span>      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">seen</span> <span class="o">==</span> <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">OM</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val_to_send</span><span class="p">,</span> <span class="n">passed_ids</span><span class="p">,</span> <span class="n">remaining_ids</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+++++++++++++++++++++++++++++++++"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">,</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"num_generals: "</span><span class="p">,</span>
         <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num_generals</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m: "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"commander_is_loyal? "</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">commander_is_loyal</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">RandomShuffle</span><span class="p">(</span><span class="n">is_loyal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">passed_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_generals</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">remaining_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="c1">// commander_id=0, received_val=618
</span>    <span class="n">OM</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">618</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">);</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（下）- 设计模式</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes2/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes2</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">策略模式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">观察者模式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">装饰者模式</a></li>
  <li><a href="#factory-method-pattern" id="markdown-toc-factory-method-pattern">工厂方法模式（Factory Method Pattern）</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">抽象工厂模式</a></li>
  <li><a href="#singleton-pattern" id="markdown-toc-singleton-pattern">单件模式（Singleton Pattern）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">命令模式（封装调用）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">适配器模式</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">外观模式</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">模板方法模式</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">迭代器模式</a></li>
  <li><a href="#section-9" id="markdown-toc-section-9">组合模式</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">状态模式</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">代理模式</a></li>
  <li><a href="#mvc--" id="markdown-toc-mvc--">MVC：模型-视图-控制器</a></li>
  <li><a href="#section-12" id="markdown-toc-section-12">模式分类</a></li>
</ol>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">策略模式</h2>

<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.strategy.png" alt="strategy" /></p>

<h2 id="section-1">观察者模式</h2>

<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。以下是Java的观察者模式：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.observers.png" alt="observers" /></p>

<ol>
  <li>出版者+订阅者=观察者模式</li>
  <li>不要依赖于观察者被通知的次序，因为一旦观察者/可观察者的实现有所改变，通知次序就会改变，很可能就会产生错误的结果，这绝对不是我们认为的松耦合</li>
  <li><code class="language-java highlighter-rouge"><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Observale</span></code>的黑暗面：<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>是一个类，如果某类想同时具有<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承，这限制了<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>的复用潜力；另外，<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>将关键方法（<code class="language-java highlighter-rouge"><span class="n">setChanged</span><span class="o">()</span></code>）保护起来，这个设计违反了设计原则：多用组合，少用继承。</li>
</ol>

<h2 id="section-2">装饰者模式</h2>

<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.decorator.png" alt="decorator" /></p>

<ol>
  <li>如上述类图关系，重点在于，装饰者和被装饰者必须是一样的类型，也就是有同样的超类，这相当关键。在这里，我们利用继承达到“类型匹配”而不是获得“行为”。</li>
  <li>为何装饰者和被装饰者有相同的接口：因为装饰者必须能取代被装饰者。</li>
  <li>通常装饰者模式是采用抽象类，但是在Java中可以使用接口</li>
</ol>

<h2 id="factory-method-pattern">工厂方法模式（Factory Method Pattern）</h2>

<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类，通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>

<p>工厂模式具有平行的类层级：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.factory.png" alt="factory" /></p>

<ol>
  <li>当可能有许多客户程序通过各种方法来创建一个类型的新对象时，可以考虑到把创建这个对象的方法放到一个工厂中去，即使用工厂模式。所有工厂模式都用来封装对象的创建。</li>
  <li>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。工厂方法不一定要真的放到一个非本类的“工厂类”中。</li>
  <li>使用“工厂”意味着客户在实例化对象时，只会依赖于接口而不是具体类。这符合依赖倒置原则。</li>
</ol>

<h2 id="section-3">抽象工厂模式</h2>

<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.abstract-factory.png" alt="abstract-factory" /></p>

<ol>
  <li>抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法</li>
  <li>抽象工厂和工厂方法都是负责创建对象，工厂方法用的方法是继承，抽象工厂是通过对象的组合</li>
  <li>当需要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂；而工厂方法可以把客户代码从需要实例化的具体类中解耦，或如果目前还不知道将来需要实例化哪些具体类时，也可以用工厂方法。</li>
  <li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
</ol>

<h2 id="singleton-pattern">单件模式（Singleton Pattern）</h2>

<p>单件模式用来创建独一无二的、只能有一个实例的对象。</p>

<ol>
  <li>实现方法：若将对象赋值给一个全局变量，那么必须在程序一开始就创建好对象。万一这个对象非常耗资源，而程序在这次执行过程中又一直没用到它，就会形成浪费。</li>
  <li>
    <p>单件模式实现中处理多线程问题的方法：</p>

    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span><span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
    </div>
    <p>使用<code class="language-java highlighter-rouge"><span class="kd">synchronized</span></code>关键字可能会导致效率严重下降。而volatile关键字定义的成员变量确保在同一时间最多只有一个线程对其进行访问，尤其是32位系统处理64位变量时。另外，也可以使用“急切”创建实例而不用延迟实例，在静态初始化器（static initializer）中创建单位：</p>

    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</code></pre>
    </div>
    <p>但这样会导致1中提到的问题。</p>
  </li>
</ol>

<h2 id="section-4">命令模式（封装调用）</h2>

<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.command.png" alt="command" /></p>

<ol>
  <li>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式</li>
  <li>宏命令模式：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.macro-command.png" alt="macro-command" /></p>

<h2 id="section-5">适配器模式</h2>

<p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.adapter.png" alt="adapter" /></p>

<h2 id="section-6">外观模式</h2>

<p>外观模式改变接口，将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观，让接口更简单。</p>

<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>

<h2 id="section-7">模板方法模式</h2>

<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>

<ol>
  <li>模板方法不一定要使用继承，例如c++的stl的排序方法使用的比较函数</li>
  <li>常见形式：
    <ul>
      <li>抽象方法：当子类必须提供算法中某个步骤的实现时使用</li>
      <li>钩子：当算法某个部分可选时使用</li>
    </ul>
  </li>
  <li>为了防止子类改变模板方法中的算法，可以将模板方法声明为<code class="language-java highlighter-rouge"><span class="kd">final</span></code></li>
</ol>

<h2 id="section-8">迭代器模式</h2>

<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.iterator.png" alt="iterator" /></p>

<h2 id="section-9">组合模式</h2>

<p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.composite.png" alt="composite" /></p>

<p>组合模式是让一个类有两个责任的模式，它不但要管理层次结构，而且还要执行菜单的操作。但组合模式以单一责任设计原则换取透明性（transparency）：通过让组件的接口同事包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁，这是一个很典型的折中案例。</p>

<h2 id="section-10">状态模式</h2>

<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.state.png" alt="state" /></p>

<p>上述<code class="language-java highlighter-rouge"><span class="n">ConcreteStateA</span></code>和<code class="language-java highlighter-rouge"><span class="n">ConcreteStateB</span></code>对<code class="language-java highlighter-rouge"><span class="n">Context</span></code>的引用并不是必须的。有时<code class="language-java highlighter-rouge"><span class="n">Context</span></code>本身也可以决定状态转换的流向。当状态转换是固定时（例如做了某个动作后就一定转换到某特定状态），就适合放在<code class="language-java highlighter-rouge"><span class="n">Context</span></code>中。当转换更动态的时候，通常就会放在状态类中。做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭。</p>

<p>多个<code class="language-java highlighter-rouge"><span class="n">Context</span></code>实例可共享状态对象（使用静态变量）。若状态需要利用<code class="language-java highlighter-rouge"><span class="n">Context</span></code>中的方法，还必须在每个<code class="language-java highlighter-rouge"><span class="n">handler</span><span class="o">()</span></code>方法内传入一个<code class="language-java highlighter-rouge"><span class="n">Context</span></code>引用。</p>

<h2 id="section-11">代理模式</h2>

<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.proxy.png" alt="proxy" /></p>

<ol>
  <li>几种代理模式：
    <ul>
      <li>远程代理：控制访问远程对象</li>
      <li>虚拟代理：控制访问创建开销大的资源</li>
      <li>保护代理：基于权限控制对资源的访问</li>
      <li>防火墙代理（Firewall Proxy）</li>
      <li>智能引用代理（Smart Reference Proxy）</li>
      <li>缓存代理（Caching Proxy）</li>
      <li>同步代理（Synchronization Proxy）</li>
      <li>复杂隐藏代理（Complexity Hiding Proxy）</li>
      <li>写入时复制代理（Copy-On-Write Proxy）</li>
    </ul>
  </li>
  <li>Java RMI（远程过程调用）
    <ul>
      <li>java.rmi.Remote</li>
      <li>stub、skeleton</li>
      <li>rmic、rmiregistry工具</li>
      <li>transient关键字：告诉Java不要序列化一个对象</li>
    </ul>
  </li>
  <li>Java的动态代理技术：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.java-dynamic-proxy.png" alt="java-dynamic-proxy" /></p>

<h2 id="mvc--">MVC：模型-视图-控制器</h2>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc.png" alt="mvc" /></p>

<p>图解：</p>

<ol>
  <li>策略模式：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略</li>
  <li>视图用组合模式组织各窗口、面板、按钮等</li>
  <li>模型实现了观察者模式，当状态改变时通知对象更新。这使得同一模型可以使用不同的视图甚至可使用多个视图</li>
  <li>不同接口的模型常常通过适配器模式复用同一个视图</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc-web.png" alt="mvc-web" /></p>

<p>上图是Web中的MVC，称为Model 2（Servlet+JSP）。</p>

<p>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p>

<h2 id="section-12">模式分类</h2>

<p>模式是在某情景下，针对某问题的某种解决方案。模式可分为以下几类：</p>

<ul>
  <li>创建型：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。包括：Singleton、Builder、Prototype、Abstract Factory、Factory Method</li>
  <li>行为型：设计到类和对象如何交互及分配的职责。包括：Template Method、Visitor、Mediator、Iterator、Command、Memento、Interpreter、Observer、Chain of Responsibility、State、Strategy</li>
  <li>结构型：可让你把类或对象组合到更大的结构中。包括：Decorator、Proxy、Composite、Façade、Flyweight、Bridge、Adapter</li>
</ul>

<p>反模式告诉你如何采用一个不好的解决方案解决一个问题，告诉你为何这个方案从长远看会造成不好的影响，警告你不要陷入某种致命的诱惑，建议你改用其他的模式以提供更好的解决方案。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（上）- 设计原则</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes1/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes1</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">封装变化</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">针对接口编程，而不是针对实现编程</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">多用组合，少用继承</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">为了交互对象之间的松耦合设计而努力</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">类应该对扩展开放，对修改关闭</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">要依赖抽象，不要依赖具体类</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">最小知识原则</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">好莱坞原则</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">应尽量让每个类保持单一责任</a></li>
</ol>

<h2 id="section">封装变化</h2>

<p>找出应用中可能需要变化之处，把它们独立出来（并封装起来），不要和那些不要变化的代码混在一起。</p>

<p>如果每次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分</p>

<h2 id="section-1">针对接口编程，而不是针对实现编程</h2>

<p>以前的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于“实现”，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p>

<p>“针对接口编程”真正的意思是“针对超类型（supertype）编程”，货可以更明确地说成“变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口”。</p>

<h2 id="section-2">多用组合，少用继承</h2>

<p>良好的OO设计必须具备可复用、可扩充、可维护三个特性。大多数的模式都允许系统局部改变独立于其他部分</p>

<h2 id="section-3">为了交互对象之间的松耦合设计而努力</h2>

<h2 id="section-4">类应该对扩展开放，对修改关闭</h2>

<h2 id="section-5">要依赖抽象，不要依赖具体类</h2>

<p>依赖倒置原则（Dependency Inversion Principle）：不能让高层组件依赖低层组件，而且，不管高层或低层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。</p>

<p>一下指导方针能帮助避免在OO设计中违反依赖倒置原则：</p>

<ol>
  <li>变量不可以持有具体类的引用</li>
  <li>不要让类派生自具体类</li>
  <li>不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</li>
</ol>

<h2 id="section-6">最小知识原则</h2>

<p>减少对象之间的交互，不要让太多的类耦合在一起。</p>

<p>指导方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>

<ol>
  <li>该对象本身</li>
  <li>被当做方法的参数而传进来的对象</li>
  <li>此方法所创建或实例化的任何对象</li>
  <li>对象的任何组件（Has-A）</li>
</ol>

<p>注意，如果某对象是调用其他方法的返回结果，不要调用该对象的方法！</p>

<h2 id="section-7">好莱坞原则</h2>

<p>别调用（打电话给）我们，我们会调用（打电话给）你（将决策权放在高层模块中）。</p>

<p>例如模板方法模式中，低层组件绝对不可以直接调用高层组件。</p>

<h2 id="section-8">应尽量让每个类保持单一责任</h2>

<p>因为一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域。如果一个类具有两个改变的原则，那么这会使得将来该类变化的几率上升；而当它真的改变时，你的设计中同时有两个方面将受到影响。</p>

<p>术语：</p>
<ul>
  <li>内聚（cohesion）：用来度量一个类或模块紧密地达到单一目的或责任</li>
  <li>高内聚：一个模块/类被设计成只支持一组相关功能</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第17-18章完）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第17章 用于大型程序的工具</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第18章 特殊工具与技术</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第17章 用于大型程序的工具</h2>

<ol>
  <li>承诺不抛出任何异常的方法：<code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{}</span></code></li>
  <li>
    <p>命名空间别名（像定义变量一样）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span>  <span class="c1">// n2是一个已定义的命名空间
</span></code></pre>
    </div>
  </li>
  <li>
    <p>屏蔽命名空间名字规则的一个重要例外：接受类类型形参（或类类型指针及引用形参）的函数（包括重载操作符），以及与类本身定义在同一命名空间中的函数（包括重载操作符），在用类类型对象（或类类型的引用及指针）作为实参的时候是可见的。如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// ok
</span></code></pre>
    </div>
    <p>当compiler看到<code class="language-c++ highlighter-rouge"><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span></code>时，它在当前作用域、包含调用的作用域以及定义<code class="language-c++ highlighter-rouge"><span class="n">cin</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>的命名空间中查找匹配的函数。</p>
  </li>
  <li>在最底层派生类的构造函数中，c++会首先初始化虚基类；在初始化中间层派生类时，忽略它们对虚基类的初始化。</li>
</ol>

<h2 id="section-1">第18章 特殊工具与技术</h2>

<ol>
  <li>c++提供以下两种方法分配和释放未构造的原始内存：<code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>类；标准库中的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>和<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>。</li>
  <li>c++还提供不同的方法在原始内存中构造和撤销对象：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>类的construct和destroy成员</li>
      <li>定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式（placement new expression）接受指向未构造内存的指针，并在该空间中初始化一个对象或一个数组</li>
      <li>可直接调用对象的析构函数来撤销对象。运行析构函数并不释放所在内存</li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">uninitialized_fill</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">uninitiated_copy</span></code></li>
    </ul>
  </li>
  <li>
    <p><code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>接口（只分配/释放空间，不构造/析构）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式（在已分配但未构造的内存中初始化对象）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">new</span> <span class="p">(</span><span class="n">place_address</span><span class="p">)</span> <span class="n">type</span>
<span class="k">new</span> <span class="p">(</span><span class="n">place_address</span><span class="p">)</span> <span class="n">type</span> <span class="p">(</span><span class="n">initializer_list</span><span class="p">)</span>
</code></pre>
    </div>
    <p>其中<code class="language-c++ highlighter-rouge"><span class="n">place_address</span></code>是指针，<code class="language-c++ highlighter-rouge"><span class="n">initializer_list</span></code>是初始化列表。
例如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
<span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>  <span class="c1">// 复制构造
</span></code></pre>
    </div>
    <p>可以改为：<code class="language-c++ highlighter-rouge"><span class="k">new</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">);</span></code></p>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>的construct只能使用复制构造，但定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式可以使用任何构造函数</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>的方法和低级操作的对应关系：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="n">allocate</span></code>   &lt;==&gt; <code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">deallocate</span></code> &lt;==&gt; <code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">construct</span></code>  &lt;==&gt; 定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式</li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">destroy</span></code>    &lt;==&gt; 直接调用析构函数如：<code class="language-c++ highlighter-rouge"><span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span></code></li>
    </ul>
  </li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">"initialized"</span><span class="p">);</span></code>实际上发生三件事：
    <ol>
      <li>调用<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>分配内存。如果<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>没被重载，就调用标准库中的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>。</li>
      <li>运行该类型的一个构造函数，在上一个步骤分配的内存中初始化之</li>
      <li>返回该对象的指针</li>
    </ol>

    <p>而<code class="language-c++ highlighter-rouge"><span class="k">delete</span> <span class="n">sp</span><span class="p">;</span></code>实际上发生两件事：</p>
    <ol>
      <li>对<code class="language-c++ highlighter-rouge"><span class="n">sp</span></code>指向的对象运行适当的析构函数</li>
      <li>调用名为<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>的标准库函数释放内存</li>
    </ol>
  </li>
  <li>我们可以为一个类<code class="language-c++ highlighter-rouge"><span class="n">C</span></code>定义它特定的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>（称为“成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>”）或<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span><span class="p">[]</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span><span class="p">[]</span></code>函数，改变<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式的行为：
    <ul>
      <li><code class="language-c++ highlighter-rouge">
  <span class="n">C</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span> <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// 调用自定义版本
</span> </code></li>
      <li><code class="language-c++ highlighter-rouge">
  <span class="n">C</span> <span class="o">*</span><span class="n">obj1</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="n">C</span><span class="p">();</span> <span class="o">::</span><span class="k">delete</span> <span class="n">obj1</span><span class="p">;</span>  <span class="c1">// 调用标准库版本
</span> </code></li>
    </ul>
  </li>
  <li>成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>有两种定义：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">C</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">C</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">);</span></code></li>
    </ul>

    <p>其中<code class="language-c++ highlighter-rouge"><span class="kt">void</span><span class="o">*</span></code>形参由<code class="language-c++ highlighter-rouge"><span class="k">delete</span></code>表达式用被<code class="language-c++ highlighter-rouge"><span class="k">delete</span></code>的指针初始化，<code class="language-c++ highlighter-rouge"><span class="kt">size_t</span></code>由编译器用第一个形参所指对象的字节大小自动初始化。<code class="language-c++ highlighter-rouge"><span class="kt">size_t</span></code>一般用于继承层次，根据<code class="language-c++ highlighter-rouge"><span class="k">virtual</span> <span class="n">ptr</span></code>指向的对象的大小确定。类似地，成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span><span class="p">[]</span></code>也有两种定义。</p>
  </li>
  <li>成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>函数隐式地为静态函数，不必显式地将它们声明为<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>，虽然这样做是合法的。</li>
  <li>运行时类型识别（RTTI）：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="k">typeid</span></code>操作符：返回动态类型信息（当类型有虚函数时）或静态的、编译时的类型信息（以<code class="language-c++ highlighter-rouge"><span class="n">type_info</span></code>对象的形式返回）</li>
      <li><code class="language-c++ highlighter-rouge"><span class="k">dynamic_cast</span></code>操作符的用法：
        <ul>
          <li>
            <p>作用于指针</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">Derived</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base_ptr</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
            </div>
          </li>
          <li>
            <p>作用于引用</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_cast</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>成员指针（pointer to member）：
    <ul>
      <li>数据成员的指针：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="n">C</span><span class="o">::*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">obj</span><span class="p">;</span></code></li>
      <li>成员函数的指针：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_type_list</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">func</span><span class="p">;</span></code></li>
      <li>类的<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员不需要特殊语法来指向，其指针就是普通指针</li>
    </ul>

    <p>成员指针的使用（<code class="language-c++ highlighter-rouge"><span class="p">.</span><span class="o">*</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">-&gt;*</span></code>操作符）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">C</span> <span class="n">cobj</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
<span class="p">(</span><span class="n">cobj</span><span class="p">.</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_list</span><span class="p">);</span>
<span class="p">(</span><span class="n">cptr</span><span class="o">-&gt;*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_list</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>关于嵌套类：
    <ul>
      <li>嵌套在类模板内部的类是模板</li>
      <li>
        <p>在外围类外部定义嵌套类的方法：</p>

        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Outer</span> <span class="p">{</span> <span class="k">class</span> <span class="nc">Inner</span><span class="p">;</span>  <span class="cm">/* forward declaration */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Outer</span><span class="o">::</span><span class="n">Inter</span> <span class="p">{</span> <span class="cm">/* definition */</span> <span class="p">};</span>
</code></pre>
        </div>
      </li>
    </ul>
  </li>
  <li>固有的不可移植的特性包括：位域、<code class="language-c++ highlighter-rouge"><span class="k">volatile</span></code>限定符、链接指示（如<code class="language-c++ highlighter-rouge"><span class="k">extern</span> <span class="s">"C"</span></code>等）。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第16章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter16/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter16</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第16章 模板与泛型编程</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第16章 模板与泛型编程</h2>

<ol>
  <li>模板形参可以是表示类型的类型形参（type parameter，表示未知类型），也可以是表示常量表达式的非类型形参（nontype parameter，表示未知值）</li>
  <li>
    <p>函数模板也可以声明为<code class="language-c++ highlighter-rouge"><span class="kr">inline</span></code>。此时<code class="language-c++ highlighter-rouge"><span class="kr">inline</span></code>关键字放在模板形参表之后、返回类型之前，不能放在关键字<code class="language-c++ highlighter-rouge"><span class="k">template</span></code>之前：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>模板形参遵循常规名字屏蔽规则：与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字</li>
  <li>用作模板形参的名字不能在模板内部重用</li>
  <li>模板也可以只声明而不定义</li>
  <li>若模板定义中使用了模板形参中的类型的一个内部定义的类型，必须用<code class="language-c++ highlighter-rouge"><span class="k">typename</span></code>显式指明该名字是一个类型，否则编译器会假定该名字指定的是一个数据成员</li>
  <li>当一个模板类型用作（同一函数的）一个以上函数形参类型时，对应的实参的类型必须完全一致（当通过“<code class="language-c++ highlighter-rouge"><span class="o">&lt;&gt;</span></code>”提供显式实参时，或者属于下列情况时，例外），因为一般而言不会转换实参以匹配已有的实例化，相反，会产生新的实例。例外的情况为：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="k">const</span></code>转换：非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象的引用或指针-&gt;<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用或指针；<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>或非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象-&gt;非引用类型（忽略<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>）</li>
      <li>数组或函数到指针的转换。当模板形参不是引用类型时：数组/函数-&gt;指针。</li>
    </ul>

    <p>例：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fobj</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>  <span class="c1">// fobj(string, string); const is ignored
</span><span class="n">fref</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>  <span class="c1">// non const -&gt; const reference
</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// fobj(int*, int*);
// fref(a, b);  // error!
</span></code></pre>
    </div>
  </li>
  <li>
    <p>可以使用函数模板对函数指针进行初始化或赋值：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// 实例化
</span></code></pre>
    </div>
    <p>如果不能从函数指针类型确定模板实参，就会出错</p>
  </li>
  <li>某些情况下不可能推断出模板实参的类型。当函数的返回类型必须与形参表中所用的所有类型都不同时，最常出现这一问题。可以采用“增加一个模板形参以表示返回类型，调用时显示指定该类型”的方法解决</li>
  <li>显式提供模板实参时可以像函数的默认实参机制那样省略右边的模板实参（由编译器推断）</li>
  <li>模板要进行实例化时，编译器必须能够访问定义模板的源代码。如果采用分别编译模型（separate compilation model），在模板定义时需要使用<code class="language-c++ highlighter-rouge"><span class="k">export</span></code>关键字。</li>
  <li>类模板的成员函数只有为程序所用才进行实例化，如果某函数从未使用，则不会实例化该成员函数。一个典型例子是，若某类型没有定义默认的构造函数，也可以用<code class="language-c++ highlighter-rouge"><span class="n">std</span><span class="o">::</span><span class="n">vector</span></code>存放它，但<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>初始化时不能使用<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>的只有一个<code class="language-c++ highlighter-rouge"><span class="n">size</span></code>成员的构造函数。</li>
  <li>
    <p>类模板中的友元声明：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// ok: A is known to be a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">C</span><span class="p">;</span>  <span class="c1">// ok: C must be an ordinary, non-template class
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">D</span><span class="p">;</span>  <span class="c1">// ok: D is a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">E</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// error: E wasn’t declare as a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// error: F wasn’t declare as a template
</span><span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>在类特化的外部定义该特化类的成员时，成员之前不能加<code class="language-c++ highlighter-rouge"><span class="k">template</span><span class="o">&lt;&gt;</span></code>标记</li>
  <li>可以只特化成员而不是特化整个类</li>
  <li>类模板的部分特化：特化某些模板形参而非全部。当声明了部分特化时，编译器将为实例化选择最特化的模板定义</li>
  <li>函数匹配与函数模板：若重载函数中既有普通函数又有函数模板，确定函数调用的步骤如下：
    <ol>
      <li>建立候选函数集，包括
        <ul>
          <li>与被调函数名字相同的任意普通函数</li>
          <li>任意函数模板实例化（模板实参推断发现了与调用中所用函数实参相匹配的模板实参）</li>
        </ul>
      </li>
      <li>确定哪些普通函数是可行的（见本笔记7.22或原书7.8节关于如何选择可行函数的讨论）。候选集中每个模板实例都是可行的，因为模板实参推断保证了这点。</li>
      <li>若需要转换来进行调用，根据转换的种类排列可行函数（注意模板函数的实例所允许的转换是有限的）
        <ul>
          <li>如果只有一个函数可选，就调用之</li>
          <li>如果调用有二义性，从可行函数集合中去掉所有函数模板实例</li>
        </ul>
      </li>
      <li>重新排列去掉函数模板实例的可行函数。如果只有一个函数可选，调用之；否则有二义性。</li>
    </ol>

    <ul>
      <li>
        <p>例一：</p>

        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cm">/* I. */</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cm">/* II.*/</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</code></pre>
        </div>
        <ul>
          <li>
            <p>调用1：</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">const_arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">const_arr1</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">);</span>
</code></pre>
            </div>
            <p>将调用普通函数II。将<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span></code>的<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>也是可行函数，但是根据上述第3点第二条，它将被去掉。
注：实际上是比较以下俩可行函数：</p>

            <ul>
              <li>从I实例化的：<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span></code></li>
              <li>II的：<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span></code></li>
            </ul>
          </li>
          <li>
            <p>调用2：</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">ch_arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">,</span> <span class="n">ch_arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">ch_arr1</span><span class="p">,</span> <span class="n">ch_arr2</span><span class="p">);</span>
</code></pre>
            </div>
            <p>同样也调用普通函数II。I的实例将<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="kt">char</span><span class="o">*</span></code>。</p>
          </li>
        </ul>
      </li>
      <li>
        <p>例二：
如果I是这样：<code class="language-c++ highlighter-rouge"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span></code>则：</p>
        <ul>
          <li><code class="language-c++ highlighter-rouge"><span class="n">compare</span><span class="p">(</span><span class="n">ch_arr1</span><span class="p">,</span><span class="n">ch_arr2</span><span class="p">);</span></code>将调用<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="kt">char</span><span class="o">*</span></code>。</li>
          <li><code class="language-c++ highlighter-rouge"><span class="n">compare</span><span class="p">(</span><span class="n">const_arr2</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">);</span></code>将调用II。</li>
          <li><code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp1</span> <span class="o">=</span> <span class="n">const_arr1</span><span class="p">,</span> <span class="o">*</span><span class="n">cp2</span> <span class="o">=</span> <span class="n">const_arr2</span><span class="p">;</span> <span class="n">compare</span><span class="p">(</span><span class="n">cp1</span><span class="p">,</span> <span class="n">cp2</span><span class="p">);</span></code>将调用II。</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第14-15章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第14章 重载操作符与转换</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第15章 面向对象编程</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第14章 重载操作符与转换</h2>

<ol>
  <li>不能重载的操作符包括：<code class="language-c++ highlighter-rouge"><span class="o">::</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">*</span></code>（取值）和三元运算符<code class="language-c++ highlighter-rouge"><span class="o">?:</span></code>。</li>
  <li>不能通过连接其他合法操作符来创建任何新操作符</li>
  <li>重载操作符必须具有至少一个类类型或枚举类型的操作数，因此内置类型的操作符含义不能改变，也不能为任何内置类型定义额外的新的操作符。</li>
  <li>操作符的优先级、结合性或操作数数目不能改变。除了函数调用操作符<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>外，重载操作符时使用默认实参是非法的。</li>
  <li>重载操作符并不保证操作数的求值顺序（尤其是<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>和逗号操作符）。在<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>的重载版本中，两个操作数都要进行求值。</li>
  <li>一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员。</li>
  <li>也可以像调用普通函数那样调用重载操作符如：
    <ul>
      <li>非类成员：<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">);</span></code></li>
      <li>类成员：<code class="language-c++ highlighter-rouge"><span class="n">item1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">item2</span><span class="p">);</span></code></li>
    </ul>
  </li>
  <li>不应重载具有内置含义的操作符：<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="p">,</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>。</li>
  <li>赋值（<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>）、下标（<code class="language-c++ highlighter-rouge"><span class="p">[]</span></code>）、调用（<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>）和成员访问箭头（<code class="language-c++ highlighter-rouge"><span class="o">-&gt;</span></code>）必须定义为成员函数。</li>
  <li>箭头操作符虽然表现得像二元操作符，但重载时不接受显式形参：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{...}</span></code>。
当这样编写时：<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">();</span></code>，由于优先级规则，它等价于<code class="language-c++ highlighter-rouge"><span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)();</span></code>。求值过程为：
    <ol>
      <li>若<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>是一个指针，指向具有名为<code class="language-c++ highlighter-rouge"><span class="n">action</span></code>的成员的类对象，则编译器将代码编译为调用该对象的<code class="language-c++ highlighter-rouge"><span class="n">action</span></code>成员；</li>
      <li>否则，若<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>是定义了<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">-&gt;</span></code>操作符的一个对象，则<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span></code>与<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="p">.</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">action</span></code>相同，即执行<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>的<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span></code>，然后调用该结果重复这两步；</li>
      <li>否则，代码出错。</li>
    </ol>

    <p>因此，重载箭头操作符必须返回指向类类型的指针，或返回定义了自己箭头操作符的类类型对象。</p>
  </li>
  <li>两种自增操作符的重载：
    <ul>
      <li>前自增：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{...}</span></code></li>
      <li>后缀式自增：Type operator++(int) {…}`</li>
    </ul>

    <p>为解决前/后缀形式的形参数目和类型相同的问题，后缀式操作符接受一个额外的（无用的）<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>型形参。使用时编译器提供<code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>作为其实参。该形参不用命名，因为不应被使用到。显式调用的方法为：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">obj</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// postfix
</span><span class="n">obj</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>  <span class="c1">// prefix
</span></code></pre>
    </div>
  </li>
  <li>一般为表示操作的类重载调用操作符，其对象称为函数对象。</li>
  <li>
    <p>转换操作符（conversion operator）是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换；它在类定义体内声明，在保留字<code class="language-c++ highlighter-rouge"><span class="k">operator</span></code>之后跟着转换的目标类型：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">operator</span> <span class="n">Type2</span><span class="p">()</span> <span class="k">const</span> <span class="p">{...}</span>  <span class="c1">// 无返回类型，形参表为空
</span></code></pre>
    </div>
    <p>对任何可作为函数返回类型的类型（<code class="language-c++ highlighter-rouge"><span class="kt">void</span></code>除外），都可以定义转换函数（故数组和函数类型不行）。虽然不能指定返回类型，但必须显式返回一个指定类型的值。</p>
  </li>
  <li>只要定义了转换，编译器将在可以使用内置转换的地方自动调用它，包括显式类型转换<code class="language-c++ highlighter-rouge"><span class="k">static_cast</span></code>。</li>
  <li>使用转换函数时，被转换的类型不必与所需类型完全匹配，必要时可在类类型转换之后跟上标准转换（如<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">double</span></code>这种）以获得想要的类型，但不能再跟另一个类类型转换！</li>
  <li>标准转换可放在类类型转换之前，例如使用构造函数执行的隐式转换：<code class="language-c++ highlighter-rouge"><span class="kt">double</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="n">Type</span></code>，其中<code class="language-c++ highlighter-rouge"><span class="n">Type</span></code>类型有一个带单<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>参数的构造函数。</li>
  <li>如果两个转换操作符都可用于同一个调用中，而且转换之后存在标准转换，则根据该标准转换的类别使用最佳匹配</li>
  <li>当两个构造函数定义的转换都可以使用时，如果存在构造函数实参所需的标准转换，就用该标准转换的类别选择最佳匹配。</li>
  <li>
    <p>当两个类定义了转换时的二义性：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cm">/*I. */</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">);</span> <span class="p">};</span>                <span class="c1">// B-&gt;A
</span><span class="cm">/*II.*/</span> <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="k">operator</span> <span class="n">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// B-&gt;A
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">func</span><span class="p">(</span><span class="n">B</span><span class="p">());</span>  <span class="c1">// ambiguous
</span></code></pre>
    </div>
    <p>但若将I改为<code class="language-c++ highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span></code>则不再存在二义性，这是因为使用<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>将需要一个引用绑定到<code class="language-c++ highlighter-rouge"><span class="n">B</span></code>的对象，而使用II则避免了这个额外步骤。</p>
  </li>
  <li>转换与函数重载确定的关系：如果重载集里面的两个函数可以用同一转换函数匹配，则使用在转换之后或之前的标准转换序列的等级来确定最佳匹配；否则，如果可以使用不同的转换操作，则认为这两个转换是一样好的匹配，不管可能需要或不需要的标准转换等级如何。</li>
  <li>操作符的重载确定遵循常见的三步过程，而操作符的候选函数可能包括成员和非成员函数。</li>
</ol>

<h2 id="section-1">第15章 面向对象编程</h2>

<ol>
  <li>派生类对其基类类型的对象的<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>成员没有特殊访问权限。</li>
  <li>派生类的虚函数的声明必须与基类完全匹配，但有个例外：派生类中的虚函数可以返回基类函数所返回类型（必须是引用或指针）的派生类的引用（或指针）</li>
  <li>一旦函数在基类中声明为虚函数，它就一直是虚函数，不管派生类中用不用<code class="language-c++ highlighter-rouge"><span class="k">virtual</span></code></li>
  <li>用作基类的类必须是已定义的，只声明不行（否则就可以从自身派生出一个类了）</li>
  <li>可以使用作用域操作符覆盖虚函数机制并强制函数调用使用虚函数的特定版本</li>
  <li>虚函数的默认实参不受动态绑定影响：通过类<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>的引用或指针调用虚函数时，默认实参是在<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>中定义的值，不管该引用或指针绑定的是<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>的对象还是其派生类对象。另外，基类中虚函数如果指定了默认实参，派生类可以指定也可以不指定；反之亦然。</li>
  <li>派生类不能访问基类的<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>成员</li>
  <li>使用<code class="language-c++ highlighter-rouge"><span class="k">using</span></code>，派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松（但g++ 4.6.1上却可以任意指定新的访问级别）</li>
  <li>友元关系不能继承：
    <ul>
      <li>基类的友元对派生类没有特殊访问权限</li>
      <li>如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系给基类的类</li>
    </ul>
  </li>
  <li>若基类定义了<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员，则整个继承层次中只有一个这样的成员，每个<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员只有一个实例。</li>
  <li>派生类可以将基类的非纯虚的虚函数变为纯虚函数</li>
  <li>派生类到基类转换的可访问性：
    <ul>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">public</span></code>继承，则用户代码和后代类都可以访问（使用）派生类到基类的转换</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>或<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承，则用户代码不能将派生类型对象转换为基类对象</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承，则从<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承类派生出来的类（即孙子层）不能转换为基类（不管是用户代码还是在下层派生类中）</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>继承，则后续派生类的成员可以转换为基类类型</li>
      <li>派生类本身的成员和友元总是可以访问派生类到基类的转换（其实只要能访问到基类的<code class="language-c++ highlighter-rouge"><span class="k">public</span></code>成员即可，不管派生了多少层）</li>
    </ul>
  </li>
  <li>合成的默认ctor、copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>以及析构函数将对对象的基类部分连同派生部分的成员一起进行初始化、复制、赋值和撤销；自定义的copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>需要显式调用基类的copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>或自己另行实现才能复制、赋值基类部分</li>
  <li>如果在构造函数或析构函数中调用虚函数（不论直接还是间接），则运行的是为构造函数或析构函数自身类型定义的版本。</li>
  <li>由于派生类的作用域嵌套在基类作用域中，在基类和派生类中使用同一名字的成员函数时，就像一般的在局部声明的函数和在全局声明的函数一样：在派生类作用域中派生类成员将屏蔽基类成员，即使函数原型不同。</li>
  <li>局部作用域中声明的函数不会重载外围作用域中定义的函数，而是会屏蔽！因此，若派生类定义了重载成员，则通过派生类（的对象、指针或引用）只能访问派生类中重定义的那些成员，不管基类中的成员是否为<code class="language-c++ highlighter-rouge"><span class="k">virtual</span></code>的！（可以通过<code class="language-c++ highlighter-rouge"><span class="k">using</span></code>声明解决这个问题）</li>
  <li>
    <p>通过基类可以调用被屏蔽的虚函数：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">();</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">D1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* 屏蔽了Base的fcn */</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">D2</span> <span class="o">:</span> <span class="n">D1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* 屏蔽了D1的fcn */</span>  <span class="kt">int</span> <span class="n">fcn</span><span class="p">();}</span>

<span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">D1</span> <span class="n">d1</span><span class="p">;</span>
<span class="n">D2</span> <span class="n">d2</span><span class="p">;</span>
<span class="n">Base</span> <span class="o">*</span><span class="n">bp1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">bp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">,</span> <span class="o">*</span><span class="n">bp3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">;</span>

<span class="n">bp1</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// Base::fcn
</span><span class="n">bp2</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// Base::fcn，注意不能用D1的对象、引用或指针调用fcn()，因为它被fcn(int)屏蔽了！
</span><span class="n">bp3</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// D2::fcn
</span></code></pre>
    </div>
  </li>
  <li>（名字查找与继承的关系）确定函数调用遵循以下四个步骤
    <ol>
      <li>首先确定进行函数调用的对象、引用或指针的静态类型</li>
      <li>在该类中查找函数（名字），若找不到则从直接基类开始往上找，若最终找不到则出错</li>
      <li>一旦找到了该名字，就进行常规类型检查，看调用是否合法</li>
      <li>若合法，编译器就生成代码。若函数为虚且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪个函数版本，否则，编译器生成代码直接调用函数。</li>
    </ol>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第09-13章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第9章 顺序容器</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第11章 泛型算法</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">第12章 类</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">第13章 复制控制</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第9章 顺序容器</h2>

<ol>
  <li>指定容器大小的类型应该使用该容器的<code class="language-c++ highlighter-rouge"><span class="n">size_type</span></code>类型</li>
  <li>允许通过使用内置数组中的一对指针初始化容器</li>
  <li>容器元素类型必须满足以下两个约束：
    <ul>
      <li>元素类型必须支持赋值运算（故不能是引用）</li>
      <li>元素类型的对象必须可以复制（用于初始化和<code class="language-c++ highlighter-rouge"><span class="n">push_back</span></code>等）</li>
    </ul>
  </li>
</ol>

<h2 id="section-1">第11章 泛型算法</h2>

<ol>
  <li>为了以降序排列<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>，只需向<code class="language-c++ highlighter-rouge"><span class="n">sort</span></code>传递一对反向迭代器<code class="language-c++ highlighter-rouge"><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span></code></li>
</ol>

<h2 id="section-2">第12章 类</h2>

<ol>
  <li>声明一个类而不定义它（即前向声明）时，该类是一个不完全类型，只能以有限方式使用：
    <ul>
      <li>不知道包含哪些成员</li>
      <li>只能用于定义指向该类型的指针及引用，或用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数</li>
      <li>不能用于定义数据成员或该类的对象（故类不能具有自身类型的数据成员）</li>
    </ul>
  </li>
  <li>在一个源文件中一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的</li>
  <li>在普通的非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>成员函数中，<code class="language-c++ highlighter-rouge"><span class="k">this</span></code>的类型是一个指向类类型的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针</li>
  <li>当我们希望类的数据成员（甚至在<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>成员函数内）可以被修改时，可将它们声明为<code class="language-c++ highlighter-rouge"><span class="k">mutable</span></code>。<code class="language-c++ highlighter-rouge"><span class="k">mutable</span></code>数据成员永远都不会且不能为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>。</li>
  <li>如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外（否则在之内）。</li>
  <li>在类定义体外定义的成员函数的返回类型如果使用由该类定义的类型，则必须使用完全限定名，这是因为在函数名被处理前，代码不在类作用域内。</li>
  <li>类定义实际上是在两个阶段中处理：
    <ol>
      <li>首先编译成员声明</li>
      <li>只有在所有成员出现之后，才编译它们的定义本身（因此成员函数可以使用类作用域中所有名字）</li>
    </ol>
  </li>
  <li>必须在类中先定义类型名字，才能将它们用作数据成员的类型，或者成员函数的返回类型或形参类型</li>
  <li>一旦一个名字被用作类型名，该名字就不能被重复定义。（但若一个名字在类外作用域中首先被定义为类型名，类中可以先重新定义它再用作类型名）。</li>
  <li>构造函数不能声明为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code></li>
  <li>对非类类型的数据成员进行赋值或使用初始化式在结果和性能上都是等价的</li>
  <li>
    <p>成员被初始化的次序就是定义成员的次序，不管它们在初始化列表中顺序如何。因此以下程序非法：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>当没有在初始化列表中指出或使用合成的默认构造函数时，对于内置和复合类型的成员（如指针和数组），只对定义在全局作用域中的对象才初始化。</li>
  <li>对于一个没有定义默认构造函数（显式或隐式地）的类：
    <ul>
      <li>不能用作动态分配数组的元素类型</li>
      <li>其静态分配数组必须为每个元素提供一个显式的初始化式</li>
    </ul>
  </li>
  <li>可以用单个实参来调用的非<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>构造函数定义了从形参类型到该类类型的一个隐式转换。</li>
  <li>友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。</li>
  <li>友元不是授予友元关系的那个类的成员，故它们不受其声明出现部分的访问控制影响。</li>
  <li>必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</li>
  <li>友元声明将已命名的类或非成员函数引入到外围作用域中。此外，友元函数可以在类的内部定义，该函数的作用域扩展到包围该类定义的作用域。用友元引入的类名和函数（定义或声明），可以像预先声明的一样使用。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="k">static</span></code>数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，但此时不必再指定初始值。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">static</span></code>数据成员的类型可以是该成员所属的类类型，并可用作默认实参。</li>
  <li>在构造函数初始化列表中除了默认的方式（如<code class="language-c++ highlighter-rouge"><span class="n">x</span><span class="p">()</span></code>）外，无法用其他方式（如传递一个数组）来初始化一个数组类型的成员变量。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">typedef</span></code>在类中必须出现在使用其定义的类型别名的声明之前。</li>
</ol>

<h2 id="section-3">第13章 复制控制</h2>

<ol>
  <li>复制构造函数、赋值构造函数和析构函数总称为复制控制（copy control），编译器自动实现这些操作，但类也可以定义自己的版本。</li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span></code>，在创建<code class="language-c++ highlighter-rouge"><span class="n">str</span></code>时，编译器首先调用接受一个c风格字符串形参的<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>构造函数，创建一个临时对象，然后编译器使用<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>复制构造函数将<code class="language-c++ highlighter-rouge"><span class="n">str</span></code>初始化为那个临时对象的副本。</li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">C</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">ci</span></code>的初始化是否正确取决于两点：
    <ul>
      <li>类C的带一个<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>形参的ctor是否为<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>（如果是<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>则失败）</li>
      <li>类C的copy ctor对当前作用域是否可见</li>
    </ul>
  </li>
  <li>
    <p>若使用元素初始化列表初始化数组元素，则首先根据指定值创建数组元素类型的元素，然后用复制构造函数将该值复制到相应元素：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">C</span> <span class="n">ci</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span>  <span class="c1">// 单参数ctor + copy ctor
</span>  <span class="n">C</span><span class="p">()</span>  <span class="c1">// 默认ctor + copy ctor
</span><span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>合成的复制构造函数将复制数组类型成员的每一个元素，合成的复制操作符也会给数组的每个元素赋值。</li>
  <li>当copy ctor定义为<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>时，就不能用于向函数传递对象和从函数返回对象。</li>
  <li>容器（不管是标准库容器还是内置数组）中的元素总是按逆序撤销</li>
  <li>合成析构函数按对象创建时的逆序撤销每个非<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员（即按类中成员声明次序的逆序）</li>
  <li>因为不能指定任何形参，所以不能重载析构函数</li>
  <li>即使我们编写了自己的析构函数，合成的析构函数仍然运行。</li>
  <li>自定义的copy ctor必须是引用传递形参（而不是传值），否则会导致无限递归。</li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
