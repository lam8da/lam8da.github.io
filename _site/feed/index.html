<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4000/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2016-11-12T00:37:14-08:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>Blogging Resources</title>
      <link>http://localhost:4000/2016/11/welcome-to-jekyll/</link>
      <pubDate>2016-11-07T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/welcome-to-jekyll</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#resources" id="markdown-toc-resources">Resources</a></li>
  <li><a href="#code-block-highlighting" id="markdown-toc-code-block-highlighting">Code block highlighting</a>    <ul>
      <li><a href="#how-to-use-highlighter" id="markdown-toc-how-to-use-highlighter">How to use highlighter</a></li>
      <li><a href="#how-to-highlight-inlined-code-blocks" id="markdown-toc-how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</a></li>
    </ul>
  </li>
  <li><a href="#block-inline-attribute-lists-ial" id="markdown-toc-block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</a></li>
</ul>

<h2 id="resources">Resources</h2>
<ol>
  <li>git commands manual: <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></li>
  <li>markdown manual: <a href="http://www.appinn.com/markdown/">http://www.appinn.com/markdown/</a></li>
  <li>kramdown
    <ul>
      <li>quickref/examples: <a href="http://kramdown.gettalong.org/quickref.html">http://kramdown.gettalong.org/quickref.html</a></li>
      <li>syntax/manual: <a href="http://kramdown.gettalong.org/syntax.html">http://kramdown.gettalong.org/syntax.html</a></li>
    </ul>
  </li>
  <li>rouge options: <a href="https://github.com/jneen/rouge#full-options">https://github.com/jneen/rouge#full-options</a></li>
  <li>latex cheat sheet: <a href="https://wch.github.io/latexsheet/">https://wch.github.io/latexsheet/</a></li>
  <li><a href="http://jekyllrb.com/docs/home">Jekyll docs</a></li>
</ol>

<h2 id="code-block-highlighting">Code block highlighting</h2>

<h3 id="how-to-use-highlighter">How to use highlighter</h3>
<!-- Overwrite the setting to not show line_numbers in fenced code blocks -->

<p>Code block using kramdown (<strong>may not be compactible if not using kramdown</strong>):</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span>
</code></pre>
</div>

<p>Code block using Pygments or Rouge by using the <code class="language-ruby highlighter-rouge"><span class="n">highlight</span></code> Liquid tag
(<strong>putting it inside a list will work incorrectly</strong>):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</h3>

<p>I discovered in 11/12/2016 that all (inlined) code blocks generated by rouge are
wrapped by a
<code class="language-nothing">&lt;code&gt;</code>
tag with css class set to
<code class="language-nothing">language-some_language highlighter-rouge</code>
. So we can copy the highlight.css
to highlighter-rouge.css and make same css rules applicable to
<code class="language-nothing">highlighter-rouge span_css_class</code>
(e.g.
<code class="language-nothing">highlighter-rouge cp</code>
).</p>

<h2 id="block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</h2>

<p id="para-one">A simple paragraph with an ID attribute.</p>

<blockquote title="The blockquote title" id="myid">
  <p>A blockquote with a title</p>
</blockquote>

<div class="language-ruby ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Some</span> <span class="n">code</span> <span class="n">here</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>拜占庭将军问题</title>
      <link>http://localhost:4000/2014/03/byzantine-general-problem/</link>
      <pubDate>2014-03-08T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2014/03/byzantine-general-problem</guid>
      <content:encoded><![CDATA[<p>工作之余，花了一周的几乎每个晚上把Lamport神的那篇有关拜占庭将军问题的文章看完了。在这里做下笔记。</p>

<p>个人觉得最难懂的就是OM算法，我将它理解成一个动态规划：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">// @c is the commander id;
// @l is one of the lieutenant id, which belongs to the current lieutenant set;
// @m is the parameter m mentioned in the paper;
// OM(c, l, m) means the final value lieutenant @l obeys from commander @c.
</span>
<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span> <span class="n">where</span> <span class="n">l</span> <span class="n">in</span> <span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">};</span>

<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">majority</span><span class="p">(</span>
  <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span>
  <span class="n">the</span> <span class="n">list</span> <span class="n">of</span> <span class="n">OM</span><span class="p">(</span><span class="n">l</span><span class="err">'</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">where</span> <span class="n">l</span><span class="err">'</span> <span class="n">in</span> <span class="p">(</span><span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">l</span><span class="p">})</span>
<span class="p">).</span>  <span class="c1">// majority
</span></pre></td></tr></tbody></table>
</div>
</div>

<p>实际上，准确来说上面的状态表示是不完全的，OM的第一个参数应该是一个commander的id列表，表示从算法开始的第一个commander通过发消息沿途产生的所有commander。这样说起来还是很抽象，具体还是看下文代码吧。</p>

<p>为了让自己有更深的理解，我用C++实现了一个模拟器，输入general的个数，指定commander是否loyal，模拟算法运行，打印出每条消息以及消息路径，最后得出每个忠诚的lieutenant遵守的命令。目测+用小数据测试没有发现错误，也贴在这里供以后回顾使用。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208</pre></td><td class="code"><pre><span class="cp">#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
</span> 
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">num_generals</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">commander_is_loyal</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_loyal</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
 
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ValueType</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ValueType</span> <span class="n">kDefaultValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999999999</span><span class="p">;</span>
 
<span class="c1">// Classic algorithm to find the majority: maintain a value and
// a counter, when see a same value, ++counter; otherwise, if
// counter is 0, set the value to the one we see and let counter=1,
// or if counter&gt;0, --counter.
</span><span class="k">struct</span> <span class="n">MajorityCount</span> <span class="p">{</span>
  <span class="n">ValueType</span> <span class="n">majority</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">seen</span><span class="p">;</span>
 
  <span class="n">MajorityCount</span><span class="p">()</span> <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">kDefaultValue</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">MajorityCount</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
 
  <span class="n">MajorityCount</span><span class="o">&amp;</span> <span class="n">Merge</span><span class="p">(</span><span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">seen</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">majority</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">majority</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">": val="</span> <span class="o">&lt;&lt;</span> <span class="n">majority</span>
         <span class="o">&lt;&lt;</span> <span class="s">", cnt="</span> <span class="o">&lt;&lt;</span> <span class="n">count</span>
         <span class="o">&lt;&lt;</span> <span class="s">", seen="</span> <span class="o">&lt;&lt;</span> <span class="n">seen</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">MajorityCount</span><span class="o">&gt;</span> <span class="n">MapType</span><span class="p">;</span>
<span class="n">MapType</span> <span class="n">val_storage</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="nf">RandomShuffle</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">begin</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Itoa</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">res</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sprintf</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Join</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">delim</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Itoa</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ValueType</span> <span class="nf">RandomValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// return std::rand() % 97;
</span>  <span class="k">return</span> <span class="mi">250</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">// Updates the value of OM(c, l, m) using OM(l', l, m-1).
</span><span class="kt">void</span> <span class="nf">MergeUp</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key_vec</span> <span class="o">=</span> <span class="n">passed_ids</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">back</span> <span class="o">=</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">string</span> <span class="n">src_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">required_num_seen</span> <span class="o">=</span> <span class="n">remaining_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
 
  <span class="k">while</span> <span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dst_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
 
    <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">[</span><span class="n">dst_key</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span><span class="n">val_storage</span><span class="p">[</span><span class="n">src_key</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">back</span><span class="p">])</span> <span class="n">mc</span><span class="p">.</span><span class="n">majority</span> <span class="o">=</span> <span class="n">RandomValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">seen</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"    "</span> <span class="o">&lt;&lt;</span> <span class="n">src_key</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">dst_key</span><span class="p">;</span>
    <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">src_key</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">==</span> <span class="n">required_num_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src_key</span> <span class="o">=</span> <span class="n">dst_key</span><span class="p">;</span>
      <span class="o">++</span><span class="n">required_num_seen</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// Sequential algorithm: for simplicity, assume that each lieutenant
// will send messages to others when needed.
</span><span class="kt">void</span> <span class="nf">OM</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">commander_id</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ValueType</span> <span class="o">&amp;</span><span class="n">received_val</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span>  <span class="c1">// the last one is commander_id.
</span>        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// {1, 2, ..., n-1} - passed_ids
</span>  <span class="k">const</span> <span class="n">string</span> <span class="n">prefix_path</span> <span class="o">=</span>
      <span class="n">Join</span><span class="p">(</span><span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids_copy</span><span class="p">(</span><span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
      <span class="n">ValueType</span> <span class="n">val_to_send</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">commander_id</span><span class="p">]</span> <span class="o">?</span> <span class="n">received_val</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">());</span>
 
      <span class="c1">// OM(m), step (1)
</span>      <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="n">prefix_path</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">Itoa</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span>
        <span class="n">val_storage</span><span class="p">[</span><span class="n">path</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span>
            <span class="n">MajorityCount</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">val_to_send</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">;</span>
      <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
      <span class="c1">// OM(m), step (2)
</span>      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">seen</span> <span class="o">==</span> <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">OM</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val_to_send</span><span class="p">,</span> <span class="n">passed_ids</span><span class="p">,</span> <span class="n">remaining_ids</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+++++++++++++++++++++++++++++++++"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">,</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"num_generals: "</span><span class="p">,</span>
         <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num_generals</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m: "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"commander_is_loyal? "</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">commander_is_loyal</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">RandomShuffle</span><span class="p">(</span><span class="n">is_loyal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">passed_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_generals</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">remaining_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="c1">// commander_id=0, received_val=618
</span>    <span class="n">OM</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">618</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">);</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（下）- 设计模式</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes2/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes2</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">策略模式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">观察者模式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">装饰者模式</a></li>
  <li><a href="#factory-method-pattern" id="markdown-toc-factory-method-pattern">工厂方法模式（Factory Method Pattern）</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">抽象工厂模式</a></li>
  <li><a href="#singleton-pattern" id="markdown-toc-singleton-pattern">单件模式（Singleton Pattern）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">命令模式（封装调用）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">适配器模式</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">外观模式</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">模板方法模式</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">迭代器模式</a></li>
  <li><a href="#section-9" id="markdown-toc-section-9">组合模式</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">状态模式</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">代理模式</a></li>
  <li><a href="#mvc--" id="markdown-toc-mvc--">MVC：模型-视图-控制器</a></li>
  <li><a href="#section-12" id="markdown-toc-section-12">模式分类</a></li>
</ol>

<h2 id="section">策略模式</h2>

<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.strategy.png" alt="strategy" /></p>

<h2 id="section-1">观察者模式</h2>

<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。以下是Java的观察者模式：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.observers.png" alt="observers" /></p>

<ol>
  <li>出版者+订阅者=观察者模式</li>
  <li>不要依赖于观察者被通知的次序，因为一旦观察者/可观察者的实现有所改变，通知次序就会改变，很可能就会产生错误的结果，这绝对不是我们认为的松耦合</li>
  <li>java.util.Observale的黑暗面：Observable是一个类，如果某类想同时具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承，这限制了Observable的复用潜力；另外，Observable将关键方法（setChanged()）保护起来，这个设计违反了设计原则：多用组合，少用继承。</li>
</ol>

<h2 id="section-2">装饰者模式</h2>

<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.decorator.png" alt="decorator" /></p>

<ol>
  <li>如上述类图关系，重点在于，装饰者和被装饰者必须是一样的类型，也就是有同样的超类，这相当关键。在这里，我们利用继承达到“类型匹配”而不是获得“行为”。</li>
  <li>为何装饰者和被装饰者有相同的接口：因为装饰者必须能取代被装饰者。</li>
  <li>通常装饰者模式是采用抽象类，但是在Java中可以使用接口</li>
</ol>

<h2 id="factory-method-pattern">工厂方法模式（Factory Method Pattern）</h2>

<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类，通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>

<p>工厂模式具有平行的类层级：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.factory.png" alt="factory" /></p>

<ol>
  <li>当可能有许多客户程序通过各种方法来创建一个类型的新对象时，可以考虑到把创建这个对象的方法放到一个工厂中去，即使用工厂模式。所有工厂模式都用来封装对象的创建。</li>
  <li>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。工厂方法不一定要真的放到一个非本类的“工厂类”中。</li>
  <li>使用“工厂”意味着客户在实例化对象时，只会依赖于接口而不是具体类。这符合依赖倒置原则。</li>
</ol>

<h2 id="section-3">抽象工厂模式</h2>

<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.abstract-factory.png" alt="abstract-factory" /></p>

<ol>
  <li>抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法</li>
  <li>抽象工厂和工厂方法都是负责创建对象，工厂方法用的方法是继承，抽象工厂是通过对象的组合</li>
  <li>当需要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂；而工厂方法可以把客户代码从需要实例化的具体类中解耦，或如果目前还不知道将来需要实例化哪些具体类时，也可以用工厂方法。</li>
  <li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
</ol>

<h2 id="singleton-pattern">单件模式（Singleton Pattern）</h2>

<p>单件模式用来创建独一无二的、只能有一个实例的对象。</p>

<ol>
  <li>实现方法：若将对象赋值给一个全局变量，那么必须在程序一开始就创建好对象。万一这个对象非常耗资源，而程序在这次执行过程中又一直没用到它，就会形成浪费。</li>
  <li>单件模式实现中处理多线程问题的方法：</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span><span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>使用synchronized关键字可能会导致效率严重下降。而volatile关键字定义的成员变量确保在同一时间最多只有一个线程对其进行访问，尤其是32位系统处理64位变量时。另外，也可以使用“急切”创建实例而不用延迟实例，在静态初始化器（static initializer）中创建单位：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span></code></pre></figure>

<p>但这样会导致1中提到的问题。</p>

<h2 id="section-4">命令模式（封装调用）</h2>

<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.command.png" alt="command" /></p>

<ol>
  <li>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式</li>
  <li>宏命令模式：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.macro-command.png" alt="macro-command" /></p>

<h2 id="section-5">适配器模式</h2>

<p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.adapter.png" alt="adapter" /></p>

<h2 id="section-6">外观模式</h2>

<p>外观模式改变接口，将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观，让接口更简单。</p>

<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>

<h2 id="section-7">模板方法模式</h2>

<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>

<ol>
  <li>模板方法不一定要使用继承，例如c++的stl的排序方法使用的比较函数</li>
  <li>常见形式：
    <ul>
      <li>抽象方法：当子类必须提供算法中某个步骤的实现时使用</li>
      <li>钩子：当算法某个部分可选时使用</li>
    </ul>
  </li>
  <li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final</li>
</ol>

<h2 id="section-8">迭代器模式</h2>

<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.iterator.png" alt="iterator" /></p>

<h2 id="section-9">组合模式</h2>

<p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.composite.png" alt="composite" /></p>

<p>组合模式是让一个类有两个责任的模式，它不但要管理层次结构，而且还要执行菜单的操作。但组合模式以单一责任设计原则换取透明性（transparency）：通过让组件的接口同事包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁，这是一个很典型的折中案例。</p>

<h2 id="section-10">状态模式</h2>

<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.state.png" alt="state" /></p>

<p>上述ConcreteStateA和ConcreteStateB对Context的引用并不是必须的。有时Context本身也可以决定状态转换的流向。当状态转换是固定时（例如做了某个动作后就一定转换到某特定状态），就适合放在Context中。当转换更动态的时候，通常就会放在状态类中。做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭。</p>

<p>多个Context实例可共享状态对象（使用静态变量）。若状态需要利用Context中的方法，还必须在每个handler()方法内传入一个Context引用。</p>

<h2 id="section-11">代理模式</h2>

<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.proxy.png" alt="proxy" /></p>

<ol>
  <li>几种代理模式：
    <ul>
      <li>远程代理：控制访问远程对象</li>
      <li>虚拟代理：控制访问创建开销大的资源</li>
      <li>保护代理：基于权限控制对资源的访问</li>
      <li>防火墙代理（Firewall Proxy）</li>
      <li>智能引用代理（Smart Reference Proxy）</li>
      <li>缓存代理（Caching Proxy）</li>
      <li>同步代理（Synchronization Proxy）</li>
      <li>复杂隐藏代理（Complexity Hiding Proxy）</li>
      <li>写入时复制代理（Copy-On-Write Proxy）</li>
    </ul>
  </li>
  <li>Java RMI（远程过程调用）
    <ul>
      <li>java.rmi.Remote</li>
      <li>stub、skeleton</li>
      <li>rmic、rmiregistry工具</li>
      <li>transient关键字：告诉Java不要序列化一个对象</li>
    </ul>
  </li>
  <li>Java的动态代理技术：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.java-dynamic-proxy.png" alt="java-dynamic-proxy" /></p>

<h2 id="mvc--">MVC：模型-视图-控制器</h2>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc.png" alt="mvc" /></p>

<p>图解：</p>

<ol>
  <li>策略模式：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略</li>
  <li>视图用组合模式组织各窗口、面板、按钮等</li>
  <li>模型实现了观察者模式，当状态改变时通知对象更新。这使得同一模型可以使用不同的视图甚至可使用多个视图</li>
  <li>不同接口的模型常常通过适配器模式复用同一个视图</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc-web.png" alt="mvc-web" /></p>

<p>上图是Web中的MVC，称为Model 2（Servlet+JSP）。</p>

<p>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p>

<h2 id="section-12">模式分类</h2>

<p>模式是在某情景下，针对某问题的某种解决方案。模式可分为以下几类：</p>

<ul>
  <li>创建型：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。包括：Singleton、Builder、Prototype、Abstract Factory、Factory Method</li>
  <li>行为型：设计到类和对象如何交互及分配的职责。包括：Template Method、Visitor、Mediator、Iterator、Command、Memento、Interpreter、Observer、Chain of Responsibility、State、Strategy</li>
  <li>结构型：可让你把类或对象组合到更大的结构中。包括：Decorator、Proxy、Composite、Façade、Flyweight、Bridge、Adapter</li>
</ul>

<p>反模式告诉你如何采用一个不好的解决方案解决一个问题，告诉你为何这个方案从长远看会造成不好的影响，警告你不要陷入某种致命的诱惑，建议你改用其他的模式以提供更好的解决方案。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（上）- 设计原则</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes1/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes1</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">封装变化</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">针对接口编程，而不是针对实现编程</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">多用组合，少用继承</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">为了交互对象之间的松耦合设计而努力</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">类应该对扩展开放，对修改关闭</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">要依赖抽象，不要依赖具体类</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">最小知识原则</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">好莱坞原则</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">应尽量让每个类保持单一责任</a></li>
</ol>

<h2 id="section">封装变化</h2>

<p>找出应用中可能需要变化之处，把它们独立出来（并封装起来），不要和那些不要变化的代码混在一起。</p>

<p>如果每次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分</p>

<h2 id="section-1">针对接口编程，而不是针对实现编程</h2>

<p>以前的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于“实现”，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p>

<p>“针对接口编程”真正的意思是“针对超类型（supertype）编程”，货可以更明确地说成“变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口”。</p>

<h2 id="section-2">多用组合，少用继承</h2>

<p>良好的OO设计必须具备可复用、可扩充、可维护三个特性。大多数的模式都允许系统局部改变独立于其他部分</p>

<h2 id="section-3">为了交互对象之间的松耦合设计而努力</h2>

<h2 id="section-4">类应该对扩展开放，对修改关闭</h2>

<h2 id="section-5">要依赖抽象，不要依赖具体类</h2>

<p>依赖倒置原则（Dependency Inversion Principle）：不能让高层组件依赖低层组件，而且，不管高层或低层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。</p>

<p>一下指导方针能帮助避免在OO设计中违反依赖倒置原则：</p>

<ol>
  <li>变量不可以持有具体类的引用</li>
  <li>不要让类派生自具体类</li>
  <li>不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</li>
</ol>

<h2 id="section-6">最小知识原则</h2>

<p>减少对象之间的交互，不要让太多的类耦合在一起。</p>

<p>指导方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>

<ol>
  <li>该对象本身</li>
  <li>被当做方法的参数而传进来的对象</li>
  <li>此方法所创建或实例化的任何对象</li>
  <li>对象的任何组件（Has-A）</li>
</ol>

<p>注意，如果某对象是调用其他方法的返回结果，不要调用该对象的方法！</p>

<h2 id="section-7">好莱坞原则</h2>

<p>别调用（打电话给）我们，我们会调用（打电话给）你（将决策权放在高层模块中）。</p>

<p>例如模板方法模式中，低层组件绝对不可以直接调用高层组件。</p>

<h2 id="section-8">应尽量让每个类保持单一责任</h2>

<p>因为一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域。如果一个类具有两个改变的原则，那么这会使得将来该类变化的几率上升；而当它真的改变时，你的设计中同时有两个方面将受到影响。</p>

<p>术语：</p>
<ul>
  <li>内聚（cohesion）：用来度量一个类或模块紧密地达到单一目的或责任</li>
  <li>高内聚：一个模块/类被设计成只支持一组相关功能</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第17-18章完）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第17章 用于大型程序的工具</a></li>
</ol>

<h2 id="section">第17章 用于大型程序的工具</h2>

<ol>
  <li>
    <p>承诺不抛出任何异常的方法：void func() throw() {}</p>
  </li>
  <li>
    <p>命名空间别名（像定义变量一样）：namespace n1 = n2;  // n2是一个已定义的命名空间</p>
  </li>
  <li>
    <p>屏蔽命名空间名字规则的一个重要例外：接受类类型形参（或类类型指针及引用形参）的函数（包括重载操作符），以及与类本身定义在同一命名空间中的函数（包括重载操作符），在用类类型对象（或类类型的引用及指针）作为实参的时候是可见的。如：
std::string s;
getline(std::cin, s);  // ok
当compiler看到getline(std::cin, s);时，它在当前作用域、包含调用的作用域以及定义cin和string的命名空间中查找匹配的函数。</p>
  </li>
  <li>
    <p>在最底层派生类的构造函数中，c++会首先初始化虚基类；在初始化中间层派生类时，忽略它们对虚基类的初始化。</p>
  </li>
</ol>

<p>第18章 特殊工具与技术</p>

<ol>
  <li>
    <p>c++提供以下两种方法分配和释放未构造的原始内存：allocator类；标准库中的operator new和operator delete。</p>
  </li>
  <li>
    <p>c++还提供不同的方法在原始内存中构造和撤销对象：
a. allocator类的construct和destroy成员
b. 定位new表达式（placement new expression）接受指向未构造内存的指针，并在该空间中初始化一个对象或一个数组
c. 可直接调用对象的析构函数来撤销对象。运行析构函数并不释放所在内存
d. uninitialized_fill和uninitiated_copy</p>
  </li>
  <li>
    <p>operator new/delete接口（只分配/释放空间，不构造/析构）：
void <em>operator new(size_t);
void *operator new<a href="size_t"></a>;
void operator delete(void</em>);
void operator delete<a href="void*"></a>;</p>
  </li>
  <li>
    <p>定位new表达式（在已分配但未构造的内存中初始化对象）：
new (place_address) type
new (place_address) type (initializer_list)
其中place_address是指针，initializer_list是初始化列表。
例如：
allocator<T> alloc;
alloc.construct(ptr, t);  // 复制构造
可以改为：
new (ptr) T(t);</T></p>
  </li>
  <li>
    <p>allocator的construct只能使用复制构造，但定位new表达式可以使用任何构造函数</p>
  </li>
  <li>
    <p>allocator的方法和低级操作的对应关系：
allocate       &lt;==&gt; operator new
deallocate  &lt;==&gt; operator delete
construct   &lt;==&gt; 定位new表达式
destroy       &lt;==&gt; 直接调用析构函数如：ptr-&gt;~T();</p>
  </li>
  <li>
    <p>对于语句string *sp = new string(“initialized”);实际上发生三件事：
a. 调用operator new分配内存。如果operator new没被重载，就调用标准库中的operator new。
b. 运行该类型的一个构造函数，在a分配的内存中初始化之
c. 返回该对象的指针
而delete sp;实际上发生两件事：
a. 对sp指向的对象运行适当的析构函数
b. 调用名为operator delete的标准库函数释放内存</p>
  </li>
  <li>
    <p>我们可以为一个类C定义它特定的operator new/delete（称为“成员operator new/delete”）或operator new[]/delete[]函数，改变new表达式的行为：
a. C *obj = new C(); delete obj;  // 调用自定义版本
b. C *obj1 = ::new C(); ::delete obj1;  // 调用标准库版本</p>
  </li>
  <li>
    <p>成员operator delete有两种定义：
void C::operator delete(void <em>p);
void C::operator delete(void *p, size_t sz);
其中void</em>形参由delete表达式用被delete的指针初始化，size_t由编译器用第一个形参所指对象的字节大小自动初始化。size_t一般用于继承层次，根据virtual ptr指向的对象的大小确定。
类似地，成员operator delete[]也有两种定义。</p>
  </li>
  <li>
    <p>成员operator new/delete函数隐式地为静态函数，不必显式地将它们声明为static，虽然这样做是合法的。</p>
  </li>
  <li>
    <p>运行时类型识别（RTTI）：
I. typeid操作符：返回动态类型信息（当类型有虚函数时）或静态的、编译时的类型信息（以type_info对象的形式返回）
II. dynamic_cast操作符的用法：
a. 作用于指针</p>
  </li>
</ol>

<p>if (Derived <em>dptr = dynamic_cast&lt;Derived</em>&gt;(base_ptr)) {
  …
} else {
  …
}</p>

<p>b. 作用于引用</p>

<p>try {
  Derived &amp;d = dynamic_cast&lt;Derived&amp;&gt;(b);
  …
} catch (std::bad_cast) {
  …
}</p>

<ol>
  <li>成员指针（pointer to member）：</li>
</ol>

<p>a. 数据成员的指针：Type C::<em>ptr = &amp;C::obj;
b. 成员函数的指针：Type (C::</em>ptr)(arg_type_list) = &amp;C::func;
c. 类的static成员不需要特殊语法来指向，其指针就是普通指针
成员指针的使用（.<em>和-&gt;</em>操作符）：
C cobj, <em>cptr;
(cobj.</em>ptr)(arg_list);
(cptr-&gt;*ptr)(arg_list);</p>

<ol>
  <li>
    <p>关于嵌套类：
a. 嵌套在类模板内部的类是模板
b. 在外围类外部定义嵌套类的方法：
class Outer { class Inner;  /* forward declaration <em>/ };
class Outer::Inter { /</em> definition */ };</p>
  </li>
  <li>
    <p>固有的不可移植的特性包括：位域、volatile限定符、链接指示（如extern “C”等）。</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第16章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter16/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter16</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第16章 模板与泛型编程</a></li>
</ol>

<h2 id="section">第16章 模板与泛型编程</h2>

<ol>
  <li>
    <p>模板形参可以是表示类型的类型形参（type parameter，表示未知类型），也可以是表示常量表达式的非类型形参（nontype parameter，表示未知值）</p>
  </li>
  <li>
    <p>函数模板也可以声明为inline。此时inline关键字放在模板形参表之后、返回类型之前，不能放在关键字template之前：
template <typename T=""> inline T min(const T&amp;, const T&amp;);</typename></p>
  </li>
  <li>
    <p>模板形参遵循常规名字屏蔽规则：与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字</p>
  </li>
  <li>
    <p>用作模板形参的名字不能在模板内部重用</p>
  </li>
  <li>
    <p>模板也可以只声明而不定义</p>
  </li>
  <li>
    <p>若模板定义中使用了模板形参中的类型的一个内部定义的类型，必须用typename显式指明该名字是一个类型，否则编译器会假定该名字指定的是一个数据成员</p>
  </li>
  <li>
    <p>当一个模板类型用作（同一函数的）一个以上函数形参类型时，对应的实参的类型必须完全一致（当通过“&lt;&gt;”提供显式实参时，或者属于下列情况时，例外），因为一般而言不会转换实参以匹配已有的实例化，相反，会产生新的实例。例外的情况为：
a. const转换：非const对象的引用或指针-&gt;const引用或指针；const或非const对象-&gt;非引用类型（忽略const）
b. 数组或函数到指针的转换。当模板形参不是引用类型时：数组/函数-&gt;指针。
例：</p>
  </li>
</ol>

<p>template<typename T=""> T fobj(T, T);
template<typename T=""> T fref(const T&amp;, const T&amp;);
string s1;
const string s2;
fobj(s1, s2);  // fobj(string, string); const is ignored
fref(s1, s2);  // non const -&gt; const reference
int a[10], b[42];
fobj(a, b);  // fobj(int*, int*);
// fref(a, b);  // error!</typename></typename></p>

<ol>
  <li>
    <p>可以使用函数模板对函数指针进行初始化或赋值：
template<typename T=""> int compare(const T&amp;, const T&amp;);
int (*pf)(const int&amp;, const int&amp;) = compare;  // 实例化
如果不能从函数指针类型确定模板实参，就会出错</typename></p>
  </li>
  <li>
    <p>某些情况下不可能推断出模板实参的类型。当函数的返回类型必须与形参表中所用的所有类型都不同时，最常出现这一问题。可以采用“增加一个模板形参以表示返回类型，调用时显示指定该类型”的方法解决</p>
  </li>
  <li>
    <p>显式提供模板实参时可以像函数的默认实参机制那样省略右边的模板实参（由编译器推断）</p>
  </li>
  <li>
    <p>模板要进行实例化时，编译器必须能够访问定义模板的源代码。如果采用分别编译模型（separate compilation model），在模板定义时需要使用export关键字。</p>
  </li>
  <li>
    <p>类模板的成员函数只有为程序所用才进行实例化，如果某函数从未使用，则不会实例化该成员函数。一个典型例子是，若某类型没有定义默认的构造函数，也可以用std::vector存放它，但vector初始化时不能使用vector的只有一个size成员的构造函数。</p>
  </li>
  <li>
    <p>类模板中的友元声明：</p>
  </li>
</ol>

<p>template<class T=""> class A;
template<class T=""> class B {
 public:
  friend class A<T>;  // ok: A is known to be a template
  friend class C;  // ok: C must be an ordinary, non-template class
  template<class S=""> friend class D;  // ok: D is a template
  friend class E<T>;  // error: E wasn’t declare as a template
  friend class F<int>;  // error: F wasn’t declare as a template
};</int></T></class></T></class></class></p>

<ol>
  <li>
    <p>在类特化的外部定义该特化类的成员时，成员之前不能加template&lt;&gt;标记</p>
  </li>
  <li>
    <p>可以只特化成员而不是特化整个类</p>
  </li>
  <li>
    <p>类模板的部分特化：特化某些模板形参而非全部。当声明了部分特化时，编译器将为实例化选择最特化的模板定义</p>
  </li>
  <li>
    <p>函数匹配与函数模板：若重载函数中既有普通函数又有函数模板，确定函数调用的步骤如下：
(1). 建立候选函数集，包括
a. 与被调函数名字相同的任意普通函数
b. 任意函数模板实例化（模板实参推断发现了与调用中所用函数实参相匹配的模板实参）
(2). 确定哪些普通函数是可行的（见本笔记7.22或原书7.8节关于如何选择可行函数的讨论）。候选集中每个模板实例都是可行的，因为模板实参推断保证了这点。
(3). 若需要转换来进行调用，根据转换的种类排列可行函数（注意模板函数的实例所允许的转换是有限的）
a. 如果只有一个函数可选，就调用之
b. 如果调用有二义性，从可行函数集合中去掉所有函数模板实例
(4). 重新排列去掉函数模板实例的可行函数。如果只有一个函数可选，调用之；否则有二义性。</p>
  </li>
</ol>

<p>例一：
I. template<typename T=""> int compare(const T&amp;, const T&amp;);
II. int compare(const char*, const char*);
调用1：
const char const_arr1[] = “world”, const_arr2[] = “hi”;
compare(const_arr1, const_arr2);
将调用普通函数II。将T绑定到const char*的I也是可行函数，但是根据(3)b，它将被去掉。
注：实际上是比较以下俩可行函数：
从I实例化的：int compare(const char* const&amp;, const char* const&amp;);
II的：int compare(const char*, const char*);
调用2：
char ch_arr1[] = “world”, ch_arr2[] = “hi”;
compare(ch_arr1, ch_arr2);
同样也调用普通函数II。I的实例将T绑定到char*。</typename></p>

<p>例二：
如果I是这样：template<typename T=""> int compare(T, T);则：
compare(ch_arr1,ch_arr2);将调用I，T绑定到char*。
compare(const_arr2, const_arr2);将调用II。
const char *cp1 = const_arr1, *cp2 = const_arr2; compare(cp1, cp2);将调用2。</typename></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第14-15章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第14章 重载操作符与转换</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第15章 面向对象编程</a></li>
</ol>

<h2 id="section">第14章 重载操作符与转换</h2>

<ol>
  <li>
    <p>不能重载的操作符包括：::、*（取值）和三元运算符?:。</p>
  </li>
  <li>
    <p>不能通过连接其他合法操作符来创建任何新操作符</p>
  </li>
  <li>
    <p>重载操作符必须具有至少一个类类型或枚举类型的操作数，因此内置类型的操作符含义不能改变，也不能为任何内置类型定义额外的新的操作符。</p>
  </li>
  <li>
    <p>操作符的优先级、结合性或操作数数目不能改变。除了函数调用操作符()外，重载操作符时使用默认实参是非法的。</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>重载操作符并不保证操作数的求值顺序（尤其是&amp;&amp;、</td>
          <td> </td>
          <td>和逗号操作符）。在&amp;&amp;和</td>
          <td> </td>
          <td>的重载版本中，两个操作数都要进行求值。</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员。</p>
  </li>
  <li>
    <p>也可以像调用普通函数那样调用重载操作符如：
a. 非类成员：operator+(item1, item2);
b. 类成员：item1.operator+=(item2);</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>不应重载具有内置含义的操作符：=、&amp;、,、&amp;&amp;、</td>
          <td> </td>
          <td>。</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）必须定义为成员函数。</p>
  </li>
  <li>箭头操作符虽然表现得像二元操作符，但重载时不接受显式形参：Type operator-&gt;() {…}。</li>
</ol>

<p>当这样编写时：pointer-&gt;action();，由于优先级规则，它等价于(pointer-&gt;action)();。求值过程为：
I. 若pointer是一个指针，指向具有名为action的成员的类对象，则编译器将代码编译为调用该对象的action成员；
II. 否则，若pointer是定义了operator-&gt;操作符的一个对象，则pointer-&gt;action与pointer.operator-&gt;()-&gt;action相同，即执行pointer的operator-&gt;()，然后调用该结果重复这两步；
III. 否则，代码出错。
因此，重载箭头操作符必须返回指向类类型的指针，或返回定义了自己箭头操作符的类类型对象。</p>

<ol>
  <li>
    <p>两种自增操作符的重载：
前自增：Type &amp;operator++() {…}
后缀式自增：Type operator++(int) {…}
未解决前/后缀形式的形参数目和类型相同的问题，后缀式操作符接受一个额外的（无用的）int型形参。使用时编译器提供0作为其实参。该形参不用命名，因为不应被使用到。显式调用的方法为：
obj.operator++(0);  // postfix
obj.operator++();  // prefix</p>
  </li>
  <li>
    <p>一般为表示操作的类重载调用操作符，其对象称为函数对象。</p>
  </li>
  <li>
    <p>转换操作符（conversion operator）是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换；它在类定义体内声明，在保留字operator之后跟着转换的目标类型：
operator Type2() const {…}  // 无返回类型，形参表为空
对任何可作为函数返回类型的类型（void除外），都可以定义转换函数（故数组和函数类型不行）。虽然不能指定返回类型，但必须显式返回一个指定类型的值。</p>
  </li>
  <li>
    <p>只要定义了转换，编译器将在可以使用内置转换的地方自动调用它，包括显式类型转换static_cast。</p>
  </li>
  <li>
    <p>使用转换函数时，被转换的类型不必与所需类型完全匹配，必要时可在类类型转换之后跟上标准转换（如int-&gt;double这种）以获得想要的类型，但不能再跟另一个类类型转换！</p>
  </li>
  <li>
    <p>标准转换可放在类类型转换之前，例如使用构造函数执行的隐式转换：double-&gt;int-&gt;Type，其中Type类型有一个带单int参数的构造函数。</p>
  </li>
  <li>
    <p>如果两个转换操作符都可用于同一个调用中，而且转换之后存在标准转换，则根据该标准转换的类别使用最佳匹配</p>
  </li>
  <li>
    <p>当两个构造函数定义的转换都可以使用时，如果存在构造函数实参所需的标准转换，就用该标准转换的类别选择最佳匹配。</p>
  </li>
  <li>
    <p>当两个类定义了转换时的二义性：</p>
  </li>
</ol>

<p>/<em>I. */ class A { public: A(B); };                // B-&gt;A
/</em>II.*/ class B { public: operator A() const; };  // B-&gt;A
void func(A);
func(B());  // ambiguous</p>

<p>但若将I改为A(const B&amp;);则不再存在二义性，这是因为使用I将需要一个引用绑定到B的对象，而使用II则避免了这个额外步骤。</p>

<ol>
  <li>
    <p>转换与函数重载确定的关系：如果重载集里面的两个函数可以用同一转换函数匹配，则使用在转换之后或之前的标准转换序列的等级来确定最佳匹配；否则，如果可以使用不同的转换操作，则认为这两个转换是一样好的匹配，不管可能需要或不需要的标准转换等级如何。</p>
  </li>
  <li>
    <p>操作符的重载确定遵循常见的三步过程，而操作符的候选函数可能包括成员和非成员函数。</p>
  </li>
</ol>

<h2 id="section-1">第15章 面向对象编程</h2>

<ol>
  <li>
    <p>派生类对其基类类型的对象的protected成员没有特殊访问权限。</p>
  </li>
  <li>
    <p>派生类的虚函数的声明必须与基类完全匹配，但有个例外：派生类中的虚函数可以返回基类函数所返回类型（必须是引用或指针）的派生类的引用（或指针）</p>
  </li>
  <li>
    <p>一旦函数在基类中声明为虚函数，它就一直是虚函数，不管派生类中用不用virtual</p>
  </li>
  <li>
    <p>用作基类的类必须是已定义的，只声明不行（否则就可以从自身派生出一个类了）</p>
  </li>
  <li>
    <p>可以使用作用域操作符覆盖虚函数机制并强制函数调用使用虚函数的特定版本</p>
  </li>
  <li>
    <p>虚函数的默认实参不受动态绑定影响：通过类A的引用或指针调用虚函数时，默认实参是在A中定义的值，不管该引用或指针绑定的是A的对象还是其派生类对象。另外，基类中虚函数如果指定了默认实参，派生类可以指定也可以不指定；反之亦然。</p>
  </li>
  <li>
    <p>派生类不能访问基类的private成员</p>
  </li>
  <li>
    <p>使用using，派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松（但g++ 4.6.1上却可以任意指定新的访问级别）</p>
  </li>
  <li>
    <p>友元关系不能继承：
a. 基类的友元对派生类没有特殊访问权限
b. 如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系给基类的类</p>
  </li>
  <li>
    <p>若基类定义了static成员，则整个继承层次中只有一个这样的成员，每个static成员只有一个实例。</p>
  </li>
  <li>
    <p>派生类可以将基类的非纯虚的虚函数变为纯虚函数</p>
  </li>
  <li>
    <p>派生类到基类转换的可访问性：
a. 如果是public继承，则用户代码和后代类都可以访问（使用）派生类到基类的转换
b. 如果是protected或private继承，则用户代码不能将派生类型对象转换为基类对象
c. 如果是private继承，则从private继承类派生出来的类（即孙子层）不能转换为基类（不管是用户代码还是在下层派生类中）
d. 如果是protected继承，则后续派生类的成员可以转换为基类类型
e. 派生类本身的成员和友元总是可以访问派生类到基类的转换（其实只要能访问到基类的public成员即可，不管派生了多少层）</p>
  </li>
  <li>
    <p>合成的默认ctor、copy ctor和=以及析构函数将对对象的基类部分连同派生部分的成员一起进行初始化、复制、赋值和撤销；自定义的copy ctor和=需要显式调用基类的copy ctor和=或自己另行实现才能复制、赋值基类部分</p>
  </li>
  <li>
    <p>如果在构造函数或析构函数中调用虚函数（不论直接还是间接），则运行的是为构造函数或析构函数自身类型定义的版本。</p>
  </li>
  <li>
    <p>由于派生类的作用域嵌套在基类作用域中，在基类和派生类中使用同一名字的成员函数时，就像一般的在局部声明的函数和在全局声明的函数一样：在派生类作用域中派生类成员将屏蔽基类成员，即使函数原型不同。</p>
  </li>
  <li>
    <p>局部作用域中声明的函数不会重载外围作用域中定义的函数，而是会屏蔽！因此，若派生类定义了重载成员，则通过派生类（的对象、指针或引用）只能访问派生类中重定义的那些成员，不管基类中的成员是否为virtual的！（可以通过using声明解决这个问题）</p>
  </li>
  <li>
    <p>通过基类可以调用被屏蔽的虚函数：</p>
  </li>
</ol>

<p>struct Base { virtual int fcn(); }
struct D1 : Base { int fcn(int);  /* 屏蔽了Base的fcn <em>/ }
struct D2 : D1 { int fcn(int);  /</em> 屏蔽了D1的fcn */  int fcn();}</p>

<p>Base b;
D1 d1;
D2 d2;
Base *bp1 = &amp;b, *bp2 = &amp;d1, *bp3 = &amp;d2;</p>

<p>bp1-&gt;fcn();  // Base::fcn
bp2-&gt;fcn();  // Base::fcn，注意不能用D1的对象、引用或指针调用fcn()，因为它被fcn(int)屏蔽了！
bp3-&gt;fcn();  // D2::fcn</p>

<ol>
  <li>（名字查找与继承的关系）确定函数调用遵循以下四个步骤
I. 首先确定进行函数调用的对象、引用或指针的静态类型
II. 在该类中查找函数（名字），若找不到则从直接基类开始往上找，若最终找不到则出错
III. 一旦找到了该名字，就进行常规类型检查，看调用是否合法
IV. 若合法，编译器就生成代码。若函数为虚且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪个函数版本，否则，编译器生成代码直接调用函数。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第9-13章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第9章 顺序容器</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第13章 复制控制</a></li>
</ol>

<h2 id="section">第9章 顺序容器</h2>

<ol>
  <li>
    <p>指定容器大小的类型应该使用该容器的size_type类型</p>
  </li>
  <li>
    <p>允许通过使用内置数组中的一对指针初始化容器</p>
  </li>
  <li>
    <p>容器元素类型必须满足以下两个约束：
a. 元素类型必须支持赋值运算（故不能是引用）
b. 元素类型的对象必须可以复制（用于初始化和push_back等）</p>
  </li>
</ol>

<p>第11章 泛型算法</p>

<ol>
  <li>为了以降序排列vector，只需向sort传递一对反向迭代器sort(vec.rbegin(), vec.rend());</li>
</ol>

<p>第12章 类</p>

<ol>
  <li>
    <p>声明一个类而不定义它（即前向声明）时，该类是一个不完全类型，只能以有限方式使用：
a. 不知道包含哪些成员
b. 只能用于定义指向该类型的指针及引用，或用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数
c. 不能用于定义数据成员或该类的对象（故类不能具有自身类型的数据成员）</p>
  </li>
  <li>
    <p>在一个源文件中一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的</p>
  </li>
  <li>
    <p>在普通的非const成员函数中，this的类型是一个指向类类型的const指针</p>
  </li>
  <li>
    <p>当我们希望类的数据成员（甚至在const成员函数内）可以被修改时，可将它们声明为mutable。mutable数据成员永远都不会且不能为const。</p>
  </li>
  <li>
    <p>如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外（否则在之内）。</p>
  </li>
  <li>
    <p>在类定义体外定义的成员函数的返回类型如果使用由该类定义的类型，则必须使用完全限定名，这是因为在函数名被处理前，代码不在类作用域内。</p>
  </li>
  <li>
    <p>类定义实际上是在两个阶段中处理：
a. 首先编译成员声明
b. 只有在所有成员出现之后，才编译它们的定义本身（因此成员函数可以使用类作用域中所有名字）</p>
  </li>
  <li>
    <p>必须在类中先定义类型名字，才能将它们用作数据成员的类型，或者成员函数的返回类型或形参类型</p>
  </li>
  <li>
    <p>一旦一个名字被用作类型名，该名字就不能被重复定义。（但若一个名字在类外作用域中首先被定义为类型名，类中可以先重新定义它再用作类型名）。</p>
  </li>
  <li>
    <p>构造函数不能声明为const</p>
  </li>
  <li>
    <p>对非类类型的数据成员进行赋值或使用初始化式在结果和性能上都是等价的</p>
  </li>
  <li>
    <p>成员被初始化的次序就是定义成员的次序，不管它们在初始化列表中顺序如何。因此以下程序非法：</p>
  </li>
</ol>

<p>class X {
  int i;
  int j;
 public:
  X(int val): j(val), i(j) {}
};</p>

<ol>
  <li>
    <p>当没有在初始化列表中指出或使用合成的默认构造函数时，对于内置和复合类型的成员（如指针和数组），只对定义在全局作用域中的对象才初始化。</p>
  </li>
  <li>
    <p>对于一个没有定义默认构造函数（显式或隐式地）的类：
a. 不能用作动态分配数组的元素类型
b. 其静态分配数组必须为每个元素提供一个显式的初始化式</p>
  </li>
  <li>
    <p>可以用单个实参来调用的非explicit构造函数定义了从形参类型到该类类型的一个隐式转换。</p>
  </li>
  <li>
    <p>友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。</p>
  </li>
  <li>
    <p>友元不是授予友元关系的那个类的成员，故它们不受其声明出现部分的访问控制影响。</p>
  </li>
  <li>
    <p>必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</p>
  </li>
  <li>
    <p>友元声明将已命名的类或非成员函数引入到外围作用域中。此外，友元函数可以在类的内部定义，该函数的作用域扩展到包围该类定义的作用域。用友元引入的类名和函数（定义或声明），可以像预先声明的一样使用。</p>
  </li>
  <li>
    <p>const static数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，但此时不必再指定初始值。</p>
  </li>
  <li>
    <p>static数据成员的类型可以是该成员所属的类类型，并可用作默认实参。</p>
  </li>
  <li>
    <p>在构造函数初始化列表中除了默认的方式（如x()）外，无法用其他方式（如传递一个数组）来初始化一个数组类型的成员变量。</p>
  </li>
  <li>
    <p>typedef在类中必须出现在使用其定义的类型别名的声明之前。</p>
  </li>
</ol>

<h2 id="section-1">第13章 复制控制</h2>

<ol>
  <li>
    <p>复制构造函数、赋值构造函数和析构函数总称为复制控制（copy control），编译器自动实现这些操作，但类也可以定义自己的版本。</p>
  </li>
  <li>
    <p>对于语句string str = “hello”;，在创建str时，编译器首先调用接受一个c风格字符串形参的string构造函数，创建一个临时对象，然后编译器使用string复制构造函数将str初始化为那个临时对象的副本。</p>
  </li>
  <li>
    <p>对于语句C ci = string(“hello”);，ci的初始化是否正确取决于两点：
a. 类C的带一个string形参的ctor是否为explicit（如果是explicit则失败）
b. 类C的copy ctor对当前作用域是否可见</p>
  </li>
  <li>
    <p>若使用元素初始化列表初始化数组元素，则首先根据指定值创建数组元素类型的元素，然后用复制构造函数将该值复制到相应元素：</p>
  </li>
</ol>

<p>View Code CPP
1
2
3
4
C ci[] = {
  string(“hello”),  // 单参数ctor + copy ctor
  C()           // 默认ctor + copy ctor
};</p>
<ol>
  <li>
    <p>合成的复制构造函数将复制数组类型成员的每一个元素，合成的复制操作符也会给数组的每个元素赋值。</p>
  </li>
  <li>
    <p>当copy ctor定义为explicit时，就不能用于向函数传递对象和从函数返回对象。</p>
  </li>
  <li>
    <p>容器（不管是标准库容器还是内置数组）中的元素总是按逆序撤销</p>
  </li>
  <li>
    <p>合成析构函数按对象创建时的逆序撤销每个非static成员（即按类中成员声明次序的逆序）</p>
  </li>
  <li>
    <p>因为不能指定任何形参，所以不能重载析构函数</p>
  </li>
  <li>
    <p>即使我们编写了自己的析构函数，合成的析构函数仍然运行。</p>
  </li>
  <li>
    <p>自定义的copy ctor必须是引用传递形参（而不是传值），否则会导致无限递归。</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第5-8章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter05to08/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter05to08</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第5章 表达式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第6章 语句</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">第7章 函数</a></li>
  <li><a href="#io" id="markdown-toc-io">第8章 标准I/O库</a></li>
</ol>

<h2 id="section">第5章 表达式</h2>

<ol>
  <li>
    <p>若两个操作数都是负数则求模结果为负。</p>
  </li>
  <li>
    <p>逻辑非：若操作数非零值则结果为false。</p>
  </li>
  <li>
    <p>如果val不是bool类型，不要这样比较：if (val == true)</p>
  </li>
  <li>
    <p>如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器，不可移植</p>
  </li>
  <li>
    <p>移位操作的右操作数不可为负且必须严格小于左操作数位数值，否则结果未定义</p>
  </li>
  <li>
    <p>sizeof是一个操作符，其结果是编译时常量。三种用法：</p>
  </li>
</ol>

<p>sizeof (type name)
sizeof (expr)
sizeof expr
将sizeof用于expr时，并没有计算expr的值</p>

<ol>
  <li>
    <p>逗号表达式从左向右计算，结果是其最右边表达式的值。如果最右边的操作数的左值，则逗号表达式的值也是左值。</p>
  </li>
  <li>
    <p>值初始化的“()”语法必须置于类型名后面，而不是变量后。如：
int x();
上式声明了一个名为x、没有参数而返回int值的函数，而不是定义一个变量。</p>
  </li>
  <li>
    <p>c++保证：删除0值的指针是安全的，但这样做没有任何意义。</p>
  </li>
  <li>
    <p>删除指针后，该指针编程悬垂指针，不再有效。</p>
  </li>
  <li>
    <p>动态创建const对象的例子：const int *pci = new cons tint(10);</p>
  </li>
  <li>
    <p>删除动态分配的内存失败称为“内存泄露”</p>
  </li>
  <li>
    <p>类类型可以定义由编译器自动执行的类型转换，如：while (cin » s) …</p>
  </li>
  <li>
    <p>显式转换也称为强制类型转换（cast），包括：dynamic_cast，const_cast，static_cast，reinterpret_cast。</p>
  </li>
  <li>
    <p>char *p = “hello”;在编译时会出现警告，改成const char *就没问题。</p>
  </li>
  <li>
    <p>sizeof (func ());的结果是func函数的返回类型的size，且不执行func。注意，不能这样用：sizeof (func);。因为func是函数类型，而sizeof不支持函数类型，func()才是数据类型。</p>
  </li>
  <li>
    <p>string str();的作用是声明一个函数而不是定义一个变量（如果想定义一个使用默认构造函数的对象，正确写法是string str;）。但如果是string str(“abc”);则相反，因为编译器看到了”abc”是一个量而不是一个变量声明。另外可以这么干：string str = string();。</p>
  </li>
  <li>
    <p>for (;;);是一个死循环；for语句只要中间不写东西就是，这是合法的。省略循环条件等效于其永远为true。</p>
  </li>
  <li>
    <p>char *p = “hello”; p[0] = ‘x’;会导致segment fault。</p>
  </li>
  <li>
    <p>大多数操作符没有定义左右操作数的求值顺序，故不能依赖它来编写程序。</p>
  </li>
</ol>

<h2 id="section-1">第6章 语句</h2>

<ol>
  <li>
    <p>空语句，如：while (expr);；又如：a = b + c;;。后者由两条语句组成：一条表达式语句和一条空语句。</p>
  </li>
  <li>
    <p>在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。如：
if (int x = val) …;
switch (int x = func ()) …;</p>
  </li>
  <li>
    <p>switch语句的每个case的标号必须是整型常量表达式，浮点数也不行！任两个case标号不能有相同的值，否则compile error。</p>
  </li>
  <li>
    <p>switch结构中，除非使用块语句，否则只能在它的最后一个case或default标号后才能定义变量。</p>
  </li>
  <li>
    <p>do…while中的continue会继续求解循环条件（和while一样）</p>
  </li>
  <li>
    <p>使用预处理器进行调试：
$ cc –DNDEBUG main.c
这等效于在main.c的开头提供#define NDEBUG预处理命令。</p>
  </li>
</ol>

<h2 id="section-2">第7章 函数</h2>

<ol>
  <li>
    <p>函数由函数名以及一组操作数类型唯一地表示</p>
  </li>
  <li>
    <p>在c语言中具有const形参或非const形参的函数并无区别（引用和指针除外），故：
void fcn (const int i) { … }
void fcn (int i) { … }
会产生编译错误：重定义。c++为了兼容也保持这点。</p>
  </li>
  <li>
    <p>由于数组不能复制，所以无法编写使用数组类型形参的函数，而函数也不允许返回一个数组！</p>
  </li>
  <li>
    <p>由于使用数组名字时，数组会被自动转化为指针，所以处理数组的函数通常通过操纵指向数组中的元素的指针来处理数组。</p>
  </li>
  <li>
    <p>虽然不能直接传递数组，但形参可以写成数组形式，下面三种定义是等价的，形参类型都是int *：
void func (int *) {…}
void func (int []) {…}
void func (int [10]) {…}
编译器只会检查实参是不是指针、指针类型是否匹配，而不会检查数组的长度。故对于以上第三种定义可以传个int[2]进去。</p>
  </li>
  <li>
    <p>一般用法：传非引用指针：
void func (const int *) {…}
也可通过引用传递，此时编译器将检查数组实参的大小与形参大小是否匹配：
void func (int (&amp;arr)[10]) {…}</p>
  </li>
  <li>
    <p>多维数组的传递：c++中没有多维数组，所谓多维数组实际上是一个一维数组，其元素是由数组组成。因此，除了第一维以外的所有维的长度都是元素类型的一部分，必须明确指定：
void f (int (m*)[10]) {…}
void f (int m[][10]) {…}
void f (int m[100][10]) {…}
上述三种定义是等价的。100，类似地，将会被忽略。</p>
  </li>
  <li>
    <p>关于可变形参：对于c++程序，只能将简单数据类型传递给含有省略符形参，实际上，当需要传递给省略符形参时，大多数类类型对象都不能正确地复制</p>
  </li>
  <li>
    <p>返回类型为void的函数可以return另一个返回类型同样是void的函数的调用结果</p>
  </li>
  <li>
    <p>函数的返回值用于初始化在调用函数处创建的临时对象。当返回引用类型时，没有复制返回值，而是返回对象本身。</p>
  </li>
  <li>
    <p>函数声明时需提供：返回类型、函数名、形参列表（不必对形参命名）。这三个元素成为函数原型。</p>
  </li>
  <li>
    <p>默认实参可以是任何适当类型的表达式（包括函数调用）。</p>
  </li>
  <li>
    <p>可在函数声明也可在函数定义中指定默认实参，但在一个文件中只能为一个形参指定默认实参一次（因此h和cc只能有一个这么干，因为cc包含了h）。如果在函数定义中指定默认实参，那么只有在包含该函数定义的源文件中调用该函数时（被指定的默认实参）才有效。在声明时指定默认实参可以类似于这么干：int f (int = 0);</p>
  </li>
  <li>
    <p>只有当定义它的函数被调用时才存在的对象成为自动对象。</p>
  </li>
  <li>
    <p>内联函数应该在头文件中定义，这一点不同于其他函数。这是因为，内联函数的定义对编译器而言必须是可见的，以便编译器能够在调用点内联展开该函数的代码。</p>
  </li>
  <li>
    <p>由编译器自动生成的默认构造函数对内置类型成员的初始化规则：
a. 若该类的对象被定义于全局作用域或定义为局部静态对象，这些成员被初始化为0
b. 否则没有初始化
另可参考《深度探索c++对象模型》</p>
  </li>
  <li>
    <p>重载函数：出现于相同作用域中（当作用域不同时会发生名字屏蔽而不是重载），名字相同而形参表不同（默认实参不改变形参表）。注意，重载函数可以有不同的返回类型。</p>
  </li>
  <li>
    <p>在c++中，名字查找发生在类型检查之前。</p>
  </li>
  <li>
    <p>形参与const形参的等价性仅适用于非引用形参，有const引用的形参与有非const引用形参的函数是不同的，对于const指针和非const指针也是不同的。（即：仅当形参是引用或指针时，形参是否为const才有影响）</p>
  </li>
  <li>
    <p>局部声明的名字会屏蔽全局声明的同名名字（包括函数名，此时，只要同名就会屏蔽，不管形参如何）</p>
  </li>
  <li>
    <p>重载确定的寻找最佳匹配方法：若仅有一个函数满足以下条件则ok，否则编译错误：</p>
  </li>
</ol>

<p>其每个实参的匹配都不劣于其他可行函数需要的匹配
至少有一个实参的匹配优于其他可行函数提供的匹配</p>
<ol>
  <li>重载确定（overload resolution）的三个步骤：</li>
</ol>

<p>确定候选函数（candidate function）集：与被调函数同名的函数的集合（声明要在调用点可见；如果调用的是类的成员函数则不考虑访问控制符如public、private等，而是将该类的所有同名函数都取出拿来用）
选择可行函数（viable function），两个条件：
函数的形参个数与该调用的实参个数相同
每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型
寻找最佳匹配：先为每个实参划分等级，再按照第23点的方法做。</p>
<ol>
  <li>为了确定最佳匹配，编译器将实参到形参的类型转换划分等级：</li>
</ol>

<p>精确匹配
通过类型提升（promotion）实现的匹配，包括整形提升：char、signed char、unsigned char、short和unsigned short提升为int，其次是提升为unsigned int。如，对于func (‘a’);来说，void func (int);要优于void func (short);。
通过标准转换实现的匹配
数组-&gt;指针，指针-&gt;void*，0-&gt;指针
算术值和指针-&gt;bool
算术值&lt;-&gt;bool
enum-&gt;int或更高
非const-&gt;const引用；非const指针-&gt;const指针
由标准库类型定义的转换
通过类类型转换实现的匹配</p>
<ol>
  <li>
    <p>不能通过基于指针本身是否为const来实现函数重载（这符合第19点）：
void f (int *);
void f (int *const);  // 错误，重声明</p>
  </li>
  <li>
    <p>函数指针：在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，故以下两句赋值含义相同：
funcptr p1 = func;
funcpty p2 = &amp;func;
故调用时也相同：
p1 (params);等价于(*p1) (params);</p>
  </li>
  <li>
    <p>指向不同函数类型（包含返回类型的定义）的指针指针之间不存在转换。</p>
  </li>
  <li>
    <p>函数指针作为形参时，以下两种形式等价：
void f (bool (int <em>));
void f (bool (</em>)(int *));</p>
  </li>
  <li>
    <p>返回类型中的函数指针的例子：int (<em>ff (int)) (int *, int);。其中，ff (int)是一个函数，它返回一个函数指针，其类型为int (</em>)(int *, int);。</p>
  </li>
  <li>
    <p>函数的返回类型不能是一个函数，最多只能是一个函数指针！！</p>
  </li>
  <li>
    <p>若类A有个带一个int参数的ctor，则以下函数定义是合法的：A func() { return 10; }</p>
  </li>
  <li>
    <p>如果一个类定义了一个非const函数以及对应的const函数，是合法的，C++将其看成重载，不会引起编译错误。对于这点，我的理解是，C++会将成员函数重写为包含指向对象本身的隐含this指针的函数，这样，const成员函数就会变成const对象指针，根据第19点这是可以被重载的。</p>
  </li>
</ol>

<h2 id="io">第8章 标准I/O库</h2>

<ol>
  <li>
    <p>IO对象不可复制或赋值，这表示着：
a. 不能存储在容器中
b. 函数的形参或返回类型不能是非指针或引用的流类型</p>
  </li>
  <li>
    <p>刷新输出缓冲区的方法：
cout « “hi” « flush;  // 不增加任何数据
cout « “hi” « ends;  // 增加null字符
cout « “hi” « endl;</p>
  </li>
  <li>
    <p>如果一个流调用tie函数将其本身绑在传递给tie的ostream实参对象上，则该流上任何IO操作都会刷新实参所关联的缓冲区。</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第01-04章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter01to04/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter01to04</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第1章 快速入门</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第2章 变量和基本类型</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第1章 快速入门</h2>

<ol>
  <li>Windows下查看程序返回值：<code class="language-c++ highlighter-rouge"><span class="nb">echo</span> %ERRORLEVEL%</code></li>
  <li>endl是一个特殊值，称为操纵符（manipulator），将其写入输出流时将会输出换行效果并刷新与设备相关联的缓冲区</li>
  <li><code class="language-c++ highlighter-rouge"><span class="s">"A"</span></code>表示包含字母A和空字符两个字符的字符串</li>
  <li>宽字符：<code class="language-c++ highlighter-rouge"><span class="n">wchat_t</span> <span class="n">ch</span><span class="o">=</span><span class="sc">L'a'</span><span class="p">;</span></code></li>
  <li>宽字符串：<code class="language-c++ highlighter-rouge"><span class="s">L"hello"</span></code>（包含了最后的宽空字符）</li>
</ol>

<h2 id="section-1">第2章 变量和基本类型</h2>

<ol>
  <li>变量名不能包含两个连续的下划线，也不能以下划线开头后面紧跟一个大写字母</li>
  <li>定义和声明的区别：
    <ul>
      <li>定义：为变量分配存储空间，还可以为变量指定初值</li>
      <li>声明：用于向程序表明变量的类型和名字</li>
    </ul>
  </li>
  <li>定义也是声明：当定义变量时我们声明了它的类型和名字</li>
  <li>如果声明有初始化式，那么它可被当作是定义，即使被标记为<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>。如：
<code class="language-c++ highlighter-rouge"><span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></code></li>
  <li>只有当<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>声明位于函数外部时，才可以含有初始化式（此时被当成定义）</li>
  <li>与一般的变量不同，在全局作用域声明的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。除非定义时加上<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>。</li>
  <li>引用是一种复合类型（是指用其他类型定义的类型）</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre>
    </div>
    <p>但同样的初始化对于非const引用都是不合法的，因为对于：</p>
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span>
</code></pre>
    </div>
    <p>编译器会将其变成：</p>
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre>
    </div>
    <p>如果ri不是const，则可对其赋值，但不会修改dval，矛盾。</p>
  </li>
  <li>非const的引用只能绑定到与该引用同类型的对象；const引用则可以绑定到不同但类型相关的对象或右值。</li>
  <li>枚举成员的值可以不唯一，如：enum { a = 2, b, c = 3, d };其中b和c都是3。</li>
  <li>不能把int等类型赋值给枚举类型的对象</li>
  <li>用于初始化的值必需是一个常量表达式，即在编译时就可以计算出值的表达式</li>
  <li>头文件一般包含：类的定义、extern变量的声明和函数的声明</li>
  <li>对于“头文件不应含有定义”这一规则，有三个例外：头文件可以定义类、值在编译时就已知的const对象和inline函数。这些实体可在多个源文件中定义，只要在每个源文件中的定义是相同的。p68</li>
  <li>当在头文件中定义了const变量后，每个包含该头文件的源文件都有了自己的const变量，其名称和值都一样；定义在头文件中的const变量应该是常量表达式。</li>
  <li>若const变量不是用常量表达式初始化，就不应在头文件中定义，而应在源文件中定义并初始化，并添加extern使其被多个文件共享。</li>
  <li>若在头文件中定义extern的const变量，多个cc文件都include了这个头文件且其obj会被链接到一起时，会出错：重定义。原因：这些cc文件引用头文件后相当于在文件中定义了这个const变量，但由于加了extern，使其全局可见。</li>
  <li>可以声明引用，例如在a.cc中定义：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ra</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre>
    </div>
    <p>则可以在a.h中声明：extern const int &amp;ra;</p>
  </li>
  <li>逗号表达式与定义，以下是合法的：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ol>

<p>第3章 标准库类型</p>

<ol>
  <li>
    <p>getline(cin, line)：getline遇到第一个换行符就中止，几时cin的第一个字符就是</p>
  </li>
  <li>
    <p>string的“+”操作符左右两边必须至少有一个是string类型</p>
  </li>
  <li>
    <p>string对象的下标变量应为string::size_type</p>
  </li>
  <li>
    <p>注意区分const_iterator和const的iterator</p>
  </li>
  <li>
    <p>任何改变vector长度的操作都会使已存在的迭代器失效。</p>
  </li>
</ol>

<p>第4章 数组和指针</p>

<ol>
  <li>
    <p>数组元素的类型不能是引用</p>
  </li>
  <li>
    <p>如果没有显式提供元素初值，数组元素会像普通变量一样初始化（2.3.4节）：</p>
  </li>
</ol>

<p>在函数体外定义的内置数组，元素均初始化为0
在函数体内定义的内置数组，元素无初始化
不管数组在哪定义，若其元素为类类型，则用default constructor来初始化；若该类没有default constructor，则必须显式初始化。</p>
<ol>
  <li>字符数组：字符串的字面值包含一个额外的null字符</li>
</ol>

<p>char ca1[] = { ‘c’, ‘+’, ‘+’ };  //长度为3
char ca2[] = “c++”;  //长度为4
char ca3[3] = “c++”;  //编译错误</p>
<ol>
  <li>对指针进行初始化和赋值只能使用：</li>
</ol>

<p>0值常量表达式
类型匹配的对象地址
另一对象之后的下一地址
同类型的另一个有效指针</p>
<ol>
  <li>
    <p>void<em>指针可以保存任何类型对象的地址，不允许使用void</em>指针操纵它指向的对象</p>
  </li>
  <li>
    <p>两个指针减法操作的结果是标准库类型ptrdiff_t的数据。</p>
  </li>
  <li>
    <p>与任何const量一样，const指针也必须在定义时初始化。</p>
  </li>
  <li>
    <p>考虑如下代码：
typedef string *pstring;
const pstring cstr;
这里const修饰的是pstring类型，这是一个指针。因此上述定义等价于string * const cstr;</p>
  </li>
  <li>
    <p>可以在数组长度后加“()”来对数组元素做值初始化：
int *p = new int<a href="">10</a>;  // 初始化为0
若不加“()”对于内置类型是不初始化的，也不能用初始化列表。</p>
  </li>
  <li>
    <p>const对象的动态数组对于内置类型一定要加“()”。</p>
  </li>
  <li>
    <p>c++允许动态分配空数组</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
