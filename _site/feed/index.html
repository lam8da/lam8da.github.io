<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4001/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2017-07-29T22:51:45-07:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>Paxos与分布式系统</title>
      <link>http://localhost:4001/2017/07/29/paxos/</link>
      <pubDate>2017-07-29T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/29/paxos</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">术语&amp;约定</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">算法</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">一些要点</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">正确性证明</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">正确性证明（另一条思路）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">算法的其他特性</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">实例</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">实例1</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">实例2</a></li>
    </ul>
  </li>
  <li><a href="#section-9" id="markdown-toc-section-9">问题</a></li>
  <li><a href="#note" id="markdown-toc-note">其他note</a></li>
  <li><a href="#multi-paxos" id="markdown-toc-multi-paxos">Multi-Paxos</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">参考</a></li>
</ul>

<h2 id="section">术语&amp;约定</h2>

<ul>
  <li>系统有多个进程，进程可能失效然后重启，进程间只能靠发送消息进行通信。消息发送速率任意，消息可以重复，也有可能被网络丢弃，但不能是corrupted（即系统中没有拜占庭失效）。</li>
  <li>每个进程可以扮演如下三个角色中的一个或多个：</li>
  <li>proposer：负责提出proposal</li>
  <li>acceptor：负责接受（accept）和否决proposal，是最关键角色。</li>
  <li>learner：负责学习最终选定（chosen）的proposal</li>
  <li>要求所有acceptor组成的进程集合不变；如果一个acceptor进程失效，必须能够重启并重新拥有跟原来进程相同的标识。设acceptor的个数为N。</li>
  <li>proposal是一个二元组&lt;proposal_id, value&gt;。其中proposal_id是一个整数值，由提出该proposal的proposer选定。要求不同的proposal具有不同的proposal_id（不管是不是同一个proposer提出的），因此不同的proposer用于产生proposal_id的整数集必须不相交。</li>
  <li>一个proposal被chosen的精确定义是：超过半数的acceptor accept了该proposal（注意包括proposal_id）。accept是对于单个acceptor来说的应用于某个proposal上的动作。而chosen则是所有acceptor的accept动作达到的系统宏观上的一种状态。</li>
  <li>下文中使用符号X(n:v,m)表示acceptor X accept了编号为n值为v的proposal，而m是X回复过的编号最大的prepare request</li>
</ul>

<h2 id="section-1">算法</h2>

<ul>
  <li>Phase 1.
    <ul>
      <li>(a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.</li>
      <li>(b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with:
        <ul>
          <li>a promise not to accept any more proposals numbered less than n</li>
          <li>the highest-numbered proposal (if any) that it has accepted.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Phase 2.
    <ul>
      <li>(a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to <span style="color: blue">each of those acceptors</span> for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.</li>
      <li>(b) If an acceptor receives an accept request for a proposal numbered n, it <span style="color: blue">accepts the proposal</span> unless it has already responded to a prepare request having a number greater than n.</li>
    </ul>
  </li>
</ul>

<h2 id="section-2">一些要点</h2>

<ul>
  <li>对任意acceptor来说，如果它已经accept了一个proposal (n1, v1)，它之后仍然可以accept其他proposal如(n2, v2)。算法保证，如果在accept (n2, v2)前有一个proposal (n, v)被chosen，则v2==v且n2&gt;=n。反之，如果在accept (n2, v2)前没有任何proposal被chosen，则有n2&gt;n1而v2可以不等于v1。</li>
  <li><span style="color: blue">Phase 2 (a)中让proposer向每个给它发response的acceptor发出proposal，这是必须的。</span>如果是发给任意超过半数的acceptors，将可能出现一个acceptor accept一个比自己之前accept过的proposal的编号还小的proposal的情况，导致算法失效。见算法的其他特性特性3。</li>
  <li>不可能存在这种情况：
    <ul>
      <li>超过半数的acceptor accept了(n1, v1)</li>
      <li>其中一个acceptor（可以是那些accept了(n1, v1)的acceptor或其他acceptor）accept了(n2, v2)</li>
      <li>n2&gt;n1且v2!=v1
这可以从下面的证明过程得到。也可以从直观上来理解：在(n2, v2)被某个acceptor accept之前，必须得到过半数的acceptor保证不会accept小于n2的proposal。如果这些保证发生在(n1, v1)被chosen之后，v2必然会等于v1（证明中对n2=n1+1, n1+2, …进行归纳假设）；如果之前，则(n1, v1)不可能被过半数的acceptor chosen。</li>
    </ul>
  </li>
  <li>再强调一下：在Phase 2 (b)中accepts the proposal指的是该proposal作为一个整体（包括其proposal_id）被accepted。如果是具有相同value但不同proposal_id的proposals分别地被一些acceptor accept且这些acceptor个数加起来超过半数，这不能也不意味着到达chosen状态。下文的实例会举出这样的例子。</li>
  <li>上文Phase 1 (b)中的acceptor也可以这么干：
    <ul>
      <li>不respond且不更新自己记录的收到的prepare请求中最大的proposal_id，这相当于该prepare消息被网络丢弃。</li>
      <li>不respond但更新自己记录的收到的prepare请求中最大的proposal_id，这相当于respond了但是该response被网络丢弃。</li>
      <li>但绝不能：respond却不更新。</li>
    </ul>
  </li>
  <li>learner如何学习到结果：每个acceptor无论在任何时候accept了一个proposal就要给learner发消息（需要通过重传或其他机制保证该消息最终会被learner收到）。尽管消息可能是乱序到达的，但每个proposal都有一个proposal_id，而且任何acceptor只会按照proposal_id的递增顺序accept不同的proposal，因此learner仍然可以在收到消息后对同一个acceptor accept的proposal进行排序，找出一个被超过半数acceptor accept的proposal即为结果，如果找不到说明还没达成一致。</li>
</ul>

<h2 id="section-3">正确性证明</h2>

<p>求证：Paxos将保证</p>
<ul>
  <li>i 只有被proposed的value才会被chosen</li>
  <li>ii 如果有一个value被chosen，则只会有一个value被chosen</li>
  <li>iii 一个learner绝不会学到一个value，除非该value被chosen</li>
</ul>

<p>证明：由算法的过程可知i和iii是显然的。现在证明ii。由算法的Phase 2 (a)可知如下结论P2c成立：</p>

<p>P2c. For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either</p>
<ul>
  <li>(a) no acceptor in S has accepted any proposal numbered less than n, or</li>
  <li>(b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.</li>
</ul>

<p>现在来证明P2b：</p>

<p>P2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.</p>

<p>采用反证法。假设proposal (n, v)被chosen，而proposal (n1, v1)是被issued的满足n1&gt;n且v1!=v且proposal_id（即n1）最小的proposal。为了满足P2c，必须使P2c (a)或P2c (b)成立。而：</p>

<ol>
  <li>(n1, v1)要被issued，首先要得到任意一个<span style="color: blue">由过半数acceptor组成的集合S1</span>中每个acceptor的保证，说之后再也不accept任何proposal_id&lt;n1的proposal；而(n, v)被chosen，说明有一个<span style="color: blue">由过半数的acceptor组成的集合S2</span>中的所有acceptor都accept了它。S1和S2的交集S1∩S2中的每个acceptor都保证既不accept任何proposal_id&lt;n1的proposal，又accept了proposal_id&lt;n1的(n, v)；所以只能是先accept了(n, v)，再保证，故P2c (a)不成立。</li>
  <li>由上述分析可知，所有proposal_id&gt;n且被issued的的proposal都是在(n, v)被chosen<span style="color: blue">后</span>被issued的，而所有满足n&lt;proposal_id&lt;n1的proposal都具有value v（归纳法）。设所有回复过proposal_id在[n, n1)中的prepare请求的acceptor的集合为S3（所以这是一个由过半acceptor组成的集合），则S1∩S3非空，要满足P2c (b)，则prepare n1请求的回复中最大的proposal_id由S1∩S3决定，因而v1=v，与假设矛盾。</li>
</ol>

<p>因此P2b成立。</p>

<p>注：如何理解上述证明第2小节中的“<span style="color: blue">后</span>”：由于chosen是由S2中所有acceptor共同决定的，而时间是相对的，无法定义S2中哪个acceptor是“最后一个”accept了(n,v)的（同理，假如(n, v)没有被chosen，也无法定义到底是哪个acceptor的“不accept”即ignore动作最后决定了(n, v)不被chosen，这是题外话）。因此，这里说“在(n, v)被chosen<span style="color: blue">后</span>被issued”的精确定义是：S1∩S2中每个acceptor都是先accept了(n, v)，再发出保证说“再也不accept任何proposal_id&lt;n1的proposal”，从而使(n1, v1)可以被issued。</p>

<p>而P2b蕴含P2a：</p>

<p>P2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.</p>

<p>P2a又蕴含P2：</p>

<p>P2.  If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.</p>

<p>P2保证了每个被chosen的higher-numbered的proposal有value v，而由于消息可能重复和延迟发送，一个acceptor在accept了那个被chosen的proposal之后可能会收到一个延迟的lower-numbered的proposal。我们必须保证该acceptor不会accept它，这将在下一节的特性2证明。因此，P2和特性2保证了ii。证毕。</p>

<p>论文中其他推论：</p>

<ul>
  <li>P1a. 即算法步骤Phase 2 (b)。</li>
  <li>P1a蕴含了P1. An acceptor must accept the first proposal that it receives.</li>
</ul>

<h2 id="section-4">正确性证明（另一条思路）</h2>

<p>我觉得这是更容易理解的思路，而且是Paxos的精髓所在。</p>

<ul>
  <li>对所有proposal（proposal是经过所有acceptor保证过后才发出的）定义一个序，通过这里的交集证明方法证明这个序是个全序而不是偏序。</li>
  <li>而其中某个proposal被accept了，要证明所有之后的proposal都有相同的value即P2b</li>
  <li>那个第一个被accept的proposal p1之后的第一个proposal p2之间没有别的proposal，最多只有一些prepare request，而prepare request不会影响其后回复其他prepare request的value。所以p2会和p1有相同的value</li>
</ul>

<h2 id="section-5">算法的其他特性</h2>

<ul>
  <li>特性1·设acceptor X在任意时刻的状态为X(n:v,m)，则n&lt;=m。Phase 2 (a)保证了这点。</li>
  <li>特性2·不可能出现一个acceptor accept一个比自己之前accept过的proposal的编号还小的proposal的情况，这是因为：根据Phase 2 (b)，一个acceptor X(n:v,m)只能accept编号大于等于m的request，而任何时刻都有n&lt;=m（特性1）。</li>
  <li>特性3·如果Phase 2 (a)中的proposer不是向每个给它发response的acceptor发accept request，而是向任意过半数的acceptor发，尽管P2仍然成立，但特性1和特性2不再成立：一个acceptor可能accept一个比自己之前accept过的proposal的编号还小的proposal，算法将失败。考虑三个acceptor ABC的例子，初始为重设状态：
    <ul>
      <li>P1给AB发prepare 1</li>
      <li>
        <p>AB均回复保证</p>

        <p><span style="color: green">此时状态为：A(-:-,1) B(-:-,1) C(-:-,-)</span></p>
      </li>
      <li>P2给AB发prepare 100</li>
      <li>
        <p>AB均回复保证</p>

        <p><span style="color: green">此时状态为：A(-:-,100) B(-:-,100) C(-:-,-)</span></p>
      </li>
      <li>P2收到保证并给BC发(100:b)</li>
      <li>
        <p>BC收到并accept</p>

        <p><span style="color: green">此时状态为：A(-:-,100) B(100:b,100) C(100:b,-)</span></p>

        <p>注意(100:b)已经被chosen</p>
      </li>
      <li>P1收到保证并给BC发(1:a)</li>
      <li>
        <p>B不accept，而C收到并accept</p>

        <p><span style="color: green">此时状态为：A(-:-,100) B(100:b,100) C(1:a,-)</span></p>

        <p>再一次变成没有任何proposal被chosen的状态，算法失败</p>
      </li>
    </ul>
  </li>
  <li>特性4·如果维持特性3对Phase 2 (a)的修改，同时修改Phase 2 (b)使：禁止一个acceptor accept一个比自己之前accept过的proposal的编号还小的proposal，算法将成功，因为这不影响P2成立，而重新保证了特性2成立（尽管特性1不再满足）。</li>
  <li>特性5·一旦一个proposal被chosen，即使挂掉少半数的acceptor，算法的正确性仍然能够得到保证，即即使不断有proposer提出不同的proposal也不会改变那个被chosen的proposal！因此acceptor的挂掉不会阻止learner学习到被chosen的value：learner可以充当proposer执行算法直到新的proposal（包含相同的被chosen的value）被chosen即可（注意：一定要等到新的proposal被chosen，而不能从已有的N-1个acceptor的当前状态推断出是否有旧的proposal被chosen，原因可以考虑实例2步骤13完成后B挂掉的情况）</li>
</ul>

<h2 id="section-6">实例</h2>

<h3 id="section-7">实例1</h3>

<p>假设共有5个acceptor分别标记为ABCDE，任意数量个proposer分别为P1，P2，P3…，设一开始系统为重设状态，算法开始：</p>

<ol>
  <li>P1给ABC发编号为1的prepare</li>
  <li>ABC均返回response保证不接受编号小于1的proposal，但由于ABC均为初始状态故没有任何highest-numbered proposal被返回</li>
  <li>P1选定值a并把(1:a)发给ABC</li>
  <li>
    <p>A收到P1的消息并accept了(1:a)</p>

    <p><span style="color: green">此时状态为：A(1:a,1) B(-:-,1) C(-:-,1) D(-:-,-) E(-:-,-)</span></p>
  </li>
  <li>在BC收到P1的消息前，P2向BCD发出了编号为2的prepare并被BCD收到</li>
  <li>BCD均返回response保证不接受编号小于2的proposal，但由于BCD均为初始状态故没有返回任何highest-numbered proposal</li>
  <li>P1发给BC的消息在到达BC后被ignored（另一种可能的情况是：P1发给BC的消息被网络丢弃了。下面用这种情况简化描述）</li>
  <li>P2选定值b并把(2:b)发给BCD</li>
  <li>
    <p>B收到P2的消息并accept了(2:b)，P2发给CD的消息被网络丢弃</p>

    <p><span style="color: green">此时状态为：A(1:a,1) B(2:b,2) C(-:-,2) D(-:-,2) E(-:-,-)</span></p>
  </li>
  <li>P3向CDE发出了编号为3的prepare并被CDE收到</li>
  <li>CDE均返回response保证不接受编号小于3的proposal，CDE为初始状态故没有返回highest-numbered proposal</li>
  <li>P3选定值c并把(3:c)发给CDE</li>
  <li>
    <p>C收到P3的消息并accept了(3:c)，P3发给DE的消息被网络丢弃</p>

    <p><span style="color: green">此时状态为：A(1:a,1) B(2:b,2) C(3:c,3) D(-:-,3) E(-:-,3)</span></p>
  </li>
  <li>P4向DEA发出了编号为4的prepare并被DEA收到</li>
  <li>DEA均返回response保证不接受编号小于4的proposal，DE为初始状态故没有返回highest-numbered proposal，而A返回(1:a)</li>
  <li>P4在收到的highest-numbered proposal中选编号最大者的值a并把(4:a)发给DEA</li>
  <li>
    <p>D收到P4的消息并accept了(4:a)，P4发给EA的消息被网络丢弃</p>

    <p><span style="color: green">此时状态为：A(1:a,4) B(2:b,2) C(3:c,3) D(4:a,4) E(-:-,4)</span></p>
  </li>
  <li>P5向EAB发出了编号为5的prepare并被EAB收到</li>
  <li>EAB均返回response保证不接受编号小于5的proposal，E为初始状态故没有返回highest-numbered proposal，而A返回(1:a)，B返回(2:b)</li>
  <li>P5在收到的highest-numbered proposal中选编号最大者的值b并把(5:b)发给EAB</li>
  <li>
    <p>E收到P5的消息并accept了(5:b)，P5发给AB的消息被网络丢弃</p>

    <p><span style="color: green">此时状态为：A(1:a,5) B(2:b,5) C(3:c,3) D(4:a,4) E(5:b,5)</span></p>
  </li>
</ol>

<p>至此，每个acceptor都accept了一个proposal，但没有任何一个proposal被过半数的acceptor接受。因此此时的状态不是稳定状态，ABCDE都可以继续accept其他proposal，即使它们与自己之前accept过的proposal的value不一样。Paxos保证一旦有一个proposal被chosen（即被过半数acceptor接受）后系统就只会issued包含该proposal的value的proposal，因此chosen后的状态为稳定状态。继续重复类似上述的过程将得到如下状态序列：</p>

<ul>
  <li>A(6:c,6) B(2:b,6) C(3:c,6) D(4:a,4) E(5:b,5)</li>
  <li>A(6:c,6) B(7:a,7) C(3:c,7) D(4:a,7) E(5:b,5)</li>
  <li>A(6:c,6) B(7:a,7) C(8:b,8) D(4:a,8) E(5:b,8)</li>
  <li>A(6:c,9) B(7:a,7) C(8:b,8) D(9:c,9) E(5:b,9)</li>
  <li>…</li>
</ul>

<p>即系统无法取得progress达到一致状态，即使网络不丢包且消息也是顺序到达。但实际中发生这种情况的概率应该很小。</p>

<h3 id="section-8">实例2</h3>

<p>如果实例1中从第10步开始变为：</p>

<ol start="10">
  <li>P3向ACD发出了编号为3的prepare并被ACD收到</li>
  <li>ACD均返回response保证不接受编号小于3的proposal，CD为初始状态故没有返回highest-numbered proposal，而A返回(1:a)</li>
  <li>P3在收到的highest-numbered proposal中选编号最大者的值a并把(3:a)发给ACD</li>
  <li>
    <p>CD收到P3的消息并accept了(3:a)，P3发给A的消息被网络丢弃</p>

    <p><span style="color: green">此时状态为：A(1:a,3) B(2:b,2) C(3:a,3) D(3:a,3) E(-:-,-)</span>
此时ACD构成过半数acceptor且都accept value a，但是这并不表示a被chosen了！Paxos要求的是一个proposal作为一个整体被过半数acceptor accept，因此现在的状态不是一个chosen状态，系统并未达到一致且可能issue value不为a的proposal。考虑：</p>
  </li>
  <li>P4向EAB发出了编号为4的prepare并被EAB收到</li>
  <li>EAB均返回response保证不接受编号小于4的proposal，E为初始状态故没有返回highest-numbered proposal，而A返回(1:a)，B返回(2:b)</li>
  <li><span style="color: blue">P4在收到的highest-numbered proposal中选编号最大者的值b并把(4:b)发给EAB</span></li>
  <li>
    <p>EAB收到P4的消息并accept了(4:b)，到达一致状态</p>

    <p><span style="color: green">此时状态为：A(4:b,4) B(4:b,4) C(3:a,3) D(3:a,3) E(4:b,4)</span></p>

    <p>此后系统再也不可能产生value不为b的proposal。</p>
  </li>
</ol>

<h2 id="section-9">问题</h2>

<ul>
  <li>acceptor的个数是否可以为偶数？答：可以。证明过程对于N为任意正整数都成立。</li>
  <li>2PC是否是Paxos的变种(@Mike Burrows)？答：</li>
  <li>根据FLP结论如何构造出“单个进程失效使得Paxos无法达成一致”的例子？答：</li>
  <li>在一次算法的运行中最多被至少一个acceptor accept过的不同的v值只有向下取整n/2个？答：</li>
</ul>

<h2 id="note">其他note</h2>

<p>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。这即论文中所述的“分布式状态机”。
一个分布式算法，有两个最重要的属性：safety 和livness，简单来说safety就是指那些需要保证永远都不会发生的事情，livness是指那些最终一定会发生的事情</p>

<h2 id="multi-paxos">Multi-Paxos</h2>

<p>[from <a href="http://dsdoc.net/paxosmadesimple/index.html">dsdoc.net</a>]</p>

<p>如何理解“因为Leader的失败和新Leader的选举都是很少见的情况，因此执行一个状态机命令—即在命令值上达成一致性的花费就是执行该一致性算法的Phase 2的花费”：大部分时间里Leader正常；Leader正常时，如果majority的proposer在Phase 1承诺了编号 n，由于所有执行实例用同一个的提案编号计数器，即所有实例的Phase 1都完成了，之后只提交Phase2消息即可。即：用一个Phase 1的message搞定了一堆Paxos实例的Phase 1的执行。</p>

<h2 id="section-10">参考</h2>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">英文wiki</a></li>
  <li>各个版本的翻译和注解
    <ul>
      <li><a href="http://duanple.blog.163.com/blog/static/709717672011440267333/">银河里的星星</a> - done</li>
      <li><a href="http://codemacro.com/2014/10/15/explain-poxos/">loop in the codes</a> - done</li>
      <li><a href="http://blog.csdn.net/sparkliang/article/details/5740882">sparkliang的专栏</a> - done</li>
      <li><a href="http://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95">中文wiki</a> - done</li>
      <li><a href="http://timyang.net/distributed/paxos-scenarios/">后端技术by Tim Yang</a> - done</li>
      <li><a href="http://www.wuzesheng.com/?p=2724">小武哥的博客</a> - done</li>
      <li><a href="http://csrd.aliapp.com/?p=160">阿里核心团队博客1</a> - done</li>
      <li><a href="http://csrd.aliapp.com/?p=162">阿里核心团队博客2</a></li>
      <li><a href="http://csrd.aliapp.com/?p=261">阿里核心团队博客3</a></li>
      <li><a href="http://coderxy.com/archives/121">paxos图解</a></li>
      <li><a href="http://coderxy.com/archives/136">Paxos算法详解</a></li>
      <li><a href="http://www.cnblogs.com/ychellboy/category/226023.html">壮族小伙</a></li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《新概念物理教程》读书笔记</title>
      <link>http://localhost:4001/2017/07/23/new-concept-physics-notes/</link>
      <pubDate>2017-07-23T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/23/new-concept-physics-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">力学</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">第一章 质点运动学</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">第二章 动量守恒 质点动力学</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">力学</h2>

<h3 id="section-1">第一章 质点运动学</h3>

<ul>
  <li>视差：观测者在两个不同位置看到同一天体的方向之差</li>
  <li>基线：两个不同位置之间的联线</li>
  <li>AU：地球公转轨道的半径=1AU</li>
  <li>角秒：符号为<code class="language-c++ highlighter-rouge"><span class="s">"</span></code>，数量上等于$\pi/648000$（弧度制）</li>
  <li>秒差距（parsec，単位符号为pc）：选地球公转轨道半径为基线，视差等于1角秒的距离，叫做1秒差距，值为3.261633光年</li>
  <li>通过加速度（矢量）的定义（即$\Delta t$趋于0时速度矢量的变化）以及平面几何相似三角形的关系可以求得匀速圆周运动的加速度大小为$\frac{v^2}{R}$而方向垂直于运动物体的速度方向并指向圆心</li>
  <li>变速圆周运动和匀速圆周运动加速度的唯一不同在于切向加速度分量不为0</li>
  <li>一般曲线运动某点的加速度可以通过曲率半径和变速圆周运动联系起来求解</li>
  <li>反之，曲线运动中若知道某点的加速度，就可以求出该点的曲率半径</li>
  <li>圆周运动的叠加可以通过相对运动的经典力学法则（非相对论，即非洛伦兹变换）来理解</li>
</ul>

<h3 id="section-2">第二章 动量守恒 质点动力学</h3>

<ul>
  <li><strong>实验表明</strong>，在一个参考系中，只要某个物体符合惯性定律，则其他物体都服从惯性定律</li>
  <li>因此定义：对某一特定物体惯性定律成立的参考系，为<strong>惯性参考系</strong>，简称惯性系。从这里初步可以看到，惯性不是个别物体的性质，而是参考系，或者说，时空的性质</li>
  <li>任何惯性参考系所描述的空间都是均匀各向同性的，它们具有平移对称性和转动对称性。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>底层并发控制机制</title>
      <link>http://localhost:4001/2017/07/23/low-level-concurrency-control/</link>
      <pubDate>2017-07-23T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/23/low-level-concurrency-control</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#spin-lock" id="markdown-toc-spin-lock">Spin Lock</a></li>
  <li><a href="#out-of-order-execution" id="markdown-toc-out-of-order-execution">乱序执行（out-of-order execution）和内存屏障</a></li>
  <li><a href="#volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97" id="markdown-toc-volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97"><a href="http://baiy.cn/doc/cpp/advanced_topic_about_multicore_and_threading.htm#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C_volatile_%E5%85%B3%E9%94%AE%E5%AD%97">原子操作和volatile关键字</a></a></li>
</ul>

<h2 id="spin-lock">Spin Lock</h2>

<ul>
  <li>spinlock<a href="http://imaupk.blog.163.com/blog/static/348222512008112655221557/">实现1</a>，结构体类似于：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">spinlock</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span>  <span class="c1">// Initialized to 0.
</span><span class="p">}</span> <span class="n">t</span><span class="p">;</span>
</code></pre>
    </div>
    <ul>
      <li>上锁：
        <ul>
          <li>先把处理器的flag寄存器存起来，然后关中断</li>
          <li>spin_lock函数：用lock前缀（锁总线？）做一个原子操作：把t.slock的最低位置1并返回原来的值。然后检查原来的值，如果是0，说明当前线程成功上锁，可以返回；否则，说明之前已被上锁，然后不断循环测试t.slock的最低位的值（忙等待），直到变为0（某其他线程释放了），再重新用lock前缀去做原子操作并重复执行上述步骤。</li>
        </ul>
      </li>
      <li>解锁：
        <ul>
          <li>spin_unlock函数：用lock前缀将t.slock最低位置0
            <blockquote class="lambda_question">
              <p>问：这里可以不用lock前缀吗？</p>
            </blockquote>
          </li>
          <li>开中断，恢复flag寄存器的值</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>当我们能保证即使发生中断、在中断程序中也不会修改critical section的数据时，可以直接使用实现1的spin_lock和spin_unlock函数而无需保存flag寄存器和关中断</li>
  <li>读写者spinlock：与实现1类似，只是除了用1个bit表示写者是否已经获得锁之外，用31个bit来表示当前读者的个数（这样写者很容易饿死吧？）</li>
  <li>spinlock<a href="http://blog.csdn.net/yeqishi/article/details/6570208">实现2</a>：结构体与实现1一样，下面叙述忽略保存flag寄存器和关中断等内容
    <ul>
      <li>上锁：用lock前缀调用decb汇编指令将t.slock的值减 1。然后用jns汇编指令检查EFLAGS寄存器的SF(符号)位，如果为 0，说明slock原来的值为1，则线程获得锁，然后结束本次函数调用；如果SF位为1，说明slock原来的值为0或负数，锁已被占用，那么线程开始不断测试t.slock与0的大小关系，直到t.slock大于0，说明锁已被释放，则跳转到开始位置重新申请锁，重复上述过程。</li>
      <li>解锁：把t.slock置为1（不用lock前缀）</li>
    </ul>
  </li>
  <li>兼顾公平：排队自旋锁
    <ul>
      <li>排队自旋锁仍然使用原有的数据结构，但是赋予slock域新的含义。为了保存顺序信息，slock 域被分成两部分，分别保存锁持有者和未来锁申请者的票据序号(Ticket Number)：如果处理器个数不超过 256，则 Owner 域为 slock 的 0-7 位，Next 域为 slock 的 8-15 位，slock 的高 16 位不使用；如果处理器个数超过 256，则 Owner 和 Next 域均为 16 位，其中 Owner 域为 slock 的低 16 位。可见排队自旋锁最多支持 2^16=65536 个处理器。</li>
      <li>只有 Next 域与 Owner 域相等时，才表明锁处于未使用状态（此时也无人申请该锁）。排队自旋锁初始化时 slock 被置为 0，即 Owner 和 Next 置为 0。内核执行线程申请自旋锁时，原子地将 Next 域加 1，并将原值返回作为自己的票据序号。如果返回的票据序号等于申请时的 Owner 值，说明自旋锁处于未使用状态，则直接获得锁；否则，该线程忙等待检查 Owner 域是否等于自己持有的票据序号，一旦相等，则表明锁轮到自己获取。线程释放锁时，原子地将 Owner 域加 1 即可，下一个线程将会发现这一变化，从忙等待状态中退出。线程将严格地按照申请顺序依次获取排队自旋锁，从而完全解决了“不公平”问题。</li>
    </ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/ABA_problem">ABA problem</a></li>
</ul>

<h2 id="out-of-order-execution">乱序执行（out-of-order execution）和内存屏障</h2>

<ul>
  <li>乱序执行实现了避免计算机在用于运算的对象不可获取时的大量等待。</li>
  <li>
    <p>乱序执行使用其他“可以执行”的指令来填补了时间的空隙，然后在在结束时重新排序运算结果来实现指令的顺序执行中的运行结果。指令在原始计算机代码中的顺序被称为程序顺序，在处理器中他们被按照数据顺序中被处理，这种顺序中，数据，运算符，在计算机寄存器中变得可以获取。一般来说乱序执行需要复杂的电路来实现转换一种顺序到另一中顺序并且维护在输出时的逻辑顺序；而处理器本身就好像是随机执行的样子。</p>
  </li>
  <li>内存一致性模型（<a href="http://www.cnblogs.com/haippy/p/3412858.html">参考这里</a>），以下讨论的写操作的order都是指针对不同内存位置的写，对同一内存位置的写必须是顺序一致的，否则程序正确性无法保证
    <ul>
      <li>顺序一致性（sequential consistency）模型：Lamport于1979：the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program。这要求同一处理器的所有操作（包括读和写）都是顺序执行的</li>
      <li>处理器一致性（processor consistency）模型：同一处理器中，所有读操作之间是sequential consistency的，任意写操作执行前所有先于（指program order）该写操作的所有访存操作（包括读和写）都已完成。该模型允许读操作被reorder至对另一位置的写之前。</li>
      <li>弱一致性（weak consistency）模型：把普通的读写访存操作和同步操作进行区分。所有同步操作之间是sequential consistency的，任一同步操作开始前所有先于该操作的普通访存操作都已完成，任一普通访存操作开始前所有先于该操作的同步操作都已完成。</li>
      <li>释放一致性（release consistency）模型：把同步操作进一步分为acquire和release操作。所有同步操作之间是sequential consistency的，任一release操作开始前所有先于该操作的普通访存操作都已完成，任一普通访存操作开始前所有先于该操作的acquire操作都已完成。</li>
    </ul>
  </li>
  <li>x86-64的内存模型：
    <ul>
      <li>Loads are not reordered with other loads.</li>
      <li>Stores are not reordered with other stores.</li>
      <li>Stores are not reordered with older loads.</li>
      <li><span style="color: blue">Loads may be reordered with older writes to different locations but not with older writes to the same location.</span></li>
      <li>In a multiprocessor system, memory ordering obeys causality （因果关系） (memory ordering respects transitive visibility).</li>
      <li>In a multiprocessor system, stores to the same location have a total order.</li>
      <li>In a multiprocessor system, locked instructions have a total order.</li>
      <li>Loads and stores are not reordered with locked instructions.</li>
    </ul>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">""</span> <span class="o">:::</span> <span class="s">"memory"</span><span class="p">);</span></code> creates a <span style="color: blue">compiler level</span> memory barrier forcing <span style="color: blue">optimizer</span> to not re-order memory accesses across the barrier.</li>
  <li>指令流水线（pipelining）：把一条指令分为取址、解码、执行、存储结果、结束等几个部分，连续的指令的不同部分并行执行，形成一个流水线</li>
  <li>lfence/sfence/mfence from intel manual section 8.2.2
    <ul>
      <li>Reads cannot pass earlier LFENCE and MFENCE instructions.</li>
      <li>Writes cannot pass earlier LFENCE, SFENCE, and MFENCE instructions.</li>
      <li>LFENCE instructions cannot pass earlier reads.</li>
      <li>SFENCE instructions cannot pass earlier writes.</li>
      <li>MFENCE instructions cannot pass earlier reads or writes.</li>
      <li>by i and iii, lfence enforces #LoadLoad ordering</li>
      <li>by ii and iii, lfence enforces #LoadStore ordering</li>
      <li>by ii and iv, sfence enforces #StoreStore ordering</li>
      <li>sfence not enforces #StoreLoad ordering</li>
    </ul>
  </li>
  <li>lock 前缀的访存指令相当于 Full Barrier，xchg 已隐式加 lock 前缀。</li>
  <li>具有acquire语义的内存屏障，保证其后的读写不会提前到屏障之前</li>
  <li>具有release语义的屏障，保证之前的读写已经生效/可见</li>
  <li>acquire和release这两种内存屏障都是单向的，即允许临界区外的读写进入到临界区内。具体到 X86-64 架构，考虑前面描述的内存模型，读操作就具有acquire语义（因为一个读操作其后的读写都不会被reorder到该读操作之前），而写操作具有release语义（因为一个写操作之前的读写都不会被reorder到该写操作之后）</li>
  <li><a href="https://en.wikipedia.org/wiki/MESI_protocol">MSEI protocol</a></li>
</ul>

<h2 id="volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97"><a href="http://baiy.cn/doc/cpp/advanced_topic_about_multicore_and_threading.htm#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C_volatile_%E5%85%B3%E9%94%AE%E5%AD%97">原子操作和volatile关键字</a></h2>

<ul>
  <li>C/C++ 中的volatile关键字提供了以下保证：
    <ul>
      <li>对声明为volatile的变量进行的任何操作都不会被优化器去除，即使它看起来没有意义（例如：连续多次对某个变量赋相同的值），因为它可能被某个在编译时未知的外部设备或线程访问。</li>
      <li>被声明为volatile的变量不会被编译器优化到寄存器中，每次读写操作都保证在内存(详见下文)中完成。</li>
      <li>在不同表达式内的多个volatile变量间的操作顺序不会被优化器调换（即：编译器保证多个volatile变量在 sequence point之间的访问顺序不会被优化和调整）。</li>
    </ul>
  </li>
  <li>volatile<span style="color: blue"><strong>不</strong></span>提供如下保证
    <ul>
      <li>volatile声明不保证读写和运算操作的原子性。</li>
      <li>volatile声明不保证对其进行的读写操作直接发生在主内存。相反，CPU 会尽可能让这些读写操作发生在 L1/L2 等cache上。除非：
        <ul>
          <li>发生了一个未命中的读请求。</li>
          <li>所有级别的cache均已被配置为通过式写（write through）。</li>
          <li>目标地址为 non-cacheable区（主要是其它设备映射到内存地址空间的通信接口。例如：网卡的板载缓冲区、显卡板载显存、WatchDog寄存器等等）。</li>
        </ul>
      </li>
      <li>编译器仅保证在生成目标码时不调整volatile变量的访问顺序，但通常并不保证该变量不受处理器的out-of-order特性影响。目前唯一一个已知的特例是安腾（IA64）处理器版的 VC：在生成 IA64 Target时，VC会自动在所有volatile访问之间添加内存屏障（详见下文）以保证访问顺序。但ISO标准并未要求编译器实现类似机制。实际上，其它编译器（或是面向其它平台的 VC）也都没有类似保证。也就是说，通常认为volatile并不保证代码在处理器上的执行顺序，如果需要类似的保证，程序员应当自己使用内存屏障操作。</li>
    </ul>
  </li>
  <li>而原子操作要求做到以下保证：
    <ul>
      <li>对原子量的 ‘读出-计算-写入’ 操作序列是原子的，在以上动作完成之前，任何其它处理器和线程均无法访问该原子量。</li>
      <li>原子操作必须保证缓存一致性。即：在多处理器环境中，原子操作要同时保持所有处理器上的各级cache之间、以及它们与主存间的访问一致性。</li>
    </ul>
  </li>
  <li>可见，使用volitale关键字并不足以保证操作的原子语义。volitale关键字的主要设计目的是支持C/C++程序与内存映射设备间的通信。但这并不是说volitale关键字对原子操作没有任何帮助：
    <ul>
      <li>对于一个被声明为volitale类型的原子量来说，如果所有写操作都是原子的，并且已提供了必要的cache一致性保证，那么读取该原子量时就不必再次对总线上锁。</li>
      <li>这是因为volitale关键字保证了对该变量的读操作起码是在当前 CPUcache中完成的（即：该变量不会被优化到寄存器中）。与此同时，只要当前环境能够保证多个处理器的cache之间，以及cache与主存之间的访问一致性。那么该读操作不管在主存还是当前系统中任意一个处理器的cache上发生，读到的都是一致的数据。</li>
      <li>在这里，volitale关键字配合原子量的写入操作一起实现了一个典型的读者/写者同步模型：所有写操作和cache同步都保证被原子、互斥地完成；读操作则可以被并发地实现。这也是 Windows API 中没有提供类似 ‘AtomicLoad’ 式语义操作的原因。</li>
      <li>当然，这里还有一个隐含的附加条件，就是 CPU 必须能够在一个操作中读入这个原子量。这个条件通常可以忽略，因为超出CPU位宽的数据类型通常无法被实现成真正的原子量类型。</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>互斥算法</title>
      <link>http://localhost:4001/2017/07/22/mutual-exclusion-algorithms/</link>
      <pubDate>2017-07-22T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/22/mutual-exclusion-algorithms</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#petersoncpu" id="markdown-toc-petersoncpu">Peterson算法（要注意CPU对内存访问顺序的优化改变）</a></li>
  <li><a href="#filtern2peterson" id="markdown-toc-filtern2peterson">Filter算法：N大于2时的Peterson算法</a></li>
  <li><a href="#deker" id="markdown-toc-deker">Deker算法</a></li>
  <li><a href="#lamport" id="markdown-toc-lamport">Lamport面包店算法</a></li>
  <li><a href="#eisenberg--mcguire-algorithm" id="markdown-toc-eisenberg--mcguire-algorithm">Eisenberg &amp; McGuire algorithm</a></li>
  <li><a href="#szymanski" id="markdown-toc-szymanski">Szymanski算法</a></li>
</ul>

<h2 id="petersoncpu">Peterson算法（要注意CPU对内存访问顺序的优化改变）</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P0:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P1:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="filtern2peterson">Filter算法：N大于2时的Peterson算法</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>  <span class="c1">// current level of processes 0...N-1
</span>
<span class="c1">// the waiting process of each level 0...N-2.
// 这是一个排队队列，任何时刻当所有进程在以下while忙等待稳定后或在临界区执行中
// 时（假设临界区足够长），不可能有两个或以上pending进程的level为同一个值
</span><span class="n">waiting</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>Code for process #i
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> 
  <span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
  <span class="n">waiting</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">waiting</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">there</span> <span class="n">exists</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">,</span> <span class="n">such</span> <span class="n">that</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">));</span>  <span class="c1">// busy wait
</span><span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// exit section
</span></code></pre>
    </div>
  </li>
</ul>

<h2 id="deker">Deker算法</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// or 1. The init value determines the first
</span>           <span class="c1">// process to enter the critical section
</span></code></pre>
    </div>
  </li>
  <li>P0:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// busy wait
</span>    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P1:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// busy wait
</span>    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="lamport">Lamport面包店算法</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Declaration and initial values of global variables
</span><span class="nl">Entering:</span> <span class="n">array</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="n">of</span> <span class="kt">bool</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
<span class="n">Number</span><span class="o">:</span> <span class="n">array</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="n">of</span> <span class="n">integer</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="n">lock</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Entering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">Number</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">Number</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">]);</span>
  <span class="n">Entering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Wait until thread j receives its number:
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">Entering</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="c1">// 上述这个while必不可少，否则在下面的&lt;判断中可能会有两个（或多个？）线程
</span>    <span class="c1">// 同时失效而同时进入critical section：考虑两个线程都把Number设为同一值但是
</span>    <span class="c1">// j&lt;i且i先到达此处的情况，这样j可能还未设置Number[j]，于是i将读到0，下面的
</span>    <span class="c1">// while失效而进入临界区；而当j进入时，下面的小于号判断失效，也进入临界区
</span>
    <span class="c1">// Wait until all threads with smaller numbers or with the same number,
</span>    <span class="c1">// but with higher priority, finish their work:
</span>    <span class="k">while</span> <span class="p">((</span><span class="n">Number</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">Number</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)));</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">unlock</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Thread</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">...</span>  <span class="cm">/* critical section here */</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">...</span>  <span class="c1">// non-critical section
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="eisenberg--mcguire-algorithm">Eisenberg &amp; McGuire algorithm</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">pstate</span> <span class="o">=</span> <span class="p">{</span><span class="n">IDLE</span><span class="p">,</span> <span class="n">WAITING</span><span class="p">,</span> <span class="n">ACTIVE</span><span class="p">};</span>
<span class="n">pstate</span> <span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
<span class="c1">// The variable turn, is set arbitrarily to a number between 0 and n-1 at the
// start of the algorithm.
// The flags variable, for each process is set to WAITING whenever it intends to
// enter the critical section.
// flags takes either IDLE or WAITING or ACTIVE.
// Initially the flags variable for each process is initialized to IDLE.
</span><span class="n">repeat</span> <span class="p">{</span>
  <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">WAITING</span><span class="p">;</span>  <span class="cm">/* announce that we need the resource */</span>

  <span class="cm">/* scan processes from the one with the turn up to ourselves. */</span>
  <span class="cm">/* repeat if necessary until the scan finds all processes idle */</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IDLE</span><span class="p">)</span> <span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">index</span> <span class="o">:=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">ACTIVE</span><span class="p">;</span>  <span class="cm">/* now tentatively claim the resource */</span>

  <span class="cm">/* find the first active process besides ourselves, if any */</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ACTIVE</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">index</span> <span class="o">:=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// if there were no other active processes, AND if we have the turn or else
</span>  <span class="c1">// whoever has it is idle, then proceed.
</span>  <span class="c1">// Otherwise, repeat the whole sequence.
</span><span class="p">}</span> <span class="n">until</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">turn</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">turn</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">)));</span>

<span class="n">turn</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* claim the turn and proceed */</span>

<span class="cm">/* Critical Section Code of the Process */</span>

<span class="c1">// find a process which is not IDLE (if there are no others, we will find
// ourselves)
</span><span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="o">+</span><span class="mi">1</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">turn</span> <span class="o">:=</span> <span class="n">index</span><span class="p">;</span>  <span class="cm">/* give the turn to someone that needs it, or keep it */</span>
<span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">IDLE</span><span class="p">;</span>  <span class="cm">/* we're finished now */</span>
</code></pre>
</div>

<h2 id="szymanski">Szymanski算法</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 进入临界区的协议：
</span><span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1">// 站在入口门外，申请进入等候室
// 等待入口门打开。即不存在有进程处于3、4状态，包括正在进门、正在使用临界区
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
<span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// 站在入口门处，即正在进入。
</span><span class="k">if</span> <span class="n">any</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span>  <span class="c1">// 如果还有在入口门外等待进入的线程
</span>  <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// 把自己置为在入口门内，等待所有提出申请的线程都完成进入等候室
</span>  <span class="n">await_until</span><span class="p">(</span><span class="n">any</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">// 等待最后进门的线程关闭入口门
</span><span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1">// 门处于关闭状态，线程在等候室
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">self</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1">// 等待所有具有更高优先级的线程访问完临界区，退出等候室
</span>
<span class="c1">// 这里是临界区...
</span>
<span class="c1">// 退出临界区的协议
// 确保所有比自己优先级低的已经通过入口门的线程都进入了等候室
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="o">+</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
<span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">// 离开等候室，如果自己是最后离开的，则入口门被打开
</span></code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>GCC内嵌汇编笔记</title>
      <link>http://localhost:4001/2017/07/22/gcc-inline-assembly/</link>
      <pubDate>2017-07-22T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/22/gcc-inline-assembly</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">__asm__</span></code>表示后面的代码为内嵌汇编，<code class="language-c++ highlighter-rouge"><span class="k">asm</span></code>是<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span></code>的别名。<code class="language-c++ highlighter-rouge"><span class="n">__volatile__</span></code>表示编译器不要优化代码，后面的指令保留原样，<code class="language-c++ highlighter-rouge"><span class="k">volatile</span></code>是它的别名。括号里面是汇编指令。使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。示例：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__violate__</span> <span class="p">(</span><span class="s">"movl %1,%0"</span> <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">input</span><span class="p">));</span>
</code></pre>
    </div>
    <p>其中<code class="language-c++ highlighter-rouge"><span class="n">movl</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="o">%</span><span class="mi">0</span></code>是指令模板；<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">input</span></code>，他们按照出现的顺序分别与指令操作数<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>对应；注意对应顺序：第一个C表达式对应<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>；第二个表达式对应<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，依次类推，操作数至多有10个，分别用<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，…，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>表示。 在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>前面的限制字符串是<code class="language-c++ highlighter-rouge"><span class="o">=</span><span class="n">r</span></code>，其中<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>表示<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>是输出操作数，<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>表示需要将<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>本身，当然指令执行完后需要将寄存器中的值存入变量<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>，从表面上看好像是指令直接对<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。<code class="language-c++ highlighter-rouge"><span class="n">input</span></code>前面的<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。</p>
  </li>
  <li>C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的汇编代码将会有错，读者可以将上例中的两个<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>，都改为<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>(<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">movl</span> <span class="n">input</span><span class="p">,</span> <span class="n">result</span>
</code></pre>
    </div>
    <p>很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令<code class="language-c++ highlighter-rouge"><span class="n">movl</span></code>允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>作为限定字符。</p>
  </li>
  <li>内嵌汇编语法如下：<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span><span class="p">(</span></code>汇编语句模板<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>输出部分<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>输入部分<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>破坏描述部分<code class="language-c++ highlighter-rouge"><span class="p">)</span></code>
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用<code class="language-c++ highlighter-rouge"><span class="o">:</span></code>格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用<code class="language-c++ highlighter-rouge"><span class="o">:</span></code>格开，相应部分内容为空。例如：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">"cli"</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">"memory"</span><span class="p">)</span>
</code></pre>
    </div>
  </li>
  <li>语法细节
    <ul>
      <li>汇编语句模板：汇编语句模板由汇编语句序列组成，语句之间使用<code class="language-c++ highlighter-rouge"><span class="p">;</span></code>、<code class="language-c++ highlighter-rouge"><span class="err">\</span><span class="n">n</span></code>或<code class="language-c++ highlighter-rouge"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span></code>分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，…，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>。指令中使用占位符表示的操作数，总被视为<code class="language-c++ highlighter-rouge"><span class="kt">long</span></code>型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在<code class="language-c++ highlighter-rouge"><span class="o">%</span></code>和序号之间插入一个字母，<code class="language-c++ highlighter-rouge"><span class="n">b</span></code>代表低字节，<code class="language-c++ highlighter-rouge"><span class="n">h</span></code>代表高字节，例如：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">h1</span></code>。</li>
      <li>输出部分：输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C语言变量组成。每个输出操作数的限定字符串必须包含<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>表示他是一个输出操作数。例如：
        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">"pushfl ; popl %0 ; cli"</span><span class="o">:</span><span class="s">"=g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</code></pre>
        </div>
        <p>描述符字符串表示对该变量的限制条件，这样GCC就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。</p>
      </li>
      <li>输入部分：输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。示例如下:
        <ul>
          <li>例1：<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">"lidt %0"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">real_mode_idt</span><span class="p">))</span></code>;</li>
          <li>例2：
            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__asm__</span><span class="p">(</span><span class="s">"btsl %1,%0"</span><span class="o">:</span><span class="s">"=m"</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="o">:</span><span class="s">"Ir"</span> <span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
            </div>
            <p>后例功能是将<code class="language-c++ highlighter-rouge"><span class="o">*</span><span class="n">addr</span></code>的第<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>位设为1。第一个占位符<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>与C语言变量<code class="language-c++ highlighter-rouge"><span class="n">ADDR</span></code>对应，第二个占位符<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>与C语言变量<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>对应。因此上面的汇编语句代码与下面的伪代码等价：<code class="language-c++ highlighter-rouge"><span class="n">btsl</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ADDR</span></code>，该指令的两个操作数不能全是内存变量，因此将<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>的限定字符串指定为<code class="language-c++ highlighter-rouge"><span class="n">Ir</span></code>，将<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>与立即数或者寄存器相关联，这样两个操作数中只有<code class="language-c++ highlighter-rouge"><span class="n">ADDR</span></code>为内存变量。</p>
          </li>
        </ul>
      </li>
      <li>限制字符：限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指令操作数之间的关系。限定符分类如下：
        <ul>
          <li>通用寄存器
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">a</span></code> 将输入变量放入eax</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">b</span></code> 将输入变量放入ebx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">c</span></code> 将输入变量放入ecx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">d</span></code> 将输入变量放入edx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">s</span></code> 将输入变量放入esi</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">d</span></code> 将输入变量放入edi</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">q</span></code> 将输入变量放入eax，ebx，ecx，edx中的一个</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">r</span></code> 将输入变量放入通用寄存器，即eax，ebx，ecx，edx，esi，edi之一</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">A</span></code> 把eax和edx合成一个64位的寄存器(use <code class="language-c++ highlighter-rouge"><span class="kt">long</span> <span class="kt">long</span></code>s)</li>
            </ul>
          </li>
          <li>内存
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">m</span></code> 内存变量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">o</span></code> 操作数为内存变量，但其寻址方式是偏移量类型，也即基址寻址</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">V</span></code> 操作数为内存变量，但寻址方式不是偏移量类型</li>
              <li><code class="language-c++ highlighter-rouge"><span class="p">,</span></code> 操作数为内存变量，但寻址方式为自动增量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">p</span></code> 操作数是一个合法的内存地址（指针）</li>
            </ul>
          </li>
          <li>寄存器或内存
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">g</span></code> 将输入变量放入eax，ebx，ecx，edx之一，或作为内存变量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">X</span></code> 操作数可以是任何类型</li>
            </ul>
          </li>
          <li>立即数
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">I</span></code> 0-31之间的立即数（用于32位移位指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">J</span></code> 0-63之间的立即数（用于64位移位指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">N</span></code> 0-255之间的立即数（用于<code class="language-c++ highlighter-rouge"><span class="n">out</span></code>指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">i</span></code> 立即数</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">n</span></code> 立即数，有些系统不支持除字以外的立即数，则应使用<code class="language-c++ highlighter-rouge"><span class="n">n</span></code>而非 <code class="language-c++ highlighter-rouge"><span class="n">i</span></code></li>
            </ul>
          </li>
          <li>匹配
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="mi">0</span></code> 表示用它限制的操作数与某个指定的操作数匹配</li>
              <li><code class="language-c++ highlighter-rouge"><span class="mi">1</span></code> …<code class="language-c++ highlighter-rouge"><span class="mi">9</span></code> 也即该操作数就是指定的那个操作数，例如<code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>去描述<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>操作数，那么<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>引用的其实就是<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>操作数，注意作为限定符字母的0－9与指令中的<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>－<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>的区别，前者描述操作数，后者代表操作数。</li>
              <li>&amp; 该输出操作数不能使用过和输入操作数相同的寄存器操作数类型</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">=</span></code> 操作数在指令中是只写的（输出操作数）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">+</span></code> 操作数在指令中是读写类型的（输入输出操作数）</li>
            </ul>
          </li>
          <li>浮点数
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">f</span></code> 浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">t</span></code> 第一个浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">u</span></code> 第二个浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">G</span></code> 标准的80387浮点常数</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">%</span></code> 该操作数可以和下一个操作数交换位置，例如<code class="language-c++ highlighter-rouge"><span class="n">addl</span></code>的两个操作数可以交换顺序（当然两个操作数都不能是立即数）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="cp">#</span></code> 部分注释，从该字符到其后的逗号之间所有字母被忽略</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">*</span></code> 表示如果选用寄存器，则其后的字母被忽略</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>破坏描述部分：破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有<code class="language-c++ highlighter-rouge"><span class="n">memory</span></code>。例如：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">eax</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">ebx</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">memory</span></code>等。</li>
    </ul>
  </li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《程序员的自我修养》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/programmer-self-cultivation-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/programmer-self-cultivation-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>参考文献
    <ul>
      <li>Linux内核源代码情景分析</li>
      <li>深入理解Windows操作系统 - Microsoft Windows Server 2003/Windows XP/Wincows 2000技术内幕</li>
      <li><span style="color: red">此书一共三卷，这是第一卷，还有两卷呢？？</span></li>
    </ul>
  </li>
  <li>singleton的实现：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">singleton_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p>实际上是不安全的，因为语句<code class="language-c++ highlighter-rouge"><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span></code>分三步：第一步分配内存，第二步在分配的内存上构造T，第三步把内存指针赋值给singleton_ptr。其中第二步和第三步可能被cpu乱序执行调换顺序，因为它们之间没有依赖。这样如果第三步先执行，另一线程并发访问，就会发现singleton_ptr被赋值了但是内容还没被构造。</p>
  </li>
  <li>linux的clone函数</li>
  <li>三种线程模型（“对”表示用户线程和内核线程的映射情况）：
    <ul>
      <li>1对1：缺点是OS限制了内核线程数量从而导致用户线程数量受限，而且线程切换开销较大</li>
      <li>多对1：一个用户线程阻塞将导致所有线程阻塞，增加cpu个数也不管用</li>
      <li>多对多：在多处理器系统上多对多模型的性能提升幅度不如一对一模型高</li>
    </ul>
  </li>
  <li>汇编器as，链接器ld</li>
  <li>词法分析器lex，语法分析器yacc</li>
  <li>链接过程主要包括：地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）</li>
  <li>文件类型p57
    <ul>
      <li>可重定位文件：windows的.obj和linux的.o</li>
      <li>动态链接库：windows的.dll和linux的.so</li>
      <li>静态链接库：windows的.lib和linux的.a</li>
      <li>可执行文件</li>
      <li>核心转储文件：linux的core dump</li>
    </ul>
  </li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《代码优化：有效使用内存》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/code-optimization-effective-memory-usage-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/code-optimization-effective-memory-usage-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>Intel的VTune性能分析器提供了行级的代码profiling</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Buffer Overflow Attacks》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/buffer-overflow-attacks-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/buffer-overflow-attacks-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>exploit是一种程序，通过该程序可以触发软件的一个漏洞并为攻击者使用</li>
  <li>第一章资源
    <ul>
      <li><a href="http://www.securiteam.com">http://www.securiteam.com</a></li>
      <li><a href="http://www.ngssoftware.com">http://www.ngssoftware.com</a></li>
      <li><a href="http://www.foundstone.com">http://www.foundstone.com</a></li>
      <li><a href="http://www.atstake.com">http://www.atstake.com</a></li>
      <li><a href="http://www.vulnerability.org">http://www.vulnerability.org</a></li>
      <li><a href="http://www.ntbugtraq.com">http://www.ntbugtraq.com</a></li>
      <li><a href="http://www.first.org">http://www.first.org</a></li>
    </ul>
  </li>
  <li>第二章资源
    <ul>
      <li><a href="http://www.applicationdefense.com">http://www.applicationdefense.com</a></li>
      <li><a href="http://www.shellcode.com.ar">http://www.shellcode.com.ar</a></li>
      <li><a href="http://www.enderunix.org/docs/en/sc-en.txt">http://www.enderunix.org/docs/en/sc-en.txt</a></li>
      <li><a href="http://www.metasploit.com/shellcode.html">http://www.metasploit.com/shellcode.html</a></li>
      <li><a href="http://www.SecurityFocus.com">http://www.SecurityFocus.com</a></li>
    </ul>
  </li>
  <li>其他网上资源
    <ul>
      <li><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a>包含常见os在常见processor上的常用shellcode</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Unix/Linux编程实践教程》读书笔记</title>
      <link>http://localhost:4001/2017/07/13/understanding-unix-linux-rogramming-notes/</link>
      <pubDate>2017-07-13T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/13/understanding-unix-linux-rogramming-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>1.6 向/dev/tty写即写向当前活动控制台，读则从键盘读入</li>
  <li>2.4 用man的-k选项可以搜索联机帮助</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《深入Linux内核架构》读书笔记</title>
      <link>http://localhost:4001/2017/07/13/professional-linux-kernel-architecture-notes/</link>
      <pubDate>2017-07-13T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/13/professional-linux-kernel-architecture-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第一章</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第二章</a></li>
  <li><a href="#b" id="markdown-toc-b">附录B</a></li>
  <li><a href="#c" id="markdown-toc-c">附录C</a></li>
</ul>

<h2 id="section">第一章</h2>

<ul>
  <li>pstree命令</li>
</ul>

<h2 id="section-1">第二章</h2>

<ul>
  <li>task_struct图解及其管理：参考<a href="http://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux内核进程管理之进程ID</a></li>
</ul>

<h2 id="b">附录B</h2>

<ul>
  <li>LXR工具：分析内核源代码并生成一个html超文本表示，带交叉引用</li>
  <li>DDD：GDB的图形化工具</li>
  <li>KGDB：可以远程调试运行中的内核</li>
  <li>UML：用户模式内核，运行于另一个（运行于真正硬件的）内核的用户空间上</li>
</ul>

<h2 id="c">附录C</h2>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
