<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4000/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2016-11-10T15:32:09-08:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>Jekyll and git resources</title>
      <link>http://localhost:4000/2016/11/welcome-to-jekyll/</link>
      <pubDate>2016-11-07T21:52:37-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/welcome-to-jekyll</guid>
      <content:encoded><![CDATA[<ol>
  <li>how to use git commands:
http://marklodato.github.io/visual-git-guide/index-zh-cn.html</li>
</ol>

<h1 id="how-to-1">1. how to 1</h1>
<h2 id="how-to-2">2. how to 2</h2>
<h3 id="how-to-3">3. how to 3</h3>

<p><img src="http://localhost:4000/assets/head-first-design-pattern-notes2.strategy.png" alt="My helpful screenshot" /></p>

<script type="math/tex; mode=display">a^2 + b^2 = c^2</script>

<p>\[ \mathbf{X} = \mathbf{Z} \mathbf{P^\mathsf{T}} \]</p>

<p>If you want to use subscripts you <strong>don't</strong> need to scape the
underscores with a backslash like:</p>

<script type="math/tex; mode=display">\mathbf{X}_{n,p} = \mathbf{A}_{n,k} \mathbf{B}\_{k,p}</script>

<p>You’ll find this post in your <code class="highlighter-rouge">_posts</code> directory. Go ahead and edit it and
re-build the site to see your changes. You can rebuild the site in many
different ways, but the most common way is to run <code class="highlighter-rouge">jekyll serve</code>, which launches
a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code class="highlighter-rouge">_posts</code> directory that follows the
convention <code class="highlighter-rouge">YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front
matter. Take a look at the source for this post to get an idea about how it
works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="http://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most
out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub
repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll
Talk</a>.</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>拜占庭将军问题</title>
      <link>http://localhost:4000/2014/03/byzantine-general-problem/</link>
      <pubDate>2014-03-08T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2014/03/byzantine-general-problem</guid>
      <content:encoded><![CDATA[<p>工作之余，花了一周的几乎每个晚上把Lamport神的那篇有关拜占庭将军问题的文章看完了。在这里做下笔记。</p>

<p>个人觉得最难懂的就是OM算法，我将它理解成一个动态规划：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// @c is the commander id;
// @l is one of the lieutenant id, which belongs to the current lieutenant set;
// @m is the parameter m mentioned in the paper;
// OM(c, l, m) means the final value lieutenant @l obeys from commander @c.

- if m = 0:
OM(c, l, m) = msg(c-&gt;l), where l in set{lieutenant};

- if m &gt; 0:
OM(c, l, m) = majority(
  msg(c-&gt;l),
  the list of OM(l', l, m-1) where l' in (set{lieutenant} - {l})
).  // majority
</code></pre>
</div>

<p>实际上，准确来说上面的状态表示是不完全的，OM的第一个参数应该是一个commander的id列表，表示从算法开始的第一个commander通过发消息沿途产生的所有commander。这样说起来还是很抽象，具体还是看下文代码吧。</p>

<p>为了让自己有更深的理解，我用C++实现了一个模拟器，输入general的个数，指定commander是否loyal，模拟算法运行，打印出每条消息以及消息路径，最后得出每个忠诚的lieutenant遵守的命令。目测+用小数据测试没有发现错误，也贴在这里供以后回顾使用。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208</pre></td><td class="code"><pre><span class="cp">#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
</span> 
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">num_generals</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">commander_is_loyal</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_loyal</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
 
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ValueType</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ValueType</span> <span class="n">kDefaultValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999999999</span><span class="p">;</span>
 
<span class="c1">// Classic algorithm to find the majority: maintain a value and
// a counter, when see a same value, ++counter; otherwise, if
// counter is 0, set the value to the one we see and let counter=1,
// or if counter&gt;0, --counter.
</span><span class="k">struct</span> <span class="n">MajorityCount</span> <span class="p">{</span>
  <span class="n">ValueType</span> <span class="n">majority</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">seen</span><span class="p">;</span>
 
  <span class="n">MajorityCount</span><span class="p">()</span> <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">kDefaultValue</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">MajorityCount</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
 
  <span class="n">MajorityCount</span><span class="o">&amp;</span> <span class="n">Merge</span><span class="p">(</span><span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">seen</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">majority</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">majority</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">": val="</span> <span class="o">&lt;&lt;</span> <span class="n">majority</span>
         <span class="o">&lt;&lt;</span> <span class="s">", cnt="</span> <span class="o">&lt;&lt;</span> <span class="n">count</span>
         <span class="o">&lt;&lt;</span> <span class="s">", seen="</span> <span class="o">&lt;&lt;</span> <span class="n">seen</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">MajorityCount</span><span class="o">&gt;</span> <span class="n">MapType</span><span class="p">;</span>
<span class="n">MapType</span> <span class="n">val_storage</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="nf">RandomShuffle</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">begin</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Itoa</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">res</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sprintf</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Join</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">delim</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Itoa</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ValueType</span> <span class="nf">RandomValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// return std::rand() % 97;
</span>  <span class="k">return</span> <span class="mi">250</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">// Updates the value of OM(c, l, m) using OM(l', l, m-1).
</span><span class="kt">void</span> <span class="nf">MergeUp</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key_vec</span> <span class="o">=</span> <span class="n">passed_ids</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">back</span> <span class="o">=</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">string</span> <span class="n">src_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">required_num_seen</span> <span class="o">=</span> <span class="n">remaining_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
 
  <span class="k">while</span> <span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dst_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
 
    <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">[</span><span class="n">dst_key</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span><span class="n">val_storage</span><span class="p">[</span><span class="n">src_key</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">back</span><span class="p">])</span> <span class="n">mc</span><span class="p">.</span><span class="n">majority</span> <span class="o">=</span> <span class="n">RandomValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">seen</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"    "</span> <span class="o">&lt;&lt;</span> <span class="n">src_key</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">dst_key</span><span class="p">;</span>
    <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">src_key</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">==</span> <span class="n">required_num_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src_key</span> <span class="o">=</span> <span class="n">dst_key</span><span class="p">;</span>
      <span class="o">++</span><span class="n">required_num_seen</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// Sequential algorithm: for simplicity, assume that each lieutenant
// will send messages to others when needed.
</span><span class="kt">void</span> <span class="nf">OM</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">commander_id</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ValueType</span> <span class="o">&amp;</span><span class="n">received_val</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span>  <span class="c1">// the last one is commander_id.
</span>        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// {1, 2, ..., n-1} - passed_ids
</span>  <span class="k">const</span> <span class="n">string</span> <span class="n">prefix_path</span> <span class="o">=</span>
      <span class="n">Join</span><span class="p">(</span><span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids_copy</span><span class="p">(</span><span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
      <span class="n">ValueType</span> <span class="n">val_to_send</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">commander_id</span><span class="p">]</span> <span class="o">?</span> <span class="n">received_val</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">());</span>
 
      <span class="c1">// OM(m), step (1)
</span>      <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="n">prefix_path</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">Itoa</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span>
        <span class="n">val_storage</span><span class="p">[</span><span class="n">path</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span>
            <span class="n">MajorityCount</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">val_to_send</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">;</span>
      <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
      <span class="c1">// OM(m), step (2)
</span>      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">seen</span> <span class="o">==</span> <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">OM</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val_to_send</span><span class="p">,</span> <span class="n">passed_ids</span><span class="p">,</span> <span class="n">remaining_ids</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+++++++++++++++++++++++++++++++++"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">,</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"num_generals: "</span><span class="p">,</span>
         <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num_generals</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m: "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"commander_is_loyal? "</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">commander_is_loyal</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">RandomShuffle</span><span class="p">(</span><span class="n">is_loyal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">passed_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_generals</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">remaining_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="c1">// commander_id=0, received_val=618
</span>    <span class="n">OM</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">618</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">);</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（下）- 设计模式</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes2/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes2</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">策略模式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">观察者模式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">装饰者模式</a></li>
  <li><a href="#factory-method-pattern" id="markdown-toc-factory-method-pattern">工厂方法模式（Factory Method Pattern）</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">抽象工厂模式</a></li>
  <li><a href="#singleton-pattern" id="markdown-toc-singleton-pattern">单件模式（Singleton Pattern）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">命令模式（封装调用）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">适配器模式</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">外观模式</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">模板方法模式</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">迭代器模式</a></li>
  <li><a href="#section-9" id="markdown-toc-section-9">组合模式</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">状态模式</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">代理模式</a></li>
  <li><a href="#mvc--" id="markdown-toc-mvc--">MVC：模型-视图-控制器</a></li>
  <li><a href="#section-12" id="markdown-toc-section-12">模式分类</a></li>
</ol>

<h2 id="section">策略模式</h2>

<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.strategy.png" alt="strategy" /></p>

<h2 id="section-1">观察者模式</h2>

<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。以下是Java的观察者模式：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.observers.png" alt="observers" /></p>

<ol>
  <li>出版者+订阅者=观察者模式</li>
  <li>不要依赖于观察者被通知的次序，因为一旦观察者/可观察者的实现有所改变，通知次序就会改变，很可能就会产生错误的结果，这绝对不是我们认为的松耦合</li>
  <li>java.util.Observale的黑暗面：Observable是一个类，如果某类想同时具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承，这限制了Observable的复用潜力；另外，Observable将关键方法（setChanged()）保护起来，这个设计违反了设计原则：多用组合，少用继承。</li>
</ol>

<h2 id="section-2">装饰者模式</h2>

<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.decorator.png" alt="decorator" /></p>

<ol>
  <li>如上述类图关系，重点在于，装饰者和被装饰者必须是一样的类型，也就是有同样的超类，这相当关键。在这里，我们利用继承达到“类型匹配”而不是获得“行为”。</li>
  <li>为何装饰者和被装饰者有相同的接口：因为装饰者必须能取代被装饰者。</li>
  <li>通常装饰者模式是采用抽象类，但是在Java中可以使用接口</li>
</ol>

<h2 id="factory-method-pattern">工厂方法模式（Factory Method Pattern）</h2>

<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类，通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>

<p>工厂模式具有平行的类层级：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.factory.png" alt="factory" /></p>

<ol>
  <li>当可能有许多客户程序通过各种方法来创建一个类型的新对象时，可以考虑到把创建这个对象的方法放到一个工厂中去，即使用工厂模式。所有工厂模式都用来封装对象的创建。</li>
  <li>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。工厂方法不一定要真的放到一个非本类的“工厂类”中。</li>
  <li>使用“工厂”意味着客户在实例化对象时，只会依赖于接口而不是具体类。这符合依赖倒置原则。</li>
</ol>

<h2 id="section-3">抽象工厂模式</h2>

<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.abstract-factory.png" alt="abstract-factory" /></p>

<ol>
  <li>抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法</li>
  <li>抽象工厂和工厂方法都是负责创建对象，工厂方法用的方法是继承，抽象工厂是通过对象的组合</li>
  <li>当需要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂；而工厂方法可以把客户代码从需要实例化的具体类中解耦，或如果目前还不知道将来需要实例化哪些具体类时，也可以用工厂方法。</li>
  <li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
</ol>

<h2 id="singleton-pattern">单件模式（Singleton Pattern）</h2>

<p>单件模式用来创建独一无二的、只能有一个实例的对象。</p>

<ol>
  <li>实现方法：若将对象赋值给一个全局变量，那么必须在程序一开始就创建好对象。万一这个对象非常耗资源，而程序在这次执行过程中又一直没用到它，就会形成浪费。</li>
  <li>单件模式实现中处理多线程问题的方法：</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span><span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>使用synchronized关键字可能会导致效率严重下降。而volatile关键字定义的成员变量确保在同一时间最多只有一个线程对其进行访问，尤其是32位系统处理64位变量时。另外，也可以使用“急切”创建实例而不用延迟实例，在静态初始化器（static initializer）中创建单位：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span></code></pre></figure>

<p>但这样会导致1中提到的问题。</p>

<h2 id="section-4">命令模式（封装调用）</h2>

<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.command.png" alt="command" /></p>

<ol>
  <li>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式</li>
  <li>宏命令模式：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.macro-command.png" alt="macro-command" /></p>

<h2 id="section-5">适配器模式</h2>

<p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.adapter.png" alt="adapter" /></p>

<h2 id="section-6">外观模式</h2>

<p>外观模式改变接口，将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观，让接口更简单。</p>

<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>

<h2 id="section-7">模板方法模式</h2>

<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>

<ol>
  <li>模板方法不一定要使用继承，例如c++的stl的排序方法使用的比较函数</li>
  <li>常见形式：
    <ul>
      <li>抽象方法：当子类必须提供算法中某个步骤的实现时使用</li>
      <li>钩子：当算法某个部分可选时使用</li>
    </ul>
  </li>
  <li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final</li>
</ol>

<h2 id="section-8">迭代器模式</h2>

<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.iterator.png" alt="iterator" /></p>

<h2 id="section-9">组合模式</h2>

<p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.composite.png" alt="composite" /></p>

<p>组合模式是让一个类有两个责任的模式，它不但要管理层次结构，而且还要执行菜单的操作。但组合模式以单一责任设计原则换取透明性（transparency）：通过让组件的接口同事包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁，这是一个很典型的折中案例。</p>

<h2 id="section-10">状态模式</h2>

<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.state.png" alt="state" /></p>

<p>上述ConcreteStateA和ConcreteStateB对Context的引用并不是必须的。有时Context本身也可以决定状态转换的流向。当状态转换是固定时（例如做了某个动作后就一定转换到某特定状态），就适合放在Context中。当转换更动态的时候，通常就会放在状态类中。做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭。</p>

<p>多个Context实例可共享状态对象（使用静态变量）。若状态需要利用Context中的方法，还必须在每个handler()方法内传入一个Context引用。</p>

<h2 id="section-11">代理模式</h2>

<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.proxy.png" alt="proxy" /></p>

<ol>
  <li>几种代理模式：
    <ul>
      <li>远程代理：控制访问远程对象</li>
      <li>虚拟代理：控制访问创建开销大的资源</li>
      <li>保护代理：基于权限控制对资源的访问</li>
      <li>防火墙代理（Firewall Proxy）</li>
      <li>智能引用代理（Smart Reference Proxy）</li>
      <li>缓存代理（Caching Proxy）</li>
      <li>同步代理（Synchronization Proxy）</li>
      <li>复杂隐藏代理（Complexity Hiding Proxy）</li>
      <li>写入时复制代理（Copy-On-Write Proxy）</li>
    </ul>
  </li>
  <li>Java RMI（远程过程调用）
    <ul>
      <li>java.rmi.Remote</li>
      <li>stub、skeleton</li>
      <li>rmic、rmiregistry工具</li>
      <li>transient关键字：告诉Java不要序列化一个对象</li>
    </ul>
  </li>
  <li>Java的动态代理技术：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.java-dynamic-proxy.png" alt="java-dynamic-proxy" /></p>

<h2 id="mvc--">MVC：模型-视图-控制器</h2>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc.png" alt="mvc" /></p>

<p>图解：</p>

<ol>
  <li>策略模式：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略</li>
  <li>视图用组合模式组织各窗口、面板、按钮等</li>
  <li>模型实现了观察者模式，当状态改变时通知对象更新。这使得同一模型可以使用不同的视图甚至可使用多个视图</li>
  <li>不同接口的模型常常通过适配器模式复用同一个视图</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc-web.png" alt="mvc-web" /></p>

<p>上图是Web中的MVC，称为Model 2（Servlet+JSP）。</p>

<p>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p>

<h2 id="section-12">模式分类</h2>

<p>模式是在某情景下，针对某问题的某种解决方案。模式可分为以下几类：</p>

<ul>
  <li>创建型：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。包括：Singleton、Builder、Prototype、Abstract Factory、Factory Method</li>
  <li>行为型：设计到类和对象如何交互及分配的职责。包括：Template Method、Visitor、Mediator、Iterator、Command、Memento、Interpreter、Observer、Chain of Responsibility、State、Strategy</li>
  <li>结构型：可让你把类或对象组合到更大的结构中。包括：Decorator、Proxy、Composite、Façade、Flyweight、Bridge、Adapter</li>
</ul>

<p>反模式告诉你如何采用一个不好的解决方案解决一个问题，告诉你为何这个方案从长远看会造成不好的影响，警告你不要陷入某种致命的诱惑，建议你改用其他的模式以提供更好的解决方案。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（上）- 设计原则</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes1/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes1</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">封装变化</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">针对接口编程，而不是针对实现编程</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">多用组合，少用继承</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">为了交互对象之间的松耦合设计而努力</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">类应该对扩展开放，对修改关闭</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">要依赖抽象，不要依赖具体类</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">最小知识原则</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">好莱坞原则</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">应尽量让每个类保持单一责任</a></li>
</ol>

<h2 id="section">封装变化</h2>

<p>找出应用中可能需要变化之处，把它们独立出来（并封装起来），不要和那些不要变化的代码混在一起。</p>

<p>如果每次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分</p>

<h2 id="section-1">针对接口编程，而不是针对实现编程</h2>

<p>以前的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于“实现”，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p>

<p>“针对接口编程”真正的意思是“针对超类型（supertype）编程”，货可以更明确地说成“变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口”。</p>

<h2 id="section-2">多用组合，少用继承</h2>

<p>良好的OO设计必须具备可复用、可扩充、可维护三个特性。大多数的模式都允许系统局部改变独立于其他部分</p>

<h2 id="section-3">为了交互对象之间的松耦合设计而努力</h2>

<h2 id="section-4">类应该对扩展开放，对修改关闭</h2>

<h2 id="section-5">要依赖抽象，不要依赖具体类</h2>

<p>依赖倒置原则（Dependency Inversion Principle）：不能让高层组件依赖低层组件，而且，不管高层或低层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。</p>

<p>一下指导方针能帮助避免在OO设计中违反依赖倒置原则：</p>

<ol>
  <li>变量不可以持有具体类的引用</li>
  <li>不要让类派生自具体类</li>
  <li>不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</li>
</ol>

<h2 id="section-6">最小知识原则</h2>

<p>减少对象之间的交互，不要让太多的类耦合在一起。</p>

<p>指导方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>

<ol>
  <li>该对象本身</li>
  <li>被当做方法的参数而传进来的对象</li>
  <li>此方法所创建或实例化的任何对象</li>
  <li>对象的任何组件（Has-A）</li>
</ol>

<p>注意，如果某对象是调用其他方法的返回结果，不要调用该对象的方法！</p>

<h2 id="section-7">好莱坞原则</h2>

<p>别调用（打电话给）我们，我们会调用（打电话给）你（将决策权放在高层模块中）。</p>

<p>例如模板方法模式中，低层组件绝对不可以直接调用高层组件。</p>

<h2 id="section-8">应尽量让每个类保持单一责任</h2>

<p>因为一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域。如果一个类具有两个改变的原则，那么这会使得将来该类变化的几率上升；而当它真的改变时，你的设计中同时有两个方面将受到影响。</p>

<p>术语：</p>
<ul>
  <li>内聚（cohesion）：用来度量一个类或模块紧密地达到单一目的或责任</li>
  <li>高内聚：一个模块/类被设计成只支持一组相关功能</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
