<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4001/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2017-07-23T17:04:08-07:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>《新概念物理教程》读书笔记</title>
      <link>http://localhost:4001/2017/07/23/new-concept-physics-notes/</link>
      <pubDate>2017-07-23T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/23/new-concept-physics-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">力学</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">第一章 质点运动学</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">第二章 动量守恒 质点动力学</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">力学</h2>

<h3 id="section-1">第一章 质点运动学</h3>

<ul>
  <li>视差：观测者在两个不同位置看到同一天体的方向之差</li>
  <li>基线：两个不同位置之间的联线</li>
  <li>AU：地球公转轨道的半径=1AU</li>
  <li>角秒：符号为<code class="language-c++ highlighter-rouge"><span class="s">"</span></code>，数量上等于$\pi/648000$（弧度制）</li>
  <li>秒差距（parsec，単位符号为pc）：选地球公转轨道半径为基线，视差等于1角秒的距离，叫做1秒差距，值为3.261633光年</li>
  <li>通过加速度（矢量）的定义（即$\Delta t$趋于0时速度矢量的变化）以及平面几何相似三角形的关系可以求得匀速圆周运动的加速度大小为$\frac{v^2}{R}$而方向垂直于运动物体的速度方向并指向圆心</li>
  <li>变速圆周运动和匀速圆周运动加速度的唯一不同在于切向加速度分量不为0</li>
  <li>一般曲线运动某点的加速度可以通过曲率半径和变速圆周运动联系起来求解</li>
  <li>反之，曲线运动中若知道某点的加速度，就可以求出该点的曲率半径</li>
  <li>圆周运动的叠加可以通过相对运动的经典力学法则（非相对论，即非洛伦兹变换）来理解</li>
</ul>

<h3 id="section-2">第二章 动量守恒 质点动力学</h3>

<ul>
  <li><strong>实验表明</strong>，在一个参考系中，只要某个物体符合惯性定律，则其他物体都服从惯性定律</li>
  <li>因此定义：对某一特定物体惯性定律成立的参考系，为<strong>惯性参考系</strong>，简称惯性系。从这里初步可以看到，惯性不是个别物体的性质，而是参考系，或者说，时空的性质</li>
  <li>任何惯性参考系所描述的空间都是均匀各向同性的，它们具有平移对称性和转动对称性。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>底层并发控制机制</title>
      <link>http://localhost:4001/2017/07/23/low-level-concurrency-control/</link>
      <pubDate>2017-07-23T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/23/low-level-concurrency-control</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#spin-lock" id="markdown-toc-spin-lock">Spin Lock</a></li>
  <li><a href="#out-of-order-execution" id="markdown-toc-out-of-order-execution">乱序执行（out-of-order execution）和内存屏障</a></li>
  <li><a href="#volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97" id="markdown-toc-volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97"><a href="http://baiy.cn/doc/cpp/advanced_topic_about_multicore_and_threading.htm#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C_volatile_%E5%85%B3%E9%94%AE%E5%AD%97">原子操作和volatile关键字</a></a></li>
</ul>

<h2 id="spin-lock">Spin Lock</h2>

<ul>
  <li>spinlock<a href="http://imaupk.blog.163.com/blog/static/348222512008112655221557/">实现1</a>，结构体类似于：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">spinlock</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span>  <span class="c1">// Initialized to 0.
</span><span class="p">}</span> <span class="n">t</span><span class="p">;</span>
</code></pre>
    </div>
    <ul>
      <li>上锁：
        <ul>
          <li>先把处理器的flag寄存器存起来，然后关中断</li>
          <li>spin_lock函数：用lock前缀（锁总线？）做一个原子操作：把t.slock的最低位置1并返回原来的值。然后检查原来的值，如果是0，说明当前线程成功上锁，可以返回；否则，说明之前已被上锁，然后不断循环测试t.slock的最低位的值（忙等待），直到变为0（某其他线程释放了），再重新用lock前缀去做原子操作并重复执行上述步骤。</li>
        </ul>
      </li>
      <li>解锁：
        <ul>
          <li>spin_unlock函数：用lock前缀将t.slock最低位置0
            <blockquote class="lambda_question">
              <p>问：这里可以不用lock前缀吗？</p>
            </blockquote>
          </li>
          <li>开中断，恢复flag寄存器的值</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>当我们能保证即使发生中断、在中断程序中也不会修改critical section的数据时，可以直接使用实现1的spin_lock和spin_unlock函数而无需保存flag寄存器和关中断</li>
  <li>读写者spinlock：与实现1类似，只是除了用1个bit表示写者是否已经获得锁之外，用31个bit来表示当前读者的个数（这样写者很容易饿死吧？）</li>
  <li>spinlock<a href="http://blog.csdn.net/yeqishi/article/details/6570208">实现2</a>：结构体与实现1一样，下面叙述忽略保存flag寄存器和关中断等内容
    <ul>
      <li>上锁：用lock前缀调用decb汇编指令将t.slock的值减 1。然后用jns汇编指令检查EFLAGS寄存器的SF(符号)位，如果为 0，说明slock原来的值为1，则线程获得锁，然后结束本次函数调用；如果SF位为1，说明slock原来的值为0或负数，锁已被占用，那么线程开始不断测试t.slock与0的大小关系，直到t.slock大于0，说明锁已被释放，则跳转到开始位置重新申请锁，重复上述过程。</li>
      <li>解锁：把t.slock置为1（不用lock前缀）</li>
    </ul>
  </li>
  <li>兼顾公平：排队自旋锁
    <ul>
      <li>排队自旋锁仍然使用原有的数据结构，但是赋予slock域新的含义。为了保存顺序信息，slock 域被分成两部分，分别保存锁持有者和未来锁申请者的票据序号(Ticket Number)：如果处理器个数不超过 256，则 Owner 域为 slock 的 0-7 位，Next 域为 slock 的 8-15 位，slock 的高 16 位不使用；如果处理器个数超过 256，则 Owner 和 Next 域均为 16 位，其中 Owner 域为 slock 的低 16 位。可见排队自旋锁最多支持 2^16=65536 个处理器。</li>
      <li>只有 Next 域与 Owner 域相等时，才表明锁处于未使用状态（此时也无人申请该锁）。排队自旋锁初始化时 slock 被置为 0，即 Owner 和 Next 置为 0。内核执行线程申请自旋锁时，原子地将 Next 域加 1，并将原值返回作为自己的票据序号。如果返回的票据序号等于申请时的 Owner 值，说明自旋锁处于未使用状态，则直接获得锁；否则，该线程忙等待检查 Owner 域是否等于自己持有的票据序号，一旦相等，则表明锁轮到自己获取。线程释放锁时，原子地将 Owner 域加 1 即可，下一个线程将会发现这一变化，从忙等待状态中退出。线程将严格地按照申请顺序依次获取排队自旋锁，从而完全解决了“不公平”问题。</li>
    </ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/ABA_problem">ABA problem</a></li>
</ul>

<h2 id="out-of-order-execution">乱序执行（out-of-order execution）和内存屏障</h2>

<ul>
  <li>乱序执行实现了避免计算机在用于运算的对象不可获取时的大量等待。</li>
  <li>
    <p>乱序执行使用其他“可以执行”的指令来填补了时间的空隙，然后在在结束时重新排序运算结果来实现指令的顺序执行中的运行结果。指令在原始计算机代码中的顺序被称为程序顺序，在处理器中他们被按照数据顺序中被处理，这种顺序中，数据，运算符，在计算机寄存器中变得可以获取。一般来说乱序执行需要复杂的电路来实现转换一种顺序到另一中顺序并且维护在输出时的逻辑顺序；而处理器本身就好像是随机执行的样子。</p>
  </li>
  <li>内存一致性模型（<a href="http://www.cnblogs.com/haippy/p/3412858.html">参考这里</a>），以下讨论的写操作的order都是指针对不同内存位置的写，对同一内存位置的写必须是顺序一致的，否则程序正确性无法保证
    <ul>
      <li>顺序一致性（sequential consistency）模型：Lamport于1979：the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program。这要求同一处理器的所有操作（包括读和写）都是顺序执行的</li>
      <li>处理器一致性（processor consistency）模型：同一处理器中，所有读操作之间是sequential consistency的，任意写操作执行前所有先于（指program order）该写操作的所有访存操作（包括读和写）都已完成。该模型允许读操作被reorder至对另一位置的写之前。</li>
      <li>弱一致性（weak consistency）模型：把普通的读写访存操作和同步操作进行区分。所有同步操作之间是sequential consistency的，任一同步操作开始前所有先于该操作的普通访存操作都已完成，任一普通访存操作开始前所有先于该操作的同步操作都已完成。</li>
      <li>释放一致性（release consistency）模型：把同步操作进一步分为acquire和release操作。所有同步操作之间是sequential consistency的，任一release操作开始前所有先于该操作的普通访存操作都已完成，任一普通访存操作开始前所有先于该操作的acquire操作都已完成。</li>
    </ul>
  </li>
  <li>x86-64的内存模型：
    <ul>
      <li>Loads are not reordered with other loads.</li>
      <li>Stores are not reordered with other stores.</li>
      <li>Stores are not reordered with older loads.</li>
      <li><span style="color: blue">Loads may be reordered with older writes to different locations but not with older writes to the same location.</span></li>
      <li>In a multiprocessor system, memory ordering obeys causality （因果关系） (memory ordering respects transitive visibility).</li>
      <li>In a multiprocessor system, stores to the same location have a total order.</li>
      <li>In a multiprocessor system, locked instructions have a total order.</li>
      <li>Loads and stores are not reordered with locked instructions.</li>
    </ul>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">""</span> <span class="o">:::</span> <span class="s">"memory"</span><span class="p">);</span></code> creates a <span style="color: blue">compiler level</span> memory barrier forcing <span style="color: blue">optimizer</span> to not re-order memory accesses across the barrier.</li>
  <li>指令流水线（pipelining）：把一条指令分为取址、解码、执行、存储结果、结束等几个部分，连续的指令的不同部分并行执行，形成一个流水线</li>
  <li>lfence/sfence/mfence from intel manual section 8.2.2
    <ul>
      <li>Reads cannot pass earlier LFENCE and MFENCE instructions.</li>
      <li>Writes cannot pass earlier LFENCE, SFENCE, and MFENCE instructions.</li>
      <li>LFENCE instructions cannot pass earlier reads.</li>
      <li>SFENCE instructions cannot pass earlier writes.</li>
      <li>MFENCE instructions cannot pass earlier reads or writes.</li>
      <li>by i and iii, lfence enforces #LoadLoad ordering</li>
      <li>by ii and iii, lfence enforces #LoadStore ordering</li>
      <li>by ii and iv, sfence enforces #StoreStore ordering</li>
      <li>sfence not enforces #StoreLoad ordering</li>
    </ul>
  </li>
  <li>lock 前缀的访存指令相当于 Full Barrier，xchg 已隐式加 lock 前缀。</li>
  <li>具有acquire语义的内存屏障，保证其后的读写不会提前到屏障之前</li>
  <li>具有release语义的屏障，保证之前的读写已经生效/可见</li>
  <li>acquire和release这两种内存屏障都是单向的，即允许临界区外的读写进入到临界区内。具体到 X86-64 架构，考虑前面描述的内存模型，读操作就具有acquire语义（因为一个读操作其后的读写都不会被reorder到该读操作之前），而写操作具有release语义（因为一个写操作之前的读写都不会被reorder到该写操作之后）</li>
  <li><a href="https://en.wikipedia.org/wiki/MESI_protocol">MSEI protocol</a></li>
</ul>

<h2 id="volatilehttpbaiycndoccppadvancedtopicaboutmulticoreandthreadinghtme58e9fe5ad90e6938de4bd9ce5928cvolatilee585b3e994aee5ad97"><a href="http://baiy.cn/doc/cpp/advanced_topic_about_multicore_and_threading.htm#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C_volatile_%E5%85%B3%E9%94%AE%E5%AD%97">原子操作和volatile关键字</a></h2>

<ul>
  <li>C/C++ 中的volatile关键字提供了以下保证：
    <ul>
      <li>对声明为volatile的变量进行的任何操作都不会被优化器去除，即使它看起来没有意义（例如：连续多次对某个变量赋相同的值），因为它可能被某个在编译时未知的外部设备或线程访问。</li>
      <li>被声明为volatile的变量不会被编译器优化到寄存器中，每次读写操作都保证在内存(详见下文)中完成。</li>
      <li>在不同表达式内的多个volatile变量间的操作顺序不会被优化器调换（即：编译器保证多个volatile变量在 sequence point之间的访问顺序不会被优化和调整）。</li>
    </ul>
  </li>
  <li>volatile<span style="color: blue"><strong>不</strong></span>提供如下保证
    <ul>
      <li>volatile声明不保证读写和运算操作的原子性。</li>
      <li>volatile声明不保证对其进行的读写操作直接发生在主内存。相反，CPU 会尽可能让这些读写操作发生在 L1/L2 等cache上。除非：
        <ul>
          <li>发生了一个未命中的读请求。</li>
          <li>所有级别的cache均已被配置为通过式写（write through）。</li>
          <li>目标地址为 non-cacheable区（主要是其它设备映射到内存地址空间的通信接口。例如：网卡的板载缓冲区、显卡板载显存、WatchDog寄存器等等）。</li>
        </ul>
      </li>
      <li>编译器仅保证在生成目标码时不调整volatile变量的访问顺序，但通常并不保证该变量不受处理器的out-of-order特性影响。目前唯一一个已知的特例是安腾（IA64）处理器版的 VC：在生成 IA64 Target时，VC会自动在所有volatile访问之间添加内存屏障（详见下文）以保证访问顺序。但ISO标准并未要求编译器实现类似机制。实际上，其它编译器（或是面向其它平台的 VC）也都没有类似保证。也就是说，通常认为volatile并不保证代码在处理器上的执行顺序，如果需要类似的保证，程序员应当自己使用内存屏障操作。</li>
    </ul>
  </li>
  <li>而原子操作要求做到以下保证：
    <ul>
      <li>对原子量的 ‘读出-计算-写入’ 操作序列是原子的，在以上动作完成之前，任何其它处理器和线程均无法访问该原子量。</li>
      <li>原子操作必须保证缓存一致性。即：在多处理器环境中，原子操作要同时保持所有处理器上的各级cache之间、以及它们与主存间的访问一致性。</li>
    </ul>
  </li>
  <li>可见，使用volitale关键字并不足以保证操作的原子语义。volitale关键字的主要设计目的是支持C/C++程序与内存映射设备间的通信。但这并不是说volitale关键字对原子操作没有任何帮助：
    <ul>
      <li>对于一个被声明为volitale类型的原子量来说，如果所有写操作都是原子的，并且已提供了必要的cache一致性保证，那么读取该原子量时就不必再次对总线上锁。</li>
      <li>这是因为volitale关键字保证了对该变量的读操作起码是在当前 CPUcache中完成的（即：该变量不会被优化到寄存器中）。与此同时，只要当前环境能够保证多个处理器的cache之间，以及cache与主存之间的访问一致性。那么该读操作不管在主存还是当前系统中任意一个处理器的cache上发生，读到的都是一致的数据。</li>
      <li>在这里，volitale关键字配合原子量的写入操作一起实现了一个典型的读者/写者同步模型：所有写操作和cache同步都保证被原子、互斥地完成；读操作则可以被并发地实现。这也是 Windows API 中没有提供类似 ‘AtomicLoad’ 式语义操作的原因。</li>
      <li>当然，这里还有一个隐含的附加条件，就是 CPU 必须能够在一个操作中读入这个原子量。这个条件通常可以忽略，因为超出CPU位宽的数据类型通常无法被实现成真正的原子量类型。</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>互斥算法</title>
      <link>http://localhost:4001/2017/07/22/mutual-exclusion-algorithms/</link>
      <pubDate>2017-07-22T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/22/mutual-exclusion-algorithms</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#petersoncpu" id="markdown-toc-petersoncpu">Peterson算法（要注意CPU对内存访问顺序的优化改变）</a></li>
  <li><a href="#filtern2peterson" id="markdown-toc-filtern2peterson">Filter算法：N大于2时的Peterson算法</a></li>
  <li><a href="#deker" id="markdown-toc-deker">Deker算法</a></li>
  <li><a href="#lamport" id="markdown-toc-lamport">Lamport面包店算法</a></li>
  <li><a href="#eisenberg--mcguire-algorithm" id="markdown-toc-eisenberg--mcguire-algorithm">Eisenberg &amp; McGuire algorithm</a></li>
  <li><a href="#szymanski" id="markdown-toc-szymanski">Szymanski算法</a></li>
</ul>

<h2 id="petersoncpu">Peterson算法（要注意CPU对内存访问顺序的优化改变）</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P0:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P1:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="filtern2peterson">Filter算法：N大于2时的Peterson算法</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>  <span class="c1">// current level of processes 0...N-1
</span>
<span class="c1">// the waiting process of each level 0...N-2.
// 这是一个排队队列，任何时刻当所有进程在以下while忙等待稳定后或在临界区执行中
// 时（假设临界区足够长），不可能有两个或以上pending进程的level为同一个值
</span><span class="n">waiting</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>Code for process #i
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> 
  <span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
  <span class="n">waiting</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">waiting</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">there</span> <span class="n">exists</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">,</span> <span class="n">such</span> <span class="n">that</span> <span class="n">level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">));</span>  <span class="c1">// busy wait
</span><span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// exit section
</span></code></pre>
    </div>
  </li>
</ul>

<h2 id="deker">Deker算法</h2>

<ul>
  <li>Initialization
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// or 1. The init value determines the first
</span>           <span class="c1">// process to enter the critical section
</span></code></pre>
    </div>
  </li>
  <li>P0:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// busy wait
</span>    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>P1:
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// busy wait
</span>    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>  <span class="cm">/* critical section here */</span>
<span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ul>

<h2 id="lamport">Lamport面包店算法</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Declaration and initial values of global variables
</span><span class="nl">Entering:</span> <span class="n">array</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="n">of</span> <span class="kt">bool</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
<span class="n">Number</span><span class="o">:</span> <span class="n">array</span> <span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">NUM_THREADS</span><span class="p">]</span> <span class="n">of</span> <span class="n">integer</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="n">lock</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Entering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">Number</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">Number</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">]);</span>
  <span class="n">Entering</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Wait until thread j receives its number:
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">Entering</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="c1">// 上述这个while必不可少，否则在下面的&lt;判断中可能会有两个（或多个？）线程
</span>    <span class="c1">// 同时失效而同时进入critical section：考虑两个线程都把Number设为同一值但是
</span>    <span class="c1">// j&lt;i且i先到达此处的情况，这样j可能还未设置Number[j]，于是i将读到0，下面的
</span>    <span class="c1">// while失效而进入临界区；而当j进入时，下面的小于号判断失效，也进入临界区
</span>
    <span class="c1">// Wait until all threads with smaller numbers or with the same number,
</span>    <span class="c1">// but with higher priority, finish their work:
</span>    <span class="k">while</span> <span class="p">((</span><span class="n">Number</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">Number</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)));</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">unlock</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Thread</span><span class="p">(</span><span class="n">integer</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">...</span>  <span class="cm">/* critical section here */</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">...</span>  <span class="c1">// non-critical section
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="eisenberg--mcguire-algorithm">Eisenberg &amp; McGuire algorithm</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">pstate</span> <span class="o">=</span> <span class="p">{</span><span class="n">IDLE</span><span class="p">,</span> <span class="n">WAITING</span><span class="p">,</span> <span class="n">ACTIVE</span><span class="p">};</span>
<span class="n">pstate</span> <span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
<span class="c1">// The variable turn, is set arbitrarily to a number between 0 and n-1 at the
// start of the algorithm.
// The flags variable, for each process is set to WAITING whenever it intends to
// enter the critical section.
// flags takes either IDLE or WAITING or ACTIVE.
// Initially the flags variable for each process is initialized to IDLE.
</span><span class="n">repeat</span> <span class="p">{</span>
  <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">WAITING</span><span class="p">;</span>  <span class="cm">/* announce that we need the resource */</span>

  <span class="cm">/* scan processes from the one with the turn up to ourselves. */</span>
  <span class="cm">/* repeat if necessary until the scan finds all processes idle */</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IDLE</span><span class="p">)</span> <span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">index</span> <span class="o">:=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">ACTIVE</span><span class="p">;</span>  <span class="cm">/* now tentatively claim the resource */</span>

  <span class="cm">/* find the first active process besides ourselves, if any */</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ACTIVE</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">index</span> <span class="o">:=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// if there were no other active processes, AND if we have the turn or else
</span>  <span class="c1">// whoever has it is idle, then proceed.
</span>  <span class="c1">// Otherwise, repeat the whole sequence.
</span><span class="p">}</span> <span class="n">until</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">turn</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">turn</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">)));</span>

<span class="n">turn</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* claim the turn and proceed */</span>

<span class="cm">/* Critical Section Code of the Process */</span>

<span class="c1">// find a process which is not IDLE (if there are no others, we will find
// ourselves)
</span><span class="n">index</span> <span class="o">:=</span> <span class="n">turn</span><span class="o">+</span><span class="mi">1</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDLE</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">index</span> <span class="o">:=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">turn</span> <span class="o">:=</span> <span class="n">index</span><span class="p">;</span>  <span class="cm">/* give the turn to someone that needs it, or keep it */</span>
<span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">IDLE</span><span class="p">;</span>  <span class="cm">/* we're finished now */</span>
</code></pre>
</div>

<h2 id="szymanski">Szymanski算法</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 进入临界区的协议：
</span><span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1">// 站在入口门外，申请进入等候室
// 等待入口门打开。即不存在有进程处于3、4状态，包括正在进门、正在使用临界区
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
<span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// 站在入口门处，即正在进入。
</span><span class="k">if</span> <span class="n">any</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span>  <span class="c1">// 如果还有在入口门外等待进入的线程
</span>  <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// 把自己置为在入口门内，等待所有提出申请的线程都完成进入等候室
</span>  <span class="n">await_until</span><span class="p">(</span><span class="n">any</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">// 等待最后进门的线程关闭入口门
</span><span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1">// 门处于关闭状态，线程在等候室
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">self</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1">// 等待所有具有更高优先级的线程访问完临界区，退出等候室
</span>
<span class="c1">// 这里是临界区...
</span>
<span class="c1">// 退出临界区的协议
// 确保所有比自己优先级低的已经通过入口门的线程都进入了等候室
</span><span class="n">await_until</span><span class="p">(</span><span class="n">all</span> <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="o">+</span><span class="mf">1.</span><span class="p">.</span><span class="n">N</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
<span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">// 离开等候室，如果自己是最后离开的，则入口门被打开
</span></code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>GCC内嵌汇编笔记</title>
      <link>http://localhost:4001/2017/07/22/gcc-inline-assembly/</link>
      <pubDate>2017-07-22T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/22/gcc-inline-assembly</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">__asm__</span></code>表示后面的代码为内嵌汇编，<code class="language-c++ highlighter-rouge"><span class="k">asm</span></code>是<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span></code>的别名。<code class="language-c++ highlighter-rouge"><span class="n">__volatile__</span></code>表示编译器不要优化代码，后面的指令保留原样，<code class="language-c++ highlighter-rouge"><span class="k">volatile</span></code>是它的别名。括号里面是汇编指令。使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。示例：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__violate__</span> <span class="p">(</span><span class="s">"movl %1,%0"</span> <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">input</span><span class="p">));</span>
</code></pre>
    </div>
    <p>其中<code class="language-c++ highlighter-rouge"><span class="n">movl</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span><span class="o">%</span><span class="mi">0</span></code>是指令模板；<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">input</span></code>，他们按照出现的顺序分别与指令操作数<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>对应；注意对应顺序：第一个C表达式对应<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>；第二个表达式对应<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，依次类推，操作数至多有10个，分别用<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，…，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>表示。 在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>前面的限制字符串是<code class="language-c++ highlighter-rouge"><span class="o">=</span><span class="n">r</span></code>，其中<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>表示<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>是输出操作数，<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>表示需要将<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>本身，当然指令执行完后需要将寄存器中的值存入变量<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>，从表面上看好像是指令直接对<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。<code class="language-c++ highlighter-rouge"><span class="n">input</span></code>前面的<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。</p>
  </li>
  <li>C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的汇编代码将会有错，读者可以将上例中的两个<code class="language-c++ highlighter-rouge"><span class="n">r</span></code>，都改为<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>(<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">movl</span> <span class="n">input</span><span class="p">,</span> <span class="n">result</span>
</code></pre>
    </div>
    <p>很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令<code class="language-c++ highlighter-rouge"><span class="n">movl</span></code>允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用<code class="language-c++ highlighter-rouge"><span class="n">m</span></code>作为限定字符。</p>
  </li>
  <li>内嵌汇编语法如下：<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span><span class="p">(</span></code>汇编语句模板<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>输出部分<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>输入部分<code class="language-c++ highlighter-rouge"><span class="o">:</span> </code>破坏描述部分<code class="language-c++ highlighter-rouge"><span class="p">)</span></code>
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用<code class="language-c++ highlighter-rouge"><span class="o">:</span></code>格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用<code class="language-c++ highlighter-rouge"><span class="o">:</span></code>格开，相应部分内容为空。例如：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">"cli"</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">"memory"</span><span class="p">)</span>
</code></pre>
    </div>
  </li>
  <li>语法细节
    <ul>
      <li>汇编语句模板：汇编语句模板由汇编语句序列组成，语句之间使用<code class="language-c++ highlighter-rouge"><span class="p">;</span></code>、<code class="language-c++ highlighter-rouge"><span class="err">\</span><span class="n">n</span></code>或<code class="language-c++ highlighter-rouge"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span></code>分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>，…，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>。指令中使用占位符表示的操作数，总被视为<code class="language-c++ highlighter-rouge"><span class="kt">long</span></code>型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在<code class="language-c++ highlighter-rouge"><span class="o">%</span></code>和序号之间插入一个字母，<code class="language-c++ highlighter-rouge"><span class="n">b</span></code>代表低字节，<code class="language-c++ highlighter-rouge"><span class="n">h</span></code>代表高字节，例如：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">h1</span></code>。</li>
      <li>输出部分：输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C语言变量组成。每个输出操作数的限定字符串必须包含<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>表示他是一个输出操作数。例如：
        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">"pushfl ; popl %0 ; cli"</span><span class="o">:</span><span class="s">"=g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</code></pre>
        </div>
        <p>描述符字符串表示对该变量的限制条件，这样GCC就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。</p>
      </li>
      <li>输入部分：输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。示例如下:
        <ul>
          <li>例1：<code class="language-c++ highlighter-rouge"><span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">"lidt %0"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">real_mode_idt</span><span class="p">))</span></code>;</li>
          <li>例2：
            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__asm__</span><span class="p">(</span><span class="s">"btsl %1,%0"</span><span class="o">:</span><span class="s">"=m"</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="o">:</span><span class="s">"Ir"</span> <span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
            </div>
            <p>后例功能是将<code class="language-c++ highlighter-rouge"><span class="o">*</span><span class="n">addr</span></code>的第<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>位设为1。第一个占位符<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>与C语言变量<code class="language-c++ highlighter-rouge"><span class="n">ADDR</span></code>对应，第二个占位符<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>与C语言变量<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>对应。因此上面的汇编语句代码与下面的伪代码等价：<code class="language-c++ highlighter-rouge"><span class="n">btsl</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ADDR</span></code>，该指令的两个操作数不能全是内存变量，因此将<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>的限定字符串指定为<code class="language-c++ highlighter-rouge"><span class="n">Ir</span></code>，将<code class="language-c++ highlighter-rouge"><span class="n">nr</span></code>与立即数或者寄存器相关联，这样两个操作数中只有<code class="language-c++ highlighter-rouge"><span class="n">ADDR</span></code>为内存变量。</p>
          </li>
        </ul>
      </li>
      <li>限制字符：限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指令操作数之间的关系。限定符分类如下：
        <ul>
          <li>通用寄存器
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">a</span></code> 将输入变量放入eax</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">b</span></code> 将输入变量放入ebx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">c</span></code> 将输入变量放入ecx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">d</span></code> 将输入变量放入edx</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">s</span></code> 将输入变量放入esi</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">d</span></code> 将输入变量放入edi</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">q</span></code> 将输入变量放入eax，ebx，ecx，edx中的一个</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">r</span></code> 将输入变量放入通用寄存器，即eax，ebx，ecx，edx，esi，edi之一</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">A</span></code> 把eax和edx合成一个64位的寄存器(use <code class="language-c++ highlighter-rouge"><span class="kt">long</span> <span class="kt">long</span></code>s)</li>
            </ul>
          </li>
          <li>内存
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">m</span></code> 内存变量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">o</span></code> 操作数为内存变量，但其寻址方式是偏移量类型，也即基址寻址</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">V</span></code> 操作数为内存变量，但寻址方式不是偏移量类型</li>
              <li><code class="language-c++ highlighter-rouge"><span class="p">,</span></code> 操作数为内存变量，但寻址方式为自动增量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">p</span></code> 操作数是一个合法的内存地址（指针）</li>
            </ul>
          </li>
          <li>寄存器或内存
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">g</span></code> 将输入变量放入eax，ebx，ecx，edx之一，或作为内存变量</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">X</span></code> 操作数可以是任何类型</li>
            </ul>
          </li>
          <li>立即数
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">I</span></code> 0-31之间的立即数（用于32位移位指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">J</span></code> 0-63之间的立即数（用于64位移位指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">N</span></code> 0-255之间的立即数（用于<code class="language-c++ highlighter-rouge"><span class="n">out</span></code>指令）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">i</span></code> 立即数</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">n</span></code> 立即数，有些系统不支持除字以外的立即数，则应使用<code class="language-c++ highlighter-rouge"><span class="n">n</span></code>而非 <code class="language-c++ highlighter-rouge"><span class="n">i</span></code></li>
            </ul>
          </li>
          <li>匹配
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="mi">0</span></code> 表示用它限制的操作数与某个指定的操作数匹配</li>
              <li><code class="language-c++ highlighter-rouge"><span class="mi">1</span></code> …<code class="language-c++ highlighter-rouge"><span class="mi">9</span></code> 也即该操作数就是指定的那个操作数，例如<code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>去描述<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>操作数，那么<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">1</span></code>引用的其实就是<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>操作数，注意作为限定符字母的0－9与指令中的<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">0</span></code>－<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="mi">9</span></code>的区别，前者描述操作数，后者代表操作数。</li>
              <li>&amp; 该输出操作数不能使用过和输入操作数相同的寄存器操作数类型</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">=</span></code> 操作数在指令中是只写的（输出操作数）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">+</span></code> 操作数在指令中是读写类型的（输入输出操作数）</li>
            </ul>
          </li>
          <li>浮点数
            <ul>
              <li><code class="language-c++ highlighter-rouge"><span class="n">f</span></code> 浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">t</span></code> 第一个浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">u</span></code> 第二个浮点寄存器</li>
              <li><code class="language-c++ highlighter-rouge"><span class="n">G</span></code> 标准的80387浮点常数</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">%</span></code> 该操作数可以和下一个操作数交换位置，例如<code class="language-c++ highlighter-rouge"><span class="n">addl</span></code>的两个操作数可以交换顺序（当然两个操作数都不能是立即数）</li>
              <li><code class="language-c++ highlighter-rouge"><span class="cp">#</span></code> 部分注释，从该字符到其后的逗号之间所有字母被忽略</li>
              <li><code class="language-c++ highlighter-rouge"><span class="o">*</span></code> 表示如果选用寄存器，则其后的字母被忽略</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>破坏描述部分：破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有<code class="language-c++ highlighter-rouge"><span class="n">memory</span></code>。例如：<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">eax</span></code>，<code class="language-c++ highlighter-rouge"><span class="o">%</span><span class="n">ebx</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">memory</span></code>等。</li>
    </ul>
  </li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《程序员的自我修养》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/programmer-self-cultivation-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/programmer-self-cultivation-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>参考文献
    <ul>
      <li>Linux内核源代码情景分析</li>
      <li>深入理解Windows操作系统 - Microsoft Windows Server 2003/Windows XP/Wincows 2000技术内幕</li>
      <li><span style="color: red">此书一共三卷，这是第一卷，还有两卷呢？？</span></li>
    </ul>
  </li>
  <li>singleton的实现：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">singleton_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p>实际上是不安全的，因为语句<code class="language-c++ highlighter-rouge"><span class="n">singleton_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span></code>分三步：第一步分配内存，第二步在分配的内存上构造T，第三步把内存指针赋值给singleton_ptr。其中第二步和第三步可能被cpu乱序执行调换顺序，因为它们之间没有依赖。这样如果第三步先执行，另一线程并发访问，就会发现singleton_ptr被赋值了但是内容还没被构造。</p>
  </li>
  <li>linux的clone函数</li>
  <li>三种线程模型（“对”表示用户线程和内核线程的映射情况）：
    <ul>
      <li>1对1：缺点是OS限制了内核线程数量从而导致用户线程数量受限，而且线程切换开销较大</li>
      <li>多对1：一个用户线程阻塞将导致所有线程阻塞，增加cpu个数也不管用</li>
      <li>多对多：在多处理器系统上多对多模型的性能提升幅度不如一对一模型高</li>
    </ul>
  </li>
  <li>汇编器as，链接器ld</li>
  <li>词法分析器lex，语法分析器yacc</li>
  <li>链接过程主要包括：地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）</li>
  <li>文件类型p57
    <ul>
      <li>可重定位文件：windows的.obj和linux的.o</li>
      <li>动态链接库：windows的.dll和linux的.so</li>
      <li>静态链接库：windows的.lib和linux的.a</li>
      <li>可执行文件</li>
      <li>核心转储文件：linux的core dump</li>
    </ul>
  </li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《代码优化：有效使用内存》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/code-optimization-effective-memory-usage-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/code-optimization-effective-memory-usage-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>Intel的VTune性能分析器提供了行级的代码profiling</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Buffer Overflow Attacks》读书笔记</title>
      <link>http://localhost:4001/2017/07/20/buffer-overflow-attacks-notes/</link>
      <pubDate>2017-07-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/20/buffer-overflow-attacks-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>exploit是一种程序，通过该程序可以触发软件的一个漏洞并为攻击者使用</li>
  <li>第一章资源
    <ul>
      <li><a href="http://www.securiteam.com">http://www.securiteam.com</a></li>
      <li><a href="http://www.ngssoftware.com">http://www.ngssoftware.com</a></li>
      <li><a href="http://www.foundstone.com">http://www.foundstone.com</a></li>
      <li><a href="http://www.atstake.com">http://www.atstake.com</a></li>
      <li><a href="http://www.vulnerability.org">http://www.vulnerability.org</a></li>
      <li><a href="http://www.ntbugtraq.com">http://www.ntbugtraq.com</a></li>
      <li><a href="http://www.first.org">http://www.first.org</a></li>
    </ul>
  </li>
  <li>第二章资源
    <ul>
      <li><a href="http://www.applicationdefense.com">http://www.applicationdefense.com</a></li>
      <li><a href="http://www.shellcode.com.ar">http://www.shellcode.com.ar</a></li>
      <li><a href="http://www.enderunix.org/docs/en/sc-en.txt">http://www.enderunix.org/docs/en/sc-en.txt</a></li>
      <li><a href="http://www.metasploit.com/shellcode.html">http://www.metasploit.com/shellcode.html</a></li>
      <li><a href="http://www.SecurityFocus.com">http://www.SecurityFocus.com</a></li>
    </ul>
  </li>
  <li>其他网上资源
    <ul>
      <li><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a>包含常见os在常见processor上的常用shellcode</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Unix/Linux编程实践教程》读书笔记</title>
      <link>http://localhost:4001/2017/07/13/understanding-unix-linux-rogramming-notes/</link>
      <pubDate>2017-07-13T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/13/understanding-unix-linux-rogramming-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>1.6 向/dev/tty写即写向当前活动控制台，读则从键盘读入</li>
  <li>2.4 用man的-k选项可以搜索联机帮助</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>《深入Linux内核架构》读书笔记</title>
      <link>http://localhost:4001/2017/07/13/professional-linux-kernel-architecture-notes/</link>
      <pubDate>2017-07-13T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/13/professional-linux-kernel-architecture-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第一章</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第二章</a></li>
  <li><a href="#b" id="markdown-toc-b">附录B</a></li>
  <li><a href="#c" id="markdown-toc-c">附录C</a></li>
</ul>

<h2 id="section">第一章</h2>

<ul>
  <li>pstree命令</li>
</ul>

<h2 id="section-1">第二章</h2>

<ul>
  <li>task_struct图解及其管理：参考<a href="http://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux内核进程管理之进程ID</a></li>
</ul>

<h2 id="b">附录B</h2>

<ul>
  <li>LXR工具：分析内核源代码并生成一个html超文本表示，带交叉引用</li>
  <li>DDD：GDB的图形化工具</li>
  <li>KGDB：可以远程调试运行中的内核</li>
  <li>UML：用户模式内核，运行于另一个（运行于真正硬件的）内核的用户空间上</li>
</ul>

<h2 id="c">附录C</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Linux内核设计与实现》（中+英）读书笔记</title>
      <link>http://localhost:4001/2017/07/13/linux-kernel-development-notes/</link>
      <pubDate>2017-07-13T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4001/2017/07/13/linux-kernel-development-notes</guid>
      <content:encoded><![CDATA[<p><!--  Not show line_numbers  -->
</p>


<ul>
  <li>3.2.1 进程的thread_info结构存放于它们内核栈的尾端（最低地址），其task成员指向task_struct。这是由于x86没有足够的寄存器</li>
  <li>3.2.3 进程状态</li>
  <li>3.2.5 进程上下文（内核空间），中断上下文</li>
  <li>3.3.2 fock(), vfork(), __done()都调用clone()，而clone()调用do_fork()</li>
  <li>3.4.2 内核线程：没有独立的地址空间（mm指针置为NULL）</li>
  <li>3.? 父进程先于子进程退出：先在父进程的线程组中找，若找不到就会令init为子进程的继父进程</li>
  <li>基于优先级的调度
    <ul>
      <li>nice值取值区间为-20到19，代表时间片的比例，越小优先级越高</li>
      <li>实时优先级：0至99，越大优先级越高</li>
    </ul>
  </li>
</ul>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
