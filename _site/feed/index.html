<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>lambda</title>
    <atom:link href="http://localhost:4000/feed/" rel="self" type="application/rss+xml" />
    <link>http://lam8da.github.io</link>
    <lastBuildDate>2016-11-13T00:08:27-08:00</lastBuildDate>
    <webMaster>lambda2fei@gmail.com</webMaster>
    
    <item>
      <title>Blogging Resources</title>
      <link>http://localhost:4000/2016/11/welcome-to-jekyll/</link>
      <pubDate>2016-11-07T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2016/11/welcome-to-jekyll</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#resources" id="markdown-toc-resources">Resources</a></li>
  <li><a href="#code-block-highlighting" id="markdown-toc-code-block-highlighting">Code block highlighting</a>    <ul>
      <li><a href="#how-to-use-highlighter" id="markdown-toc-how-to-use-highlighter">How to use highlighter</a></li>
      <li><a href="#how-to-highlight-inlined-code-blocks" id="markdown-toc-how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</a></li>
    </ul>
  </li>
  <li><a href="#block-inline-attribute-lists-ial" id="markdown-toc-block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</a></li>
</ul>

<h2 id="resources">Resources</h2>
<ol>
  <li>git commands manual: <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></li>
  <li>markdown manual: <a href="http://www.appinn.com/markdown/">http://www.appinn.com/markdown/</a></li>
  <li>kramdown
    <ul>
      <li>quickref/examples: <a href="http://kramdown.gettalong.org/quickref.html">http://kramdown.gettalong.org/quickref.html</a></li>
      <li>syntax/manual: <a href="http://kramdown.gettalong.org/syntax.html">http://kramdown.gettalong.org/syntax.html</a></li>
    </ul>
  </li>
  <li>rouge options: <a href="https://github.com/jneen/rouge#full-options">https://github.com/jneen/rouge#full-options</a></li>
  <li>latex cheat sheet: <a href="https://wch.github.io/latexsheet/">https://wch.github.io/latexsheet/</a></li>
  <li><a href="http://jekyllrb.com/docs/home">Jekyll docs</a></li>
</ol>

<h2 id="code-block-highlighting">Code block highlighting</h2>

<h3 id="how-to-use-highlighter">How to use highlighter</h3>
<!-- Overwrite the setting to not show line_numbers in fenced code blocks -->

<p>Code block using kramdown (<strong>may not be compactible if not using kramdown</strong>):</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span>
</code></pre>
</div>

<p>Code block using Pygments or Rouge by using the <code class="language-ruby highlighter-rouge"><span class="n">highlight</span></code> Liquid tag
(<strong>putting it inside a list will work incorrectly</strong>):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="how-to-highlight-inlined-code-blocks">How to highlight inlined code blocks</h3>

<p>I discovered in 11/12/2016 that all (inlined) code blocks generated by rouge are
wrapped by a
<code class="language-ruby highlighter-rouge"><span class="nt">&lt;code&gt;</span></code>
tag with css class set to</p>
<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="nt">language-some_language</span> <span class="nt">highlighter-rouge</span>
</code></pre>
</div>
<p>. So we can copy the highlight.css to highlighter-rouge.css and make same css
rules applicable to</p>
<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="nt">highlighter-rouge</span> <span class="nt">span_css_class</span>
</code></pre>
</div>
<p>(e.g. <code class="language-ruby highlighter-rouge"><span class="nt">highlighter-rouge</span> <span class="nt">cp</span></code>).</p>

<p>If the code block is just a block of text, not code, we can append
<code class="language-ruby highlighter-rouge"><span class="p">{</span><span class="ss">:language</span><span class="o">-</span><span class="n">nothing</span><span class="p">}</span></code> to the end of the block to make rouge not generate
colorful html representations. E.g.</p>
<div class="language-markdown highlighter-rouge"><pre class="highlight"><code><span class="sb">`int i = 0;`</span>{:.language-nothing}
</code></pre>
</div>
<p>looks like: <code class="language-nothing">int i = 0;</code></p>

<h2 id="block-inline-attribute-lists-ial">Block inline attribute lists (IAL)</h2>

<p id="para-one">A simple paragraph with an ID attribute.</p>

<blockquote title="The blockquote title" id="myid">
  <p>A blockquote with a title</p>
</blockquote>

<div class="language-ruby ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Some</span> <span class="n">code</span> <span class="n">here</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>拜占庭将军问题</title>
      <link>http://localhost:4000/2014/03/byzantine-general-problem/</link>
      <pubDate>2014-03-08T00:00:00-08:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2014/03/byzantine-general-problem</guid>
      <content:encoded><![CDATA[<p>工作之余，花了一周的几乎每个晚上把Lamport神的那篇有关拜占庭将军问题的文章看完了。在这里做下笔记。</p>

<p>个人觉得最难懂的就是OM算法，我将它理解成一个动态规划：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">// @c is the commander id;
// @l is one of the lieutenant id, which belongs to the current lieutenant set;
// @m is the parameter m mentioned in the paper;
// OM(c, l, m) means the final value lieutenant @l obeys from commander @c.
</span>
<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span> <span class="n">where</span> <span class="n">l</span> <span class="n">in</span> <span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">};</span>

<span class="o">-</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
<span class="n">OM</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">majority</span><span class="p">(</span>
  <span class="n">msg</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">),</span>
  <span class="n">the</span> <span class="n">list</span> <span class="n">of</span> <span class="n">OM</span><span class="p">(</span><span class="n">l</span><span class="err">'</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">where</span> <span class="n">l</span><span class="err">'</span> <span class="n">in</span> <span class="p">(</span><span class="n">set</span><span class="p">{</span><span class="n">lieutenant</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">l</span><span class="p">})</span>
<span class="p">).</span>  <span class="c1">// majority
</span></pre></td></tr></tbody></table>
</div>
</div>

<p>实际上，准确来说上面的状态表示是不完全的，OM的第一个参数应该是一个commander的id列表，表示从算法开始的第一个commander通过发消息沿途产生的所有commander。这样说起来还是很抽象，具体还是看下文代码吧。</p>

<p>为了让自己有更深的理解，我用C++实现了一个模拟器，输入general的个数，指定commander是否loyal，模拟算法运行，打印出每条消息以及消息路径，最后得出每个忠诚的lieutenant遵守的命令。目测+用小数据测试没有发现错误，也贴在这里供以后回顾使用。</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208</pre></td><td class="code"><pre><span class="cp">#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
</span> 
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">num_generals</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">commander_is_loyal</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_loyal</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
 
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ValueType</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ValueType</span> <span class="n">kDefaultValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999999999</span><span class="p">;</span>
 
<span class="c1">// Classic algorithm to find the majority: maintain a value and
// a counter, when see a same value, ++counter; otherwise, if
// counter is 0, set the value to the one we see and let counter=1,
// or if counter&gt;0, --counter.
</span><span class="k">struct</span> <span class="n">MajorityCount</span> <span class="p">{</span>
  <span class="n">ValueType</span> <span class="n">majority</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">seen</span><span class="p">;</span>
 
  <span class="n">MajorityCount</span><span class="p">()</span> <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">kDefaultValue</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">MajorityCount</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">majority</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">seen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
 
  <span class="n">MajorityCount</span><span class="o">&amp;</span> <span class="n">Merge</span><span class="p">(</span><span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">seen</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">majority</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">majority</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">majority</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">count</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">": val="</span> <span class="o">&lt;&lt;</span> <span class="n">majority</span>
         <span class="o">&lt;&lt;</span> <span class="s">", cnt="</span> <span class="o">&lt;&lt;</span> <span class="n">count</span>
         <span class="o">&lt;&lt;</span> <span class="s">", seen="</span> <span class="o">&lt;&lt;</span> <span class="n">seen</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">MajorityCount</span><span class="o">&gt;</span> <span class="n">MapType</span><span class="p">;</span>
<span class="n">MapType</span> <span class="n">val_storage</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="nf">RandomShuffle</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">begin</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Itoa</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">res</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sprintf</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">string</span> <span class="nf">Join</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">delim</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Itoa</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ValueType</span> <span class="nf">RandomValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// return std::rand() % 97;
</span>  <span class="k">return</span> <span class="mi">250</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">// Updates the value of OM(c, l, m) using OM(l', l, m-1).
</span><span class="kt">void</span> <span class="nf">MergeUp</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">key_vec</span> <span class="o">=</span> <span class="n">passed_ids</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">back</span> <span class="o">=</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">string</span> <span class="n">src_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">required_num_seen</span> <span class="o">=</span> <span class="n">remaining_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
 
  <span class="k">while</span> <span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="n">key_vec</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dst_key</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="n">key_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
 
    <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">[</span><span class="n">dst_key</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span><span class="n">val_storage</span><span class="p">[</span><span class="n">src_key</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">back</span><span class="p">])</span> <span class="n">mc</span><span class="p">.</span><span class="n">majority</span> <span class="o">=</span> <span class="n">RandomValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">seen</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"    "</span> <span class="o">&lt;&lt;</span> <span class="n">src_key</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">dst_key</span><span class="p">;</span>
    <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">src_key</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">==</span> <span class="n">required_num_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src_key</span> <span class="o">=</span> <span class="n">dst_key</span><span class="p">;</span>
      <span class="o">++</span><span class="n">required_num_seen</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">// Sequential algorithm: for simplicity, assume that each lieutenant
// will send messages to others when needed.
</span><span class="kt">void</span> <span class="nf">OM</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">commander_id</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ValueType</span> <span class="o">&amp;</span><span class="n">received_val</span><span class="p">,</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span>  <span class="c1">// the last one is commander_id.
</span>        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// {1, 2, ..., n-1} - passed_ids
</span>  <span class="k">const</span> <span class="n">string</span> <span class="n">prefix_path</span> <span class="o">=</span>
      <span class="n">Join</span><span class="p">(</span><span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">(),</span> <span class="s">"-"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids_copy</span><span class="p">(</span><span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">remaining_ids_copy</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
      <span class="n">ValueType</span> <span class="n">val_to_send</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">commander_id</span><span class="p">]</span> <span class="o">?</span> <span class="n">received_val</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">());</span>
 
      <span class="c1">// OM(m), step (1)
</span>      <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="n">prefix_path</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">Itoa</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">MajorityCount</span> <span class="o">&amp;</span><span class="n">mc</span> <span class="o">=</span>
        <span class="n">val_storage</span><span class="p">[</span><span class="n">path</span><span class="p">].</span><span class="n">Merge</span><span class="p">(</span>
            <span class="n">MajorityCount</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">val_to_send</span> <span class="o">:</span> <span class="n">RandomValue</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">;</span>
      <span class="n">mc</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
 
      <span class="c1">// OM(m), step (2)
</span>      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">seen</span> <span class="o">==</span> <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">OM</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val_to_send</span><span class="p">,</span> <span class="n">passed_ids</span><span class="p">,</span> <span class="n">remaining_ids</span><span class="p">);</span>
      <span class="n">remaining_ids</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">passed_ids</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">MergeUp</span><span class="p">(</span><span class="o">*</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_ids</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+++++++++++++++++++++++++++++++++"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">,</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"num_generals: "</span><span class="p">,</span>
         <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num_generals</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m: "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"commander_is_loyal? "</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">commander_is_loyal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">val_storage</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_loyal</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">commander_is_loyal</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">is_loyal</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">RandomShuffle</span><span class="p">(</span><span class="n">is_loyal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_generals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">passed_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">remaining_ids</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_generals</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">remaining_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="c1">// commander_id=0, received_val=618
</span>    <span class="n">OM</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">618</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">passed_ids</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remaining_ids</span><span class="p">);</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MapType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">val_storage</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">Print</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（下）- 设计模式</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes2/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes2</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">策略模式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">观察者模式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">装饰者模式</a></li>
  <li><a href="#factory-method-pattern" id="markdown-toc-factory-method-pattern">工厂方法模式（Factory Method Pattern）</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">抽象工厂模式</a></li>
  <li><a href="#singleton-pattern" id="markdown-toc-singleton-pattern">单件模式（Singleton Pattern）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">命令模式（封装调用）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">适配器模式</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">外观模式</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">模板方法模式</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">迭代器模式</a></li>
  <li><a href="#section-9" id="markdown-toc-section-9">组合模式</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">状态模式</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">代理模式</a></li>
  <li><a href="#mvc--" id="markdown-toc-mvc--">MVC：模型-视图-控制器</a></li>
  <li><a href="#section-12" id="markdown-toc-section-12">模式分类</a></li>
</ol>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">策略模式</h2>

<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.strategy.png" alt="strategy" /></p>

<h2 id="section-1">观察者模式</h2>

<p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。以下是Java的观察者模式：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.observers.png" alt="observers" /></p>

<ol>
  <li>出版者+订阅者=观察者模式</li>
  <li>不要依赖于观察者被通知的次序，因为一旦观察者/可观察者的实现有所改变，通知次序就会改变，很可能就会产生错误的结果，这绝对不是我们认为的松耦合</li>
  <li><code class="language-java highlighter-rouge"><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Observale</span></code>的黑暗面：<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>是一个类，如果某类想同时具有<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承，这限制了<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>的复用潜力；另外，<code class="language-java highlighter-rouge"><span class="n">Observable</span></code>将关键方法（<code class="language-java highlighter-rouge"><span class="n">setChanged</span><span class="o">()</span></code>）保护起来，这个设计违反了设计原则：多用组合，少用继承。</li>
</ol>

<h2 id="section-2">装饰者模式</h2>

<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.decorator.png" alt="decorator" /></p>

<ol>
  <li>如上述类图关系，重点在于，装饰者和被装饰者必须是一样的类型，也就是有同样的超类，这相当关键。在这里，我们利用继承达到“类型匹配”而不是获得“行为”。</li>
  <li>为何装饰者和被装饰者有相同的接口：因为装饰者必须能取代被装饰者。</li>
  <li>通常装饰者模式是采用抽象类，但是在Java中可以使用接口</li>
</ol>

<h2 id="factory-method-pattern">工厂方法模式（Factory Method Pattern）</h2>

<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类，通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>

<p>工厂模式具有平行的类层级：</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.factory.png" alt="factory" /></p>

<ol>
  <li>当可能有许多客户程序通过各种方法来创建一个类型的新对象时，可以考虑到把创建这个对象的方法放到一个工厂中去，即使用工厂模式。所有工厂模式都用来封装对象的创建。</li>
  <li>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。工厂方法不一定要真的放到一个非本类的“工厂类”中。</li>
  <li>使用“工厂”意味着客户在实例化对象时，只会依赖于接口而不是具体类。这符合依赖倒置原则。</li>
</ol>

<h2 id="section-3">抽象工厂模式</h2>

<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.abstract-factory.png" alt="abstract-factory" /></p>

<ol>
  <li>抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法</li>
  <li>抽象工厂和工厂方法都是负责创建对象，工厂方法用的方法是继承，抽象工厂是通过对象的组合</li>
  <li>当需要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂；而工厂方法可以把客户代码从需要实例化的具体类中解耦，或如果目前还不知道将来需要实例化哪些具体类时，也可以用工厂方法。</li>
  <li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
</ol>

<h2 id="singleton-pattern">单件模式（Singleton Pattern）</h2>

<p>单件模式用来创建独一无二的、只能有一个实例的对象。</p>

<ol>
  <li>实现方法：若将对象赋值给一个全局变量，那么必须在程序一开始就创建好对象。万一这个对象非常耗资源，而程序在这次执行过程中又一直没用到它，就会形成浪费。</li>
  <li>
    <p>单件模式实现中处理多线程问题的方法：</p>

    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span><span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">uniqueInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">uniqueInstance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
    </div>
    <p>使用<code class="language-java highlighter-rouge"><span class="kd">synchronized</span></code>关键字可能会导致效率严重下降。而volatile关键字定义的成员变量确保在同一时间最多只有一个线程对其进行访问，尤其是32位系统处理64位变量时。另外，也可以使用“急切”创建实例而不用延迟实例，在静态初始化器（static initializer）中创建单位：</p>

    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">uniqueInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</code></pre>
    </div>
    <p>但这样会导致1中提到的问题。</p>
  </li>
</ol>

<h2 id="section-4">命令模式（封装调用）</h2>

<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.command.png" alt="command" /></p>

<ol>
  <li>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式</li>
  <li>宏命令模式：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.macro-command.png" alt="macro-command" /></p>

<h2 id="section-5">适配器模式</h2>

<p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.adapter.png" alt="adapter" /></p>

<h2 id="section-6">外观模式</h2>

<p>外观模式改变接口，将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观，让接口更简单。</p>

<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>

<h2 id="section-7">模板方法模式</h2>

<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>

<ol>
  <li>模板方法不一定要使用继承，例如c++的stl的排序方法使用的比较函数</li>
  <li>常见形式：
    <ul>
      <li>抽象方法：当子类必须提供算法中某个步骤的实现时使用</li>
      <li>钩子：当算法某个部分可选时使用</li>
    </ul>
  </li>
  <li>为了防止子类改变模板方法中的算法，可以将模板方法声明为<code class="language-java highlighter-rouge"><span class="kd">final</span></code></li>
</ol>

<h2 id="section-8">迭代器模式</h2>

<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.iterator.png" alt="iterator" /></p>

<h2 id="section-9">组合模式</h2>

<p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.composite.png" alt="composite" /></p>

<p>组合模式是让一个类有两个责任的模式，它不但要管理层次结构，而且还要执行菜单的操作。但组合模式以单一责任设计原则换取透明性（transparency）：通过让组件的接口同事包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁，这是一个很典型的折中案例。</p>

<h2 id="section-10">状态模式</h2>

<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.state.png" alt="state" /></p>

<p>上述<code class="language-java highlighter-rouge"><span class="n">ConcreteStateA</span></code>和<code class="language-java highlighter-rouge"><span class="n">ConcreteStateB</span></code>对<code class="language-java highlighter-rouge"><span class="n">Context</span></code>的引用并不是必须的。有时<code class="language-java highlighter-rouge"><span class="n">Context</span></code>本身也可以决定状态转换的流向。当状态转换是固定时（例如做了某个动作后就一定转换到某特定状态），就适合放在<code class="language-java highlighter-rouge"><span class="n">Context</span></code>中。当转换更动态的时候，通常就会放在状态类中。做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭。</p>

<p>多个<code class="language-java highlighter-rouge"><span class="n">Context</span></code>实例可共享状态对象（使用静态变量）。若状态需要利用<code class="language-java highlighter-rouge"><span class="n">Context</span></code>中的方法，还必须在每个<code class="language-java highlighter-rouge"><span class="n">handler</span><span class="o">()</span></code>方法内传入一个<code class="language-java highlighter-rouge"><span class="n">Context</span></code>引用。</p>

<h2 id="section-11">代理模式</h2>

<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.proxy.png" alt="proxy" /></p>

<ol>
  <li>几种代理模式：
    <ul>
      <li>远程代理：控制访问远程对象</li>
      <li>虚拟代理：控制访问创建开销大的资源</li>
      <li>保护代理：基于权限控制对资源的访问</li>
      <li>防火墙代理（Firewall Proxy）</li>
      <li>智能引用代理（Smart Reference Proxy）</li>
      <li>缓存代理（Caching Proxy）</li>
      <li>同步代理（Synchronization Proxy）</li>
      <li>复杂隐藏代理（Complexity Hiding Proxy）</li>
      <li>写入时复制代理（Copy-On-Write Proxy）</li>
    </ul>
  </li>
  <li>Java RMI（远程过程调用）
    <ul>
      <li>java.rmi.Remote</li>
      <li>stub、skeleton</li>
      <li>rmic、rmiregistry工具</li>
      <li>transient关键字：告诉Java不要序列化一个对象</li>
    </ul>
  </li>
  <li>Java的动态代理技术：</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.java-dynamic-proxy.png" alt="java-dynamic-proxy" /></p>

<h2 id="mvc--">MVC：模型-视图-控制器</h2>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc.png" alt="mvc" /></p>

<p>图解：</p>

<ol>
  <li>策略模式：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略</li>
  <li>视图用组合模式组织各窗口、面板、按钮等</li>
  <li>模型实现了观察者模式，当状态改变时通知对象更新。这使得同一模型可以使用不同的视图甚至可使用多个视图</li>
  <li>不同接口的模型常常通过适配器模式复用同一个视图</li>
</ol>

<p><img src="http://localhost:4000/assets/2013-09-20-head-first-design-pattern-notes2.mvc-web.png" alt="mvc-web" /></p>

<p>上图是Web中的MVC，称为Model 2（Servlet+JSP）。</p>

<p>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p>

<h2 id="section-12">模式分类</h2>

<p>模式是在某情景下，针对某问题的某种解决方案。模式可分为以下几类：</p>

<ul>
  <li>创建型：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。包括：Singleton、Builder、Prototype、Abstract Factory、Factory Method</li>
  <li>行为型：设计到类和对象如何交互及分配的职责。包括：Template Method、Visitor、Mediator、Iterator、Command、Memento、Interpreter、Observer、Chain of Responsibility、State、Strategy</li>
  <li>结构型：可让你把类或对象组合到更大的结构中。包括：Decorator、Proxy、Composite、Façade、Flyweight、Bridge、Adapter</li>
</ul>

<p>反模式告诉你如何采用一个不好的解决方案解决一个问题，告诉你为何这个方案从长远看会造成不好的影响，警告你不要陷入某种致命的诱惑，建议你改用其他的模式以提供更好的解决方案。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Head First设计模式》读书笔记（上）- 设计原则</title>
      <link>http://localhost:4000/2013/09/head-first-design-pattern-notes1/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/head-first-design-pattern-notes1</guid>
      <content:encoded><![CDATA[<ol id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">封装变化</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">针对接口编程，而不是针对实现编程</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">多用组合，少用继承</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">为了交互对象之间的松耦合设计而努力</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">类应该对扩展开放，对修改关闭</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">要依赖抽象，不要依赖具体类</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">最小知识原则</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">好莱坞原则</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">应尽量让每个类保持单一责任</a></li>
</ol>

<h2 id="section">封装变化</h2>

<p>找出应用中可能需要变化之处，把它们独立出来（并封装起来），不要和那些不要变化的代码混在一起。</p>

<p>如果每次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分</p>

<h2 id="section-1">针对接口编程，而不是针对实现编程</h2>

<p>以前的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于“实现”，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p>

<p>“针对接口编程”真正的意思是“针对超类型（supertype）编程”，货可以更明确地说成“变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口”。</p>

<h2 id="section-2">多用组合，少用继承</h2>

<p>良好的OO设计必须具备可复用、可扩充、可维护三个特性。大多数的模式都允许系统局部改变独立于其他部分</p>

<h2 id="section-3">为了交互对象之间的松耦合设计而努力</h2>

<h2 id="section-4">类应该对扩展开放，对修改关闭</h2>

<h2 id="section-5">要依赖抽象，不要依赖具体类</h2>

<p>依赖倒置原则（Dependency Inversion Principle）：不能让高层组件依赖低层组件，而且，不管高层或低层组件，两者都应该依赖于抽象。所谓高层组件，是由其他低层组件定义其行为的类。</p>

<p>一下指导方针能帮助避免在OO设计中违反依赖倒置原则：</p>

<ol>
  <li>变量不可以持有具体类的引用</li>
  <li>不要让类派生自具体类</li>
  <li>不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</li>
</ol>

<h2 id="section-6">最小知识原则</h2>

<p>减少对象之间的交互，不要让太多的类耦合在一起。</p>

<p>指导方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：</p>

<ol>
  <li>该对象本身</li>
  <li>被当做方法的参数而传进来的对象</li>
  <li>此方法所创建或实例化的任何对象</li>
  <li>对象的任何组件（Has-A）</li>
</ol>

<p>注意，如果某对象是调用其他方法的返回结果，不要调用该对象的方法！</p>

<h2 id="section-7">好莱坞原则</h2>

<p>别调用（打电话给）我们，我们会调用（打电话给）你（将决策权放在高层模块中）。</p>

<p>例如模板方法模式中，低层组件绝对不可以直接调用高层组件。</p>

<h2 id="section-8">应尽量让每个类保持单一责任</h2>

<p>因为一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域。如果一个类具有两个改变的原则，那么这会使得将来该类变化的几率上升；而当它真的改变时，你的设计中同时有两个方面将受到影响。</p>

<p>术语：</p>
<ul>
  <li>内聚（cohesion）：用来度量一个类或模块紧密地达到单一目的或责任</li>
  <li>高内聚：一个模块/类被设计成只支持一组相关功能</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第17-18章完）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter17to18</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第17章 用于大型程序的工具</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第18章 特殊工具与技术</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第17章 用于大型程序的工具</h2>

<ol>
  <li>承诺不抛出任何异常的方法：<code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{}</span></code></li>
  <li>
    <p>命名空间别名（像定义变量一样）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span>  <span class="c1">// n2是一个已定义的命名空间
</span></code></pre>
    </div>
  </li>
  <li>
    <p>屏蔽命名空间名字规则的一个重要例外：接受类类型形参（或类类型指针及引用形参）的函数（包括重载操作符），以及与类本身定义在同一命名空间中的函数（包括重载操作符），在用类类型对象（或类类型的引用及指针）作为实参的时候是可见的。如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// ok
</span></code></pre>
    </div>
    <p>当compiler看到<code class="language-c++ highlighter-rouge"><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span></code>时，它在当前作用域、包含调用的作用域以及定义<code class="language-c++ highlighter-rouge"><span class="n">cin</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>的命名空间中查找匹配的函数。</p>
  </li>
  <li>在最底层派生类的构造函数中，c++会首先初始化虚基类；在初始化中间层派生类时，忽略它们对虚基类的初始化。</li>
</ol>

<h2 id="section-1">第18章 特殊工具与技术</h2>

<ol>
  <li>c++提供以下两种方法分配和释放未构造的原始内存：<code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>类；标准库中的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>和<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>。</li>
  <li>c++还提供不同的方法在原始内存中构造和撤销对象：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>类的construct和destroy成员</li>
      <li>定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式（placement new expression）接受指向未构造内存的指针，并在该空间中初始化一个对象或一个数组</li>
      <li>可直接调用对象的析构函数来撤销对象。运行析构函数并不释放所在内存</li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">uninitialized_fill</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">uninitiated_copy</span></code></li>
    </ul>
  </li>
  <li>
    <p><code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>接口（只分配/释放空间，不构造/析构）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式（在已分配但未构造的内存中初始化对象）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">new</span> <span class="p">(</span><span class="n">place_address</span><span class="p">)</span> <span class="n">type</span>
<span class="k">new</span> <span class="p">(</span><span class="n">place_address</span><span class="p">)</span> <span class="n">type</span> <span class="p">(</span><span class="n">initializer_list</span><span class="p">)</span>
</code></pre>
    </div>
    <p>其中<code class="language-c++ highlighter-rouge"><span class="n">place_address</span></code>是指针，<code class="language-c++ highlighter-rouge"><span class="n">initializer_list</span></code>是初始化列表。
例如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
<span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>  <span class="c1">// 复制构造
</span></code></pre>
    </div>
    <p>可以改为：<code class="language-c++ highlighter-rouge"><span class="k">new</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">);</span></code></p>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>的construct只能使用复制构造，但定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式可以使用任何构造函数</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">allocator</span></code>的方法和低级操作的对应关系：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="n">allocate</span></code>   &lt;==&gt; <code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">deallocate</span></code> &lt;==&gt; <code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">construct</span></code>  &lt;==&gt; 定位<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式</li>
      <li><code class="language-c++ highlighter-rouge"><span class="n">destroy</span></code>    &lt;==&gt; 直接调用析构函数如：<code class="language-c++ highlighter-rouge"><span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span></code></li>
    </ul>
  </li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">"initialized"</span><span class="p">);</span></code>实际上发生三件事：
    <ol>
      <li>调用<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>分配内存。如果<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>没被重载，就调用标准库中的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>。</li>
      <li>运行该类型的一个构造函数，在上一个步骤分配的内存中初始化之</li>
      <li>返回该对象的指针</li>
    </ol>

    <p>而<code class="language-c++ highlighter-rouge"><span class="k">delete</span> <span class="n">sp</span><span class="p">;</span></code>实际上发生两件事：</p>
    <ol>
      <li>对<code class="language-c++ highlighter-rouge"><span class="n">sp</span></code>指向的对象运行适当的析构函数</li>
      <li>调用名为<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>的标准库函数释放内存</li>
    </ol>
  </li>
  <li>我们可以为一个类<code class="language-c++ highlighter-rouge"><span class="n">C</span></code>定义它特定的<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>（称为“成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>”）或<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span><span class="p">[]</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span><span class="p">[]</span></code>函数，改变<code class="language-c++ highlighter-rouge"><span class="k">new</span></code>表达式的行为：
    <ul>
      <li><code class="language-c++ highlighter-rouge">
  <span class="n">C</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span> <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// 调用自定义版本
</span> </code></li>
      <li><code class="language-c++ highlighter-rouge">
  <span class="n">C</span> <span class="o">*</span><span class="n">obj1</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="n">C</span><span class="p">();</span> <span class="o">::</span><span class="k">delete</span> <span class="n">obj1</span><span class="p">;</span>  <span class="c1">// 调用标准库版本
</span> </code></li>
    </ul>
  </li>
  <li>成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>有两种定义：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">C</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">C</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">);</span></code></li>
    </ul>

    <p>其中<code class="language-c++ highlighter-rouge"><span class="kt">void</span><span class="o">*</span></code>形参由<code class="language-c++ highlighter-rouge"><span class="k">delete</span></code>表达式用被<code class="language-c++ highlighter-rouge"><span class="k">delete</span></code>的指针初始化，<code class="language-c++ highlighter-rouge"><span class="kt">size_t</span></code>由编译器用第一个形参所指对象的字节大小自动初始化。<code class="language-c++ highlighter-rouge"><span class="kt">size_t</span></code>一般用于继承层次，根据<code class="language-c++ highlighter-rouge"><span class="k">virtual</span> <span class="n">ptr</span></code>指向的对象的大小确定。类似地，成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span><span class="p">[]</span></code>也有两种定义。</p>
  </li>
  <li>成员<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">new</span></code>/<code class="language-c++ highlighter-rouge"><span class="k">operator</span> <span class="k">delete</span></code>函数隐式地为静态函数，不必显式地将它们声明为<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>，虽然这样做是合法的。</li>
  <li>运行时类型识别（RTTI）：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="k">typeid</span></code>操作符：返回动态类型信息（当类型有虚函数时）或静态的、编译时的类型信息（以<code class="language-c++ highlighter-rouge"><span class="n">type_info</span></code>对象的形式返回）</li>
      <li><code class="language-c++ highlighter-rouge"><span class="k">dynamic_cast</span></code>操作符的用法：
        <ul>
          <li>
            <p>作用于指针</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">Derived</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base_ptr</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
            </div>
          </li>
          <li>
            <p>作用于引用</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_cast</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>成员指针（pointer to member）：
    <ul>
      <li>数据成员的指针：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="n">C</span><span class="o">::*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">obj</span><span class="p">;</span></code></li>
      <li>成员函数的指针：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_type_list</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">func</span><span class="p">;</span></code></li>
      <li>类的<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员不需要特殊语法来指向，其指针就是普通指针</li>
    </ul>

    <p>成员指针的使用（<code class="language-c++ highlighter-rouge"><span class="p">.</span><span class="o">*</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">-&gt;*</span></code>操作符）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">C</span> <span class="n">cobj</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
<span class="p">(</span><span class="n">cobj</span><span class="p">.</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_list</span><span class="p">);</span>
<span class="p">(</span><span class="n">cptr</span><span class="o">-&gt;*</span><span class="n">ptr</span><span class="p">)(</span><span class="n">arg_list</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>关于嵌套类：
    <ul>
      <li>嵌套在类模板内部的类是模板</li>
      <li>
        <p>在外围类外部定义嵌套类的方法：</p>

        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Outer</span> <span class="p">{</span> <span class="k">class</span> <span class="nc">Inner</span><span class="p">;</span>  <span class="cm">/* forward declaration */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Outer</span><span class="o">::</span><span class="n">Inter</span> <span class="p">{</span> <span class="cm">/* definition */</span> <span class="p">};</span>
</code></pre>
        </div>
      </li>
    </ul>
  </li>
  <li>固有的不可移植的特性包括：位域、<code class="language-c++ highlighter-rouge"><span class="k">volatile</span></code>限定符、链接指示（如<code class="language-c++ highlighter-rouge"><span class="k">extern</span> <span class="s">"C"</span></code>等）。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第16章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter16/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter16</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第16章 模板与泛型编程</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第16章 模板与泛型编程</h2>

<ol>
  <li>模板形参可以是表示类型的类型形参（type parameter，表示未知类型），也可以是表示常量表达式的非类型形参（nontype parameter，表示未知值）</li>
  <li>
    <p>函数模板也可以声明为<code class="language-c++ highlighter-rouge"><span class="kr">inline</span></code>。此时<code class="language-c++ highlighter-rouge"><span class="kr">inline</span></code>关键字放在模板形参表之后、返回类型之前，不能放在关键字<code class="language-c++ highlighter-rouge"><span class="k">template</span></code>之前：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>模板形参遵循常规名字屏蔽规则：与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字</li>
  <li>用作模板形参的名字不能在模板内部重用</li>
  <li>模板也可以只声明而不定义</li>
  <li>若模板定义中使用了模板形参中的类型的一个内部定义的类型，必须用<code class="language-c++ highlighter-rouge"><span class="k">typename</span></code>显式指明该名字是一个类型，否则编译器会假定该名字指定的是一个数据成员</li>
  <li>当一个模板类型用作（同一函数的）一个以上函数形参类型时，对应的实参的类型必须完全一致（当通过“<code class="language-c++ highlighter-rouge"><span class="o">&lt;&gt;</span></code>”提供显式实参时，或者属于下列情况时，例外），因为一般而言不会转换实参以匹配已有的实例化，相反，会产生新的实例。例外的情况为：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="k">const</span></code>转换：非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象的引用或指针-&gt;<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用或指针；<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>或非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象-&gt;非引用类型（忽略<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>）</li>
      <li>数组或函数到指针的转换。当模板形参不是引用类型时：数组/函数-&gt;指针。</li>
    </ul>

    <p>例：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fobj</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>  <span class="c1">// fobj(string, string); const is ignored
</span><span class="n">fref</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>  <span class="c1">// non const -&gt; const reference
</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// fobj(int*, int*);
// fref(a, b);  // error!
</span></code></pre>
    </div>
  </li>
  <li>
    <p>可以使用函数模板对函数指针进行初始化或赋值：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// 实例化
</span></code></pre>
    </div>
    <p>如果不能从函数指针类型确定模板实参，就会出错</p>
  </li>
  <li>某些情况下不可能推断出模板实参的类型。当函数的返回类型必须与形参表中所用的所有类型都不同时，最常出现这一问题。可以采用“增加一个模板形参以表示返回类型，调用时显示指定该类型”的方法解决</li>
  <li>显式提供模板实参时可以像函数的默认实参机制那样省略右边的模板实参（由编译器推断）</li>
  <li>模板要进行实例化时，编译器必须能够访问定义模板的源代码。如果采用分别编译模型（separate compilation model），在模板定义时需要使用<code class="language-c++ highlighter-rouge"><span class="k">export</span></code>关键字。</li>
  <li>类模板的成员函数只有为程序所用才进行实例化，如果某函数从未使用，则不会实例化该成员函数。一个典型例子是，若某类型没有定义默认的构造函数，也可以用<code class="language-c++ highlighter-rouge"><span class="n">std</span><span class="o">::</span><span class="n">vector</span></code>存放它，但<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>初始化时不能使用<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>的只有一个<code class="language-c++ highlighter-rouge"><span class="n">size</span></code>成员的构造函数。</li>
  <li>
    <p>类模板中的友元声明：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// ok: A is known to be a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">C</span><span class="p">;</span>  <span class="c1">// ok: C must be an ordinary, non-template class
</span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">D</span><span class="p">;</span>  <span class="c1">// ok: D is a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">E</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// error: E wasn’t declare as a template
</span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// error: F wasn’t declare as a template
</span><span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>在类特化的外部定义该特化类的成员时，成员之前不能加<code class="language-c++ highlighter-rouge"><span class="k">template</span><span class="o">&lt;&gt;</span></code>标记</li>
  <li>可以只特化成员而不是特化整个类</li>
  <li>类模板的部分特化：特化某些模板形参而非全部。当声明了部分特化时，编译器将为实例化选择最特化的模板定义</li>
  <li>函数匹配与函数模板：若重载函数中既有普通函数又有函数模板，确定函数调用的步骤如下：
    <ol>
      <li>建立候选函数集，包括
        <ul>
          <li>与被调函数名字相同的任意普通函数</li>
          <li>任意函数模板实例化（模板实参推断发现了与调用中所用函数实参相匹配的模板实参）</li>
        </ul>
      </li>
      <li>确定哪些普通函数是可行的（见本笔记7.22或原书7.8节关于如何选择可行函数的讨论）。候选集中每个模板实例都是可行的，因为模板实参推断保证了这点。</li>
      <li>若需要转换来进行调用，根据转换的种类排列可行函数（注意模板函数的实例所允许的转换是有限的）
        <ul>
          <li>如果只有一个函数可选，就调用之</li>
          <li>如果调用有二义性，从可行函数集合中去掉所有函数模板实例</li>
        </ul>
      </li>
      <li>重新排列去掉函数模板实例的可行函数。如果只有一个函数可选，调用之；否则有二义性。</li>
    </ol>

    <ul>
      <li>
        <p>例一：</p>

        <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cm">/* I. */</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="cm">/* II.*/</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</code></pre>
        </div>
        <ul>
          <li>
            <p>调用1：</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">const_arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">const_arr1</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">);</span>
</code></pre>
            </div>
            <p>将调用普通函数II。将<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span></code>的<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>也是可行函数，但是根据上述第3点第二条，它将被去掉。
注：实际上是比较以下俩可行函数：</p>

            <ul>
              <li>从I实例化的：<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span></code></li>
              <li>II的：<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span></code></li>
            </ul>
          </li>
          <li>
            <p>调用2：</p>

            <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">ch_arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">,</span> <span class="n">ch_arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">ch_arr1</span><span class="p">,</span> <span class="n">ch_arr2</span><span class="p">);</span>
</code></pre>
            </div>
            <p>同样也调用普通函数II。I的实例将<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="kt">char</span><span class="o">*</span></code>。</p>
          </li>
        </ul>
      </li>
      <li>
        <p>例二：
如果I是这样：<code class="language-c++ highlighter-rouge"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span></code>则：</p>
        <ul>
          <li><code class="language-c++ highlighter-rouge"><span class="n">compare</span><span class="p">(</span><span class="n">ch_arr1</span><span class="p">,</span><span class="n">ch_arr2</span><span class="p">);</span></code>将调用<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">T</span></code>绑定到<code class="language-c++ highlighter-rouge"><span class="kt">char</span><span class="o">*</span></code>。</li>
          <li><code class="language-c++ highlighter-rouge"><span class="n">compare</span><span class="p">(</span><span class="n">const_arr2</span><span class="p">,</span> <span class="n">const_arr2</span><span class="p">);</span></code>将调用II。</li>
          <li><code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp1</span> <span class="o">=</span> <span class="n">const_arr1</span><span class="p">,</span> <span class="o">*</span><span class="n">cp2</span> <span class="o">=</span> <span class="n">const_arr2</span><span class="p">;</span> <span class="n">compare</span><span class="p">(</span><span class="n">cp1</span><span class="p">,</span> <span class="n">cp2</span><span class="p">);</span></code>将调用II。</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第14-15章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter14to15</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第14章 重载操作符与转换</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第15章 面向对象编程</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第14章 重载操作符与转换</h2>

<ol>
  <li>不能重载的操作符包括：<code class="language-c++ highlighter-rouge"><span class="o">::</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">*</span></code>（取值）和三元运算符<code class="language-c++ highlighter-rouge"><span class="o">?:</span></code>。</li>
  <li>不能通过连接其他合法操作符来创建任何新操作符</li>
  <li>重载操作符必须具有至少一个类类型或枚举类型的操作数，因此内置类型的操作符含义不能改变，也不能为任何内置类型定义额外的新的操作符。</li>
  <li>操作符的优先级、结合性或操作数数目不能改变。除了函数调用操作符<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>外，重载操作符时使用默认实参是非法的。</li>
  <li>重载操作符并不保证操作数的求值顺序（尤其是<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>和逗号操作符）。在<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>和<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>的重载版本中，两个操作数都要进行求值。</li>
  <li>一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员。</li>
  <li>也可以像调用普通函数那样调用重载操作符如：
    <ul>
      <li>非类成员：<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">);</span></code></li>
      <li>类成员：<code class="language-c++ highlighter-rouge"><span class="n">item1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">item2</span><span class="p">);</span></code></li>
    </ul>
  </li>
  <li>不应重载具有内置含义的操作符：<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="p">,</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">&amp;&amp;</span></code>、<code class="language-c++ highlighter-rouge"><span class="o">||</span></code>。</li>
  <li>赋值（<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>）、下标（<code class="language-c++ highlighter-rouge"><span class="p">[]</span></code>）、调用（<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>）和成员访问箭头（<code class="language-c++ highlighter-rouge"><span class="o">-&gt;</span></code>）必须定义为成员函数。</li>
  <li>箭头操作符虽然表现得像二元操作符，但重载时不接受显式形参：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{...}</span></code>。
当这样编写时：<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">();</span></code>，由于优先级规则，它等价于<code class="language-c++ highlighter-rouge"><span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)();</span></code>。求值过程为：
    <ol>
      <li>若<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>是一个指针，指向具有名为<code class="language-c++ highlighter-rouge"><span class="n">action</span></code>的成员的类对象，则编译器将代码编译为调用该对象的<code class="language-c++ highlighter-rouge"><span class="n">action</span></code>成员；</li>
      <li>否则，若<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>是定义了<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">-&gt;</span></code>操作符的一个对象，则<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">action</span></code>与<code class="language-c++ highlighter-rouge"><span class="n">pointer</span><span class="p">.</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">action</span></code>相同，即执行<code class="language-c++ highlighter-rouge"><span class="n">pointer</span></code>的<code class="language-c++ highlighter-rouge"><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span></code>，然后调用该结果重复这两步；</li>
      <li>否则，代码出错。</li>
    </ol>

    <p>因此，重载箭头操作符必须返回指向类类型的指针，或返回定义了自己箭头操作符的类类型对象。</p>
  </li>
  <li>两种自增操作符的重载：
    <ul>
      <li>前自增：<code class="language-c++ highlighter-rouge"><span class="n">Type</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{...}</span></code></li>
      <li>后缀式自增：Type operator++(int) {…}`</li>
    </ul>

    <p>为解决前/后缀形式的形参数目和类型相同的问题，后缀式操作符接受一个额外的（无用的）<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>型形参。使用时编译器提供<code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>作为其实参。该形参不用命名，因为不应被使用到。显式调用的方法为：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">obj</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// postfix
</span><span class="n">obj</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>  <span class="c1">// prefix
</span></code></pre>
    </div>
  </li>
  <li>一般为表示操作的类重载调用操作符，其对象称为函数对象。</li>
  <li>
    <p>转换操作符（conversion operator）是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换；它在类定义体内声明，在保留字<code class="language-c++ highlighter-rouge"><span class="k">operator</span></code>之后跟着转换的目标类型：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">operator</span> <span class="n">Type2</span><span class="p">()</span> <span class="k">const</span> <span class="p">{...}</span>  <span class="c1">// 无返回类型，形参表为空
</span></code></pre>
    </div>
    <p>对任何可作为函数返回类型的类型（<code class="language-c++ highlighter-rouge"><span class="kt">void</span></code>除外），都可以定义转换函数（故数组和函数类型不行）。虽然不能指定返回类型，但必须显式返回一个指定类型的值。</p>
  </li>
  <li>只要定义了转换，编译器将在可以使用内置转换的地方自动调用它，包括显式类型转换<code class="language-c++ highlighter-rouge"><span class="k">static_cast</span></code>。</li>
  <li>使用转换函数时，被转换的类型不必与所需类型完全匹配，必要时可在类类型转换之后跟上标准转换（如<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">double</span></code>这种）以获得想要的类型，但不能再跟另一个类类型转换！</li>
  <li>标准转换可放在类类型转换之前，例如使用构造函数执行的隐式转换：<code class="language-c++ highlighter-rouge"><span class="kt">double</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="n">Type</span></code>，其中<code class="language-c++ highlighter-rouge"><span class="n">Type</span></code>类型有一个带单<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>参数的构造函数。</li>
  <li>如果两个转换操作符都可用于同一个调用中，而且转换之后存在标准转换，则根据该标准转换的类别使用最佳匹配</li>
  <li>当两个构造函数定义的转换都可以使用时，如果存在构造函数实参所需的标准转换，就用该标准转换的类别选择最佳匹配。</li>
  <li>
    <p>当两个类定义了转换时的二义性：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cm">/*I. */</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">);</span> <span class="p">};</span>                <span class="c1">// B-&gt;A
</span><span class="cm">/*II.*/</span> <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="k">operator</span> <span class="n">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// B-&gt;A
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">func</span><span class="p">(</span><span class="n">B</span><span class="p">());</span>  <span class="c1">// ambiguous
</span></code></pre>
    </div>
    <p>但若将I改为<code class="language-c++ highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span></code>则不再存在二义性，这是因为使用<code class="language-c++ highlighter-rouge"><span class="n">I</span></code>将需要一个引用绑定到<code class="language-c++ highlighter-rouge"><span class="n">B</span></code>的对象，而使用II则避免了这个额外步骤。</p>
  </li>
  <li>转换与函数重载确定的关系：如果重载集里面的两个函数可以用同一转换函数匹配，则使用在转换之后或之前的标准转换序列的等级来确定最佳匹配；否则，如果可以使用不同的转换操作，则认为这两个转换是一样好的匹配，不管可能需要或不需要的标准转换等级如何。</li>
  <li>操作符的重载确定遵循常见的三步过程，而操作符的候选函数可能包括成员和非成员函数。</li>
</ol>

<h2 id="section-1">第15章 面向对象编程</h2>

<ol>
  <li>派生类对其基类类型的对象的<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>成员没有特殊访问权限。</li>
  <li>派生类的虚函数的声明必须与基类完全匹配，但有个例外：派生类中的虚函数可以返回基类函数所返回类型（必须是引用或指针）的派生类的引用（或指针）</li>
  <li>一旦函数在基类中声明为虚函数，它就一直是虚函数，不管派生类中用不用<code class="language-c++ highlighter-rouge"><span class="k">virtual</span></code></li>
  <li>用作基类的类必须是已定义的，只声明不行（否则就可以从自身派生出一个类了）</li>
  <li>可以使用作用域操作符覆盖虚函数机制并强制函数调用使用虚函数的特定版本</li>
  <li>虚函数的默认实参不受动态绑定影响：通过类<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>的引用或指针调用虚函数时，默认实参是在<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>中定义的值，不管该引用或指针绑定的是<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>的对象还是其派生类对象。另外，基类中虚函数如果指定了默认实参，派生类可以指定也可以不指定；反之亦然。</li>
  <li>派生类不能访问基类的<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>成员</li>
  <li>使用<code class="language-c++ highlighter-rouge"><span class="k">using</span></code>，派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松（但g++ 4.6.1上却可以任意指定新的访问级别）</li>
  <li>友元关系不能继承：
    <ul>
      <li>基类的友元对派生类没有特殊访问权限</li>
      <li>如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系给基类的类</li>
    </ul>
  </li>
  <li>若基类定义了<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员，则整个继承层次中只有一个这样的成员，每个<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员只有一个实例。</li>
  <li>派生类可以将基类的非纯虚的虚函数变为纯虚函数</li>
  <li>派生类到基类转换的可访问性：
    <ul>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">public</span></code>继承，则用户代码和后代类都可以访问（使用）派生类到基类的转换</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>或<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承，则用户代码不能将派生类型对象转换为基类对象</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承，则从<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>继承类派生出来的类（即孙子层）不能转换为基类（不管是用户代码还是在下层派生类中）</li>
      <li>如果是<code class="language-c++ highlighter-rouge"><span class="k">protected</span></code>继承，则后续派生类的成员可以转换为基类类型</li>
      <li>派生类本身的成员和友元总是可以访问派生类到基类的转换（其实只要能访问到基类的<code class="language-c++ highlighter-rouge"><span class="k">public</span></code>成员即可，不管派生了多少层）</li>
    </ul>
  </li>
  <li>合成的默认ctor、copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>以及析构函数将对对象的基类部分连同派生部分的成员一起进行初始化、复制、赋值和撤销；自定义的copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>需要显式调用基类的copy ctor和<code class="language-c++ highlighter-rouge"><span class="o">=</span></code>或自己另行实现才能复制、赋值基类部分</li>
  <li>如果在构造函数或析构函数中调用虚函数（不论直接还是间接），则运行的是为构造函数或析构函数自身类型定义的版本。</li>
  <li>由于派生类的作用域嵌套在基类作用域中，在基类和派生类中使用同一名字的成员函数时，就像一般的在局部声明的函数和在全局声明的函数一样：在派生类作用域中派生类成员将屏蔽基类成员，即使函数原型不同。</li>
  <li>局部作用域中声明的函数不会重载外围作用域中定义的函数，而是会屏蔽！因此，若派生类定义了重载成员，则通过派生类（的对象、指针或引用）只能访问派生类中重定义的那些成员，不管基类中的成员是否为<code class="language-c++ highlighter-rouge"><span class="k">virtual</span></code>的！（可以通过<code class="language-c++ highlighter-rouge"><span class="k">using</span></code>声明解决这个问题）</li>
  <li>
    <p>通过基类可以调用被屏蔽的虚函数：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">();</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">D1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* 屏蔽了Base的fcn */</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">D2</span> <span class="o">:</span> <span class="n">D1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* 屏蔽了D1的fcn */</span>  <span class="kt">int</span> <span class="n">fcn</span><span class="p">();}</span>

<span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">D1</span> <span class="n">d1</span><span class="p">;</span>
<span class="n">D2</span> <span class="n">d2</span><span class="p">;</span>
<span class="n">Base</span> <span class="o">*</span><span class="n">bp1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">bp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">,</span> <span class="o">*</span><span class="n">bp3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">;</span>

<span class="n">bp1</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// Base::fcn
</span><span class="n">bp2</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// Base::fcn，注意不能用D1的对象、引用或指针调用fcn()，因为它被fcn(int)屏蔽了！
</span><span class="n">bp3</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span>  <span class="c1">// D2::fcn
</span></code></pre>
    </div>
  </li>
  <li>（名字查找与继承的关系）确定函数调用遵循以下四个步骤</li>
  <li>首先确定进行函数调用的对象、引用或指针的静态类型</li>
  <li>在该类中查找函数（名字），若找不到则从直接基类开始往上找，若最终找不到则出错</li>
  <li>一旦找到了该名字，就进行常规类型检查，看调用是否合法</li>
  <li>若合法，编译器就生成代码。若函数为虚且通过引用或指针调用，则编译器生成代码以确定根据对象的动态类型运行哪个函数版本，否则，编译器生成代码直接调用函数。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第09-13章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter09to13</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第9章 顺序容器</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第11章 泛型算法</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">第12章 类</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">第13章 复制控制</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第9章 顺序容器</h2>

<ol>
  <li>指定容器大小的类型应该使用该容器的<code class="language-c++ highlighter-rouge"><span class="n">size_type</span></code>类型</li>
  <li>允许通过使用内置数组中的一对指针初始化容器</li>
  <li>容器元素类型必须满足以下两个约束：
    <ul>
      <li>元素类型必须支持赋值运算（故不能是引用）</li>
      <li>元素类型的对象必须可以复制（用于初始化和<code class="language-c++ highlighter-rouge"><span class="n">push_back</span></code>等）</li>
    </ul>
  </li>
</ol>

<h2 id="section-1">第11章 泛型算法</h2>

<ol>
  <li>为了以降序排列<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>，只需向<code class="language-c++ highlighter-rouge"><span class="n">sort</span></code>传递一对反向迭代器<code class="language-c++ highlighter-rouge"><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span></code></li>
</ol>

<h2 id="section-2">第12章 类</h2>

<ol>
  <li>声明一个类而不定义它（即前向声明）时，该类是一个不完全类型，只能以有限方式使用：
    <ul>
      <li>不知道包含哪些成员</li>
      <li>只能用于定义指向该类型的指针及引用，或用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数</li>
      <li>不能用于定义数据成员或该类的对象（故类不能具有自身类型的数据成员）</li>
    </ul>
  </li>
  <li>在一个源文件中一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的</li>
  <li>在普通的非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>成员函数中，<code class="language-c++ highlighter-rouge"><span class="k">this</span></code>的类型是一个指向类类型的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针</li>
  <li>当我们希望类的数据成员（甚至在<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>成员函数内）可以被修改时，可将它们声明为<code class="language-c++ highlighter-rouge"><span class="k">mutable</span></code>。<code class="language-c++ highlighter-rouge"><span class="k">mutable</span></code>数据成员永远都不会且不能为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>。</li>
  <li>如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外（否则在之内）。</li>
  <li>在类定义体外定义的成员函数的返回类型如果使用由该类定义的类型，则必须使用完全限定名，这是因为在函数名被处理前，代码不在类作用域内。</li>
  <li>类定义实际上是在两个阶段中处理：
    <ol>
      <li>首先编译成员声明</li>
      <li>只有在所有成员出现之后，才编译它们的定义本身（因此成员函数可以使用类作用域中所有名字）</li>
    </ol>
  </li>
  <li>必须在类中先定义类型名字，才能将它们用作数据成员的类型，或者成员函数的返回类型或形参类型</li>
  <li>一旦一个名字被用作类型名，该名字就不能被重复定义。（但若一个名字在类外作用域中首先被定义为类型名，类中可以先重新定义它再用作类型名）。</li>
  <li>构造函数不能声明为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code></li>
  <li>对非类类型的数据成员进行赋值或使用初始化式在结果和性能上都是等价的</li>
  <li>
    <p>成员被初始化的次序就是定义成员的次序，不管它们在初始化列表中顺序如何。因此以下程序非法：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>当没有在初始化列表中指出或使用合成的默认构造函数时，对于内置和复合类型的成员（如指针和数组），只对定义在全局作用域中的对象才初始化。</li>
  <li>对于一个没有定义默认构造函数（显式或隐式地）的类：
    <ul>
      <li>不能用作动态分配数组的元素类型</li>
      <li>其静态分配数组必须为每个元素提供一个显式的初始化式</li>
    </ul>
  </li>
  <li>可以用单个实参来调用的非<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>构造函数定义了从形参类型到该类类型的一个隐式转换。</li>
  <li>友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。</li>
  <li>友元不是授予友元关系的那个类的成员，故它们不受其声明出现部分的访问控制影响。</li>
  <li>必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</li>
  <li>友元声明将已命名的类或非成员函数引入到外围作用域中。此外，友元函数可以在类的内部定义，该函数的作用域扩展到包围该类定义的作用域。用友元引入的类名和函数（定义或声明），可以像预先声明的一样使用。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="k">static</span></code>数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，但此时不必再指定初始值。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">static</span></code>数据成员的类型可以是该成员所属的类类型，并可用作默认实参。</li>
  <li>在构造函数初始化列表中除了默认的方式（如<code class="language-c++ highlighter-rouge"><span class="n">x</span><span class="p">()</span></code>）外，无法用其他方式（如传递一个数组）来初始化一个数组类型的成员变量。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">typedef</span></code>在类中必须出现在使用其定义的类型别名的声明之前。</li>
</ol>

<h2 id="section-3">第13章 复制控制</h2>

<ol>
  <li>复制构造函数、赋值构造函数和析构函数总称为复制控制（copy control），编译器自动实现这些操作，但类也可以定义自己的版本。</li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span></code>，在创建<code class="language-c++ highlighter-rouge"><span class="n">str</span></code>时，编译器首先调用接受一个c风格字符串形参的<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>构造函数，创建一个临时对象，然后编译器使用<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>复制构造函数将<code class="language-c++ highlighter-rouge"><span class="n">str</span></code>初始化为那个临时对象的副本。</li>
  <li>对于语句<code class="language-c++ highlighter-rouge"><span class="n">C</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span></code>，<code class="language-c++ highlighter-rouge"><span class="n">ci</span></code>的初始化是否正确取决于两点：
    <ul>
      <li>类C的带一个<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>形参的ctor是否为<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>（如果是<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>则失败）</li>
      <li>类C的copy ctor对当前作用域是否可见</li>
    </ul>
  </li>
  <li>
    <p>若使用元素初始化列表初始化数组元素，则首先根据指定值创建数组元素类型的元素，然后用复制构造函数将该值复制到相应元素：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">C</span> <span class="n">ci</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span>  <span class="c1">// 单参数ctor + copy ctor
</span>  <span class="n">C</span><span class="p">()</span>  <span class="c1">// 默认ctor + copy ctor
</span><span class="p">};</span>
</code></pre>
    </div>
  </li>
  <li>合成的复制构造函数将复制数组类型成员的每一个元素，合成的复制操作符也会给数组的每个元素赋值。</li>
  <li>当copy ctor定义为<code class="language-c++ highlighter-rouge"><span class="k">explicit</span></code>时，就不能用于向函数传递对象和从函数返回对象。</li>
  <li>容器（不管是标准库容器还是内置数组）中的元素总是按逆序撤销</li>
  <li>合成析构函数按对象创建时的逆序撤销每个非<code class="language-c++ highlighter-rouge"><span class="k">static</span></code>成员（即按类中成员声明次序的逆序）</li>
  <li>因为不能指定任何形参，所以不能重载析构函数</li>
  <li>即使我们编写了自己的析构函数，合成的析构函数仍然运行。</li>
  <li>自定义的copy ctor必须是引用传递形参（而不是传值），否则会导致无限递归。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第05-08章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter05to08/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter05to08</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第5章 表达式</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第6章 语句</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">第7章 函数</a></li>
  <li><a href="#io" id="markdown-toc-io">第8章 标准I/O库</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第5章 表达式</h2>

<ol>
  <li>若两个操作数都是负数则求模结果为负。</li>
  <li>逻辑非：若操作数非零值则结果为<code class="language-c++ highlighter-rouge"><span class="nb">false</span></code>。</li>
  <li>如果<code class="language-c++ highlighter-rouge"><span class="n">val</span></code>不是<code class="language-c++ highlighter-rouge"><span class="kt">bool</span></code>类型，不要这样比较：<code class="language-c++ highlighter-rouge"><span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span></code></li>
  <li>如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器，不可移植</li>
  <li>移位操作的右操作数不可为负且必须严格小于左操作数位数值，否则结果未定义</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">sizeof</span></code>是一个操作符，其结果是编译时常量。三种用法：
    <ul>
      <li><code class="language-c++ highlighter-rouge"><span class="k">sizeof</span><span class="p">(</span><span class="n">type</span> <span class="n">name</span><span class="p">)</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="k">sizeof</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="k">sizeof</span> <span class="n">expr</span></code>
将<code class="language-c++ highlighter-rouge"><span class="k">sizeof</span></code>用于<code class="language-c++ highlighter-rouge"><span class="n">expr</span></code>时，并没有计算<code class="language-c++ highlighter-rouge"><span class="n">expr</span></code>的值</li>
    </ul>
  </li>
  <li>逗号表达式从左向右计算，结果是其最右边表达式的值。如果最右边的操作数的左值，则逗号表达式的值也是左值。</li>
  <li>
    <p>值初始化的<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>语法必须置于类型名后面，而不是变量后。如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">();</span>
</code></pre>
    </div>
    <p>上式声明了一个名为<code class="language-c++ highlighter-rouge"><span class="n">x</span></code>、没有参数而返回<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>值的函数，而不是定义一个变量。</p>
  </li>
  <li>c++保证：删除0值的指针是安全的，但这样做没有任何意义。</li>
  <li>删除指针后，该指针编程悬垂指针，不再有效。</li>
  <li>动态创建<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象的例子：<code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="n">cons</span> <span class="n">tint</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span></code></li>
  <li>删除动态分配的内存失败称为“内存泄露”</li>
  <li>类类型可以定义由编译器自动执行的类型转换，如：<code class="language-c++ highlighter-rouge"><span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">...</span></code></li>
  <li>显式转换也称为强制类型转换（cast），包括：dynamic_cast，const_cast，static_cast，reinterpret_cast。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span></code>在编译时会出现警告，改成<code class="language-c++ highlighter-rouge"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span></code>就没问题。</li>
  <li>
    <p><code class="language-c++ highlighter-rouge"><span class="k">sizeof</span><span class="p">(</span><span class="n">func</span><span class="p">());</span></code>的结果是<code class="language-c++ highlighter-rouge"><span class="n">func</span></code>函数的返回类型的size，且不执行<code class="language-c++ highlighter-rouge"><span class="n">func</span></code>。注意，不能这样用：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">sizeof</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
</code></pre>
    </div>
    <p>。因为<code class="language-c++ highlighter-rouge"><span class="n">func</span></code>是函数类型，而<code class="language-c++ highlighter-rouge"><span class="k">sizeof</span></code>不支持函数类型，<code class="language-c++ highlighter-rouge"><span class="n">func</span><span class="p">()</span></code>才是数据类型。</p>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span><span class="p">();</span></code>的作用是声明一个函数而不是定义一个变量（如果想定义一个使用默认构造函数的对象，正确写法是<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span><span class="p">;</span></code>）。但如果是<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span></code>则相反，因为编译器看到了<code class="language-c++ highlighter-rouge"><span class="s">"abc"</span></code>是一个量而不是一个变量声明。另外可以这么干：<code class="language-c++ highlighter-rouge"><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">string</span><span class="p">();</span></code>。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">for</span> <span class="p">(;;);</span></code>是一个死循环；<code class="language-c++ highlighter-rouge"><span class="k">for</span></code>语句只要中间不写东西就是，这是合法的。省略循环条件等效于其永远为<code class="language-c++ highlighter-rouge"><span class="nb">true</span></code>。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'x'</span><span class="p">;</span></code>会导致segment fault。</li>
  <li>大多数操作符没有定义左右操作数的求值顺序，故不能依赖它来编写程序。</li>
</ol>

<h2 id="section-1">第6章 语句</h2>

<ol>
  <li>空语句，如：<code class="language-c++ highlighter-rouge"><span class="k">while</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span></code>；又如：<code class="language-c++ highlighter-rouge"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;;</span></code>。后者由两条语句组成：一条表达式语句和一条空语句。</li>
  <li>
    <p>在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。如：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">val</span><span class="p">)</span> <span class="p">...;</span>
<span class="k">switch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="p">())</span> <span class="p">...;</span>
</code></pre>
    </div>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">switch</span></code>语句的每个<code class="language-c++ highlighter-rouge"><span class="k">case</span></code>的标号必须是整型常量表达式，浮点数也不行！任两个<code class="language-c++ highlighter-rouge"><span class="k">case</span></code>标号不能有相同的值，否则compile error。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">switch</span></code>结构中，除非使用块语句，否则只能在它的最后一个<code class="language-c++ highlighter-rouge"><span class="k">case</span></code>或<code class="language-c++ highlighter-rouge"><span class="k">default</span></code>标号后才能定义变量。</li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">do</span><span class="p">...</span><span class="k">while</span></code>中的<code class="language-c++ highlighter-rouge"><span class="k">continue</span></code>会继续求解循环条件（和<code class="language-c++ highlighter-rouge"><span class="k">while</span></code>一样）</li>
  <li>
    <p>使用预处理器进行调试：<code class="language-c++ highlighter-rouge"><span class="gp">$ </span>cc -DNDEBUG main.c</code></p>

    <p>这等效于在main.c的开头提供<code class="language-c++ highlighter-rouge"><span class="cp">#define NDEBUG</span></code>预处理命令。</p>
  </li>
</ol>

<h2 id="section-2">第7章 函数</h2>

<ol>
  <li>函数由函数名以及一组操作数类型唯一地表示</li>
  <li>
    <p>在c语言中具有<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>形参或非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>形参的函数并无区别（引用和指针除外），故：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fcn</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">fcn</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
</code></pre>
    </div>
    <p>会产生编译错误：重定义。c++为了兼容也保持这点。</p>
  </li>
  <li>由于数组不能复制，所以无法编写使用数组类型形参的函数，而函数也不允许返回一个数组！</li>
  <li>由于使用数组名字时，数组会被自动转化为指针，所以处理数组的函数通常通过操纵指向数组中的元素的指针来处理数组。</li>
  <li>
    <p>虽然不能直接传递数组，但形参可以写成数组形式，下面三种定义是等价的，形参类型都是<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="o">*</span></code>：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">[])</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{...}</span>
</code></pre>
    </div>
    <p>编译器只会检查实参是不是指针、指针类型是否匹配，而不会检查数组的长度。故对于以上第三种定义可以传个<code class="language-c++ highlighter-rouge"><span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></code>进去。</p>
  </li>
  <li>
    <p>一般用法：传非引用指针：<code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="nf">func</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">{...}</span></code>。
也可通过引用传递，此时编译器将检查数组实参的大小与形参大小是否匹配：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{...}</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>多维数组的传递：c++中没有多维数组，所谓多维数组实际上是一个一维数组，其元素是由数组组成。因此，除了第一维以外的所有维的长度都是元素类型的一部分，必须明确指定：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">[][</span><span class="mi">10</span><span class="p">])</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">10</span><span class="p">])</span> <span class="p">{...}</span>
</code></pre>
    </div>
    <p>上述三种定义是等价的。<code class="language-c++ highlighter-rouge"><span class="mi">100</span></code>，类似地，将会被忽略。</p>
  </li>
  <li>关于可变形参：对于c++程序，只能将简单数据类型传递给含有省略符形参，实际上，当需要传递给省略符形参时，大多数类类型对象都不能正确地复制</li>
  <li>返回类型为<code class="language-c++ highlighter-rouge"><span class="kt">void</span></code>的函数可以<code class="language-c++ highlighter-rouge"><span class="k">return</span></code>另一个返回类型同样是<code class="language-c++ highlighter-rouge"><span class="kt">void</span></code>的函数的调用结果</li>
  <li>函数的返回值用于初始化在调用函数处创建的临时对象。当返回引用类型时，没有复制返回值，而是返回对象本身。</li>
  <li>函数声明时需提供：返回类型、函数名、形参列表（不必对形参命名）。这三个元素成为函数原型。</li>
  <li>默认实参可以是任何适当类型的表达式（包括函数调用）。</li>
  <li>
    <p>可在函数声明也可在函数定义中指定默认实参，但在一个文件中只能为一个形参指定默认实参一次（因此h和cc只能有一个这么干，因为cc包含了h）。如果在函数定义中指定默认实参，那么只有在包含该函数定义的源文件中调用该函数时（被指定的默认实参）才有效。在声明时指定默认实参可以类似于这么干：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>只有当定义它的函数被调用时才存在的对象成为自动对象。</li>
  <li>内联函数应该在头文件中定义，这一点不同于其他函数。这是因为，内联函数的定义对编译器而言必须是可见的，以便编译器能够在调用点内联展开该函数的代码。</li>
  <li>由编译器自动生成的默认构造函数对内置类型成员的初始化规则：
    <ol>
      <li>若该类的对象被定义于全局作用域或定义为局部静态对象，这些成员被初始化为0</li>
      <li>否则没有初始化</li>
    </ol>

    <p>另可参考《深度探索c++对象模型》</p>
  </li>
  <li>重载函数：出现于相同作用域中（当作用域不同时会发生名字屏蔽而不是重载），名字相同而形参表不同（默认实参不改变形参表）。注意，重载函数可以有不同的返回类型。</li>
  <li>在c++中，名字查找发生在类型检查之前。</li>
  <li>形参与<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>形参的等价性仅适用于非引用形参，有<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用的形参与有非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用形参的函数是不同的，对于<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针和非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针也是不同的。（即：仅当形参是引用或指针时，形参是否为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>才有影响）</li>
  <li>局部声明的名字会屏蔽全局声明的同名名字（包括函数名，此时，只要同名就会屏蔽，不管形参如何）</li>
  <li>重载确定的寻找最佳匹配方法：若仅有一个函数满足以下条件则ok，否则编译错误：
    <ul>
      <li>其每个实参的匹配都不劣于其他可行函数需要的匹配</li>
      <li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
    </ul>
  </li>
  <li>重载确定（overload resolution）的三个步骤：
    <ol>
      <li>确定候选函数（candidate function）集：与被调函数同名的函数的集合（声明要在调用点可见；如果调用的是类的成员函数则不考虑访问控制符如<code class="language-c++ highlighter-rouge"><span class="k">public</span></code>、<code class="language-c++ highlighter-rouge"><span class="k">private</span></code>等，而是将该类的所有同名函数都取出拿来用）</li>
      <li>选择可行函数（viable function），两个条件：
        <ul>
          <li>函数的形参个数与该调用的实参个数相同</li>
          <li>每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型</li>
        </ul>
      </li>
      <li>寻找最佳匹配：先为每个实参划分等级，再按照第下述方法做。</li>
    </ol>
  </li>
  <li>为了确定最佳匹配，编译器将实参到形参的类型转换划分等级：
    <ol>
      <li>精确匹配</li>
      <li>通过类型提升（promotion）实现的匹配，包括整形提升：<code class="language-c++ highlighter-rouge"><span class="kt">char</span></code>、<code class="language-c++ highlighter-rouge"><span class="kt">signed</span> <span class="kt">char</span></code>、<code class="language-c++ highlighter-rouge"><span class="kt">unsigned</span> <span class="kt">char</span></code>、<code class="language-c++ highlighter-rouge"><span class="kt">short</span></code>和<code class="language-c++ highlighter-rouge"><span class="kt">unsigned</span> <span class="kt">short</span></code>提升为<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>，其次是提升为<code class="language-c++ highlighter-rouge"><span class="kt">unsigned</span> <span class="kt">int</span></code>。如，对于
<code class="language-c++ highlighter-rouge"><span class="n">func</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span></code>来说，<code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span></code>要优于<code class="language-c++ highlighter-rouge"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span></code>。</li>
      <li>通过标准转换实现的匹配</li>
      <li>数组-&gt;指针，指针-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">void</span><span class="o">*</span></code>，<code class="language-c++ highlighter-rouge"><span class="mi">0</span></code>-&gt;指针</li>
      <li>算术值和指针-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">bool</span></code></li>
      <li>算术值&lt;-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">bool</span></code></li>
      <li><code class="language-c++ highlighter-rouge"><span class="k">enum</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>或更高</li>
      <li>非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>-&gt;<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用；非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针-&gt;<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针</li>
      <li>由标准库类型定义的转换</li>
      <li>通过类类型转换实现的匹配</li>
    </ol>
  </li>
  <li>
    <p>不能通过基于指针本身是否为<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>来实现函数重载（这符合第19点）：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="k">const</span><span class="p">);</span>  <span class="c1">// 错误，重声明
</span></code></pre>
    </div>
  </li>
  <li>
    <p>函数指针：在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，故以下两句赋值含义相同：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">funcptr</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="n">funcpty</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">;</span>
</code></pre>
    </div>
    <p>故调用时也相同：<code class="language-c++ highlighter-rouge"><span class="n">p1</span> <span class="p">(</span><span class="n">params</span><span class="p">);</span></code>等价于<code class="language-c++ highlighter-rouge"><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)(</span><span class="n">params</span><span class="p">);</span></code></p>
  </li>
  <li>指向不同函数类型（包含返回类型的定义）的指针指针之间不存在转换。</li>
  <li>
    <p>函数指针作为形参时，以下两种形式等价：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">bool</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>返回类型中的函数指针的例子：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ff</span><span class="p">(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre>
    </div>
    <p>。其中，<code class="language-c++ highlighter-rouge"><span class="n">ff</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code>是一个函数，它返回一个函数指针，其类型为<code class="language-c++ highlighter-rouge"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span></code>。</p>
  </li>
  <li>函数的返回类型不能是一个函数，最多只能是一个函数指针！！</li>
  <li>
    <p>若类<code class="language-c++ highlighter-rouge"><span class="n">A</span></code>有个带一个<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>参数的ctor，则以下函数定义是合法的：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">A</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
    </div>
  </li>
  <li>如果一个类定义了一个非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>函数以及对应的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>函数，是合法的，C++将其看成重载，不会引起编译错误。对于这点，我的理解是，C++会将成员函数重写为包含指向对象本身的隐含<code class="language-c++ highlighter-rouge"><span class="k">this</span></code>指针的函数，这样，<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>成员函数就会变成<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象指针，根据第19点这是可以被重载的。</li>
</ol>

<h2 id="io">第8章 标准I/O库</h2>

<ol>
  <li>IO对象不可复制或赋值，这表示着：
    <ul>
      <li>不能存储在容器中</li>
      <li>函数的形参或返回类型不能是非指针或引用的流类型</li>
    </ul>
  </li>
  <li>
    <p>刷新输出缓冲区的方法：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"hi"</span> <span class="o">&lt;&lt;</span> <span class="n">flush</span><span class="p">;</span>  <span class="c1">// 不增加任何数据
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"hi"</span> <span class="o">&lt;&lt;</span> <span class="n">ends</span><span class="p">;</span>  <span class="c1">// 增加null字符
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"hi"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>如果一个流调用<code class="language-c++ highlighter-rouge"><span class="n">tie</span></code>函数将其本身绑在传递给<code class="language-c++ highlighter-rouge"><span class="n">tie</span></code>的<code class="language-c++ highlighter-rouge"><span class="n">ostream</span></code>实参对象上，则该流上任何IO操作都会刷新实参所关联的缓冲区。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>《C++ Primer》读书笔记（第01-04章）</title>
      <link>http://localhost:4000/2013/09/c++-primer-notes-chapter01to04/</link>
      <pubDate>2013-09-20T00:00:00-07:00</pubDate>
      <author>lambda</author>
      <guid>http://localhost:4000/2013/09/c++-primer-notes-chapter01to04</guid>
      <content:encoded><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">第1章 快速入门</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">第2章 变量和基本类型</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">第3章 标准库类型</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">第4章 数组和指针</a></li>
</ul>

<p><!--  Not show line_numbers  -->
</p>

<h2 id="section">第1章 快速入门</h2>

<ol>
  <li>Windows下查看程序返回值：<code class="language-c++ highlighter-rouge"><span class="nb">echo</span> %ERRORLEVEL%</code></li>
  <li>endl是一个特殊值，称为操纵符（manipulator），将其写入输出流时将会输出换行效果并刷新与设备相关联的缓冲区</li>
  <li><code class="language-c++ highlighter-rouge"><span class="s">"A"</span></code>表示包含字母A和空字符两个字符的字符串</li>
  <li>宽字符：<code class="language-c++ highlighter-rouge"><span class="n">wchat_t</span> <span class="n">ch</span><span class="o">=</span><span class="sc">L'a'</span><span class="p">;</span></code></li>
  <li>宽字符串：<code class="language-c++ highlighter-rouge"><span class="s">L"hello"</span></code>（包含了最后的宽空字符）</li>
</ol>

<h2 id="section-1">第2章 变量和基本类型</h2>

<ol>
  <li>变量名不能包含两个连续的下划线，也不能以下划线开头后面紧跟一个大写字母</li>
  <li>定义和声明的区别：
    <ul>
      <li>定义：为变量分配存储空间，还可以为变量指定初值</li>
      <li>声明：用于向程序表明变量的类型和名字</li>
    </ul>
  </li>
  <li>定义也是声明：当定义变量时我们声明了它的类型和名字</li>
  <li>
    <p>如果声明有初始化式，那么它可被当作是定义，即使被标记为<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>。如：</p>

    <p><code class="language-c++ highlighter-rouge"><span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></code></p>
  </li>
  <li>只有当<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>声明位于函数外部时，才可以含有初始化式（此时被当成定义）</li>
  <li>与一般的变量不同，在全局作用域声明的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。除非定义时加上<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>。</li>
  <li>引用是一种复合类型（是指用其他类型定义的类型）</li>
  <li>
    <p><code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre>
    </div>
    <p>但同样的初始化对于非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用都是不合法的，因为对于：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span>
</code></pre>
    </div>
    <p>编译器会将其变成：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre>
    </div>
    <p>如果<code class="language-c++ highlighter-rouge"><span class="n">ri</span></code>不是<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>，则可对其赋值，但不会修改<code class="language-c++ highlighter-rouge"><span class="n">dval</span></code>，矛盾。</p>
  </li>
  <li>非<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>的引用只能绑定到与该引用同类型的对象；<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>引用则可以绑定到不同但类型相关的对象或右值。</li>
  <li>枚举成员的值可以不唯一，如：<code class="language-c++ highlighter-rouge"><span class="k">enum</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d</span> <span class="p">};</span></code>其中<code class="language-c++ highlighter-rouge"><span class="n">b</span></code>和<code class="language-c++ highlighter-rouge"><span class="n">c</span></code>都是3。</li>
  <li>不能把<code class="language-c++ highlighter-rouge"><span class="kt">int</span></code>等类型赋值给枚举类型的对象</li>
  <li>用于初始化的值必需是一个常量表达式，即在编译时就可以计算出值的表达式</li>
  <li>头文件一般包含：类的定义、<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>变量的声明和函数的声明</li>
  <li>对于“头文件不应含有定义”这一规则，有三个例外：头文件可以定义类、值在编译时就已知的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象和<code class="language-c++ highlighter-rouge"><span class="kr">inline</span></code>函数。这些实体可在多个源文件中定义，只要在每个源文件中的定义是相同的。p68</li>
  <li>当在头文件中定义了<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量后，每个包含该头文件的源文件都有了自己的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量，其名称和值都一样；定义在头文件中的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量应该是常量表达式。</li>
  <li>若<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量不是用常量表达式初始化，就不应在头文件中定义，而应在源文件中定义并初始化，并添加<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>使其被多个文件共享。</li>
  <li>若在头文件中定义<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>的<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量，多个cc文件都<code class="language-c++ highlighter-rouge"><span class="cp">#include</span></code>了这个头文件且其obj会被链接到一起时，会出错：重定义。原因：这些cc文件引用头文件后相当于在文件中定义了这个<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>变量，但由于加了<code class="language-c++ highlighter-rouge"><span class="k">extern</span></code>，使其全局可见。</li>
  <li>
    <p>可以声明引用，例如在a.cc中定义：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ra</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre>
    </div>
    <p>则可以在a.h中声明：<code class="language-c++ highlighter-rouge"><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ra</span><span class="p">;</span></code></p>
  </li>
  <li>
    <p>逗号表达式与定义，以下是合法的：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
</ol>

<h2 id="section-2">第3章 标准库类型</h2>

<ol>
  <li><code class="language-c++ highlighter-rouge"><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span></code>：<code class="language-c++ highlighter-rouge"><span class="n">getline</span></code>遇到第一个换行符就中止，即使<code class="language-c++ highlighter-rouge"><span class="n">cin</span></code>的第一个字符就是</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">string</span></code>的“+”操作符左右两边必须至少有一个是<code class="language-c++ highlighter-rouge"><span class="n">string</span></code>类型</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">string</span></code>对象的下标变量应为<code class="language-c++ highlighter-rouge"><span class="n">string</span><span class="o">::</span><span class="n">size_type</span></code></li>
  <li>注意区分<code class="language-c++ highlighter-rouge"><span class="n">const_iterator</span></code>和<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>的<code class="language-c++ highlighter-rouge"><span class="n">iterator</span></code></li>
  <li>任何改变<code class="language-c++ highlighter-rouge"><span class="n">vector</span></code>长度的操作都会使已存在的迭代器失效。</li>
</ol>

<h2 id="section-3">第4章 数组和指针</h2>

<ol>
  <li>数组元素的类型不能是引用</li>
  <li>如果没有显式提供元素初值，数组元素会像普通变量一样初始化（2.3.4节）：
    <ul>
      <li>在函数体外定义的内置数组，元素均初始化为0</li>
      <li>在函数体内定义的内置数组，元素无初始化</li>
      <li>不管数组在哪定义，若其元素为类类型，则用default constructor来初始化；若该类没有default constructor，则必须显式初始化。</li>
    </ul>
  </li>
  <li>
    <p>字符数组：字符串的字面值包含一个额外的<code class="language-c++ highlighter-rouge"><span class="n">null</span></code>字符</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">ca1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'+'</span> <span class="p">};</span>  <span class="c1">//长度为3
</span><span class="kt">char</span> <span class="n">ca2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"c++"</span><span class="p">;</span>  <span class="c1">//长度为4
</span><span class="kt">char</span> <span class="n">ca3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"c++"</span><span class="p">;</span>  <span class="c1">//编译错误
</span></code></pre>
    </div>
  </li>
  <li>对指针进行初始化和赋值只能使用：
    <ul>
      <li>0值常量表达式</li>
      <li>类型匹配的对象地址</li>
      <li>另一对象之后的下一地址</li>
      <li>同类型的另一个有效指针</li>
    </ul>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="kt">void</span><span class="o">*</span></code>指针可以保存任何类型对象的地址，不允许使用<code class="language-c++ highlighter-rouge"><span class="kt">void</span><span class="o">*</span></code>指针操纵它指向的对象</li>
  <li>两个指针减法操作的结果是标准库类型<code class="language-c++ highlighter-rouge"><span class="kt">ptrdiff_t</span></code>的数据。</li>
  <li>与任何<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>量一样，<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>指针也必须在定义时初始化。</li>
  <li>
    <p>考虑如下代码：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">string</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span><span class="p">;</span>
</code></pre>
    </div>
    <p>这里<code class="language-c++ highlighter-rouge"><span class="k">const</span></code>修饰的是<code class="language-c++ highlighter-rouge"><span class="n">pstring</span></code>类型，这是一个指针。因此上述定义等价于</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="o">*</span> <span class="k">const</span> <span class="n">cstr</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>可以在数组长度后加<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>来对数组元素做值初始化：</p>

    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>  <span class="c1">// 初始化为0
</span></code></pre>
    </div>
    <p>若不加<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>对于内置类型是不初始化的，也不能用初始化列表。</p>
  </li>
  <li><code class="language-c++ highlighter-rouge"><span class="k">const</span></code>对象的动态数组对于内置类型一定要加<code class="language-c++ highlighter-rouge"><span class="p">()</span></code>。</li>
  <li>c++允许动态分配空数组</li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
