---
layout: post
title: 《Linux程序设计》（第四版）笔记
date: 2017-07-12 00:00:00 +0000
categories:
    - 程序&设计
tags:
    - Linux
    - 程序设计
    - 读书笔记
---

{::comment} Not show line_numbers {:/comment}
{::options syntax_highlighter_opts="{default_lang: sh \}" /}

- 1.2.4 静态库也称归档文件（archive），按惯例它们的文件名都以.a结尾。命令`gcc -c`和`ar`命令用于建立它们
- 1.2.4 `nm`命令：查看哪些函数被包含在目标文件、函数库或可执行文件
- 1.2.4 静态库的缺点：当运行的许多程序都是用同一函数库的函数时内存中会有同一函数的多份副本，程序文件中也有多份副本
- 2.6.1 shell环境变量：`$0`是shell脚本名字，`$#`是传递给脚本的参数个数，`$$`是shell脚本进程号，`$?`是返回值，`$*`是所有参数（由IFS第一个字符分割），`$@`类似于`$*`只是总是以空格分开各参数
- 2.6.3 `{}`或`()`包含的语句块的执行结果由其最后一条语句的执行结果决定（注意与`if`等条件判断的混合使用）
- 2.6.4 `return`命令可以返回数字值，如果无`return`则函数的返回值是执行的最后一条命令的退出码
- 2.6.5 `break`命令可以指定一个额外数值参数表示需要跳出的循环层数
- 2.6.5 `.`命令用于在当前shell中执行命令，如`. ./shell_script.sh`
- 2.6.5 `exec`命令将当前shell替换为一个不同的程序，也可以用于修改当前文件描述符；`shift`命令将所有参数变量左移一个位置；`trap`命令用于指定在接收到信号后采取的行动；`unset`在环境中删除变量或函数
- 2.6.6 参数扩展：
   - `${#param}`给出长度
   - `${param%word}`尾部删除最小匹配
   - `${param#word}`头部删除最小匹配
   - `${param:offset:len}`选择子串（`len`可选）
   - `${param/pattern/str}`替换最长匹配（`str`可选）
   - `${param//pattern/str}`替换所有匹配（`str`可选）
   - `${var:?string}`若变量`var`不为空，则用变量`var`的值来替换`${var:?string}`；若`var`不存在或为空时输出`var:string`并异常终止
   - `${var:+string}`存在且不为空时返回`string`
   - `${var:-string}`若变量`var`为空，则用在命令行中用`string`来替换`${var:-string}`，否则变量`var`不为空时，则用变量`var`的值来替换
   - `${var:=string}`和`${var:-string}`类似，不同之处是若`var`为空时，用`string`替换`${var:=string}`的同时，把`string`赋给变量`var`
- 其他非书中所述的bash特性也一并写在这里：
   - `if`的条件中，`＝`用于比较字符串；`-eq`用于比较整型数。
   - `$[a+1]` vs. `$((a+1))` vs. `expr '$a+1'` vs. `bc`: `$[]`访问变量要加`$`，`(())`不用
   - `let`等价于用于数学表达式中的`(())`
   - `$(())`是把`(())`中的值取出来
   - `()`和`{}`的区别
     - `()`只是对一串命令重新开一个子shell进行执行，`{}`对一串命令在当前shell执行
     - `()`最后一个命令可以不用分号，`{}`最后一个命令要用分号
     - `{}`的第一个命令和左括号之间必须要有一个空格，`()`里的各命令不必和括号有空格
   - `$()`只取标准输出而不取标准错误的内容？！
   - `${#*}`和`${#@}`是位置参量的个数，为`${#param}`的特例
   - `${param:3:5}` 替换为变量的第3个字符到第5个字符
   - 命令`dirname`返回操作数表示的文件（夹）所在的目录
   - 传命令参数时，`"${a}"`表示把变量a的值作为一个整体（即一个参数）传给命令行，而`${a}`则表示如果`a`里面有空格就分割为多个参数传给命令行！
   - 在一个命令前加反斜杠可以去掉其`alias`的效果，例如有`alias ls='ls --color'`那么`\ls`表示原来的`ls`命令而不是`alias`后的命令
- 2.6.7 `here`文档：`<<`操作符；`ed`编辑器！！！
- 2.8 `cut`命令用于截取一列以空格（或其他字符？）分隔的字符串
- 3.1 `/dev/tty`为当前终端文件
- 3.4.1 处理被缓冲的输出时，当程序退出时文件描述符会被自动关闭吗？
- 3.4.3 文件操作的`open`调用是一个原子操作
- 3.5.5 `fclose`函数隐含执行了`flush`操作
- 3.6.1 标准库的`printf`等格式化输出可以输出可变长度字符串，如`printf("%*s", 20, "hello");`
- 3.6.2 格式化输入：`%o`和`%x`读取八进制或十六进制整数，`%f`和`%e`和`%g`读取浮点数，`%c`读取字符时不会忽略空格，`%[]`读取字符集合入`%[A-Z]`，`%%`读取百分号
- 3.7.3 先`open`再`unlink`是创建临时文件的技巧
- 3.10 `/proc/cpuinfo`，`/proc/数字`表示进程id为给定数字的进行信息
- 3.11 `fcntl`和`mmap`内存映射
- 4.1 `getopt`函数用于处理输入参数
- 5.1 终端输入的规范模式或标准模式：所有输入都基于行进行处理；非标准模式则有更大控制权
- 5.4 POSIX规范的终端处理标准接口：`termios`
- 6 curses库
- 7.1 `calloc`按照元素类型和个数的方式分配内存且全部初始化为0，`realloc`
- 7.2 用`open`系统调用创建文件锁；`fcntl`可以锁定文件一部分
- 9.2 makefile的出现在命令前的特殊字符：`-`告诉make忽略所有错误；`@`告诉make在执行某条命令前不要将该命令显示在标准输出上
- 10.3.8 程序运行失败时，Linux系统通常会产生一个核心转储（core dump），并将它保存在core文件中，这个文件其实是程序的内存映像文件，它包含程序在运行失败的那个时刻的全局变量的取值
- 10.4.2 `cflow`程序打印出一个函数调用树，它显示了函数之间的调用关系
- 10.6.2 `valgrind`是一个内存调试工具，可以检测出数组访问错误和内存泄露
- 11 进程和信号
- 12.3 通过定义宏`_REENTRAN`来告诉编译器我们需要可重入功能
- 12.6 脱离线程（detached thread）
- 13 匿名管道：标准库的`popen`和`pclose`函数，unistd.h的`pipe`、`dup`和`dup2`函数；命名管道FIFO：`mkfifo`，`mknod`
- 14 Dekker算法，IPC：信号量、共享内存和消息队列
- 15 套接字
- 18 Linux标准化规范（LSB）：www.linux-foundation.org
- 18.1 gcc的警告选项：`-pedantic`检查代码的最强大编译器选项，`-Wall`启用绝大多数gcc警告

