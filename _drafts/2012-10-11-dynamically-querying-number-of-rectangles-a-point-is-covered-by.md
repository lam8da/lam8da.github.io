---
layout: post
title: 动态查询矩形覆盖次数
categories:
    - 算法&数学
tags:
    - Work in Progress
    - 面试题
    - 算法
---

{::comment} Not show line_numbers {:/comment}
{::options syntax_highlighter_opts="{default_lang: c++ \}" /}

1. TOC
{:toc}

这也是一道笔试题，来自G公司。题目大意是这样的：平面上有固定的\\(n\\)个矩形，每个的左下角右上角坐标给出（均为整数）。然后开始动态询问，每次给定一个1*1的单位矩形，问这个矩形被之前的\\(n\\)个矩形覆盖了多少次？

姑且把上述问题看成问题一。我又自作聪明地修改了一下，得到以下几个改版问题：

问题二：如果反过来，给定的是\\(n\\)个1*1单位矩形，而每次询问时给一个大小位置未定的矩形，问该矩形包含了多少个单位矩形，那该怎么做？
问题三：

原问题解答

这题是经典的线段树问题。使用\\(n\\)颗线段树，或者使用二维线段树，甚至使用\\(n\\)个一维的或者一个二维的树状数组，应该都能解答，其本质大同小异。我要说的是不使用这些fancy的数据结构的方法。

如果矩形的坐标位置在一个大的范围内取值，首先需要离散化。这步就不多说了，因为预处理只会增加\\(n\log
n\\)的复杂度，而查询也就只增加\\(\log
n\\)的复杂度。所以以下假设坐标范围在[0,n]以内，即不需要离散化。此时，我们可以建立一个二维int数组\\(mat\\)，大小为\\(n\cdot
n\\)。首先令\\(mat\\)的所有元素均为0，然后对每一个矩形，假设其左下角坐标为\\((x_1,y_1)\\)，右上角坐标为\\((x_2,y_2)\\)，其中\\(x_1<x_2\\)且\\(y_1<y_2\\)，则进行如下操作：

mat[x1][y1] += 1;
mat[x1][y2+1] -= 1;
mat[x2+1][y1] -= 1;
mat[x2+1][y2+1] += 1;
然后对\\(mat\\)进行求部分和的操作，得出一个\\(mat'\\)，即令\\(mat'[i][j]=\sum_{k=0}^i\sum_{l=0}^j
mat[k][l]\\)。于是此时\\(mat'[i][j]\\)就表示了单位矩形\\((i,j)-(i+1,j+1)\\)被覆盖的次数。

问题二解答

以下方法原创于cc同学，其实也不难。一开始的离散化就不说了，要注意的是离散化时需要在所有（只看一个维度的）最近的两个点之间放多一个空隙，这是因为查询的矩形的边界不一定落在\\(n\\)个单位矩形的边界上。然后建一个二维表，一开始全为0，然后每个单位矩形对应的位置+1，然后对该表求一个二维的前缀和。查询时，用\\(\log(n)\\)时间找出矩形边界所对应的离散化后的值，然后得到四个点，加减法求一下和即可。这个方法的预处理时间和空间复杂度都是\\(O(n^2)\\)，查询复杂度是\\(O(\log(n)\\)。

有没有预处理复杂度低点的方法呢？必须有的。
